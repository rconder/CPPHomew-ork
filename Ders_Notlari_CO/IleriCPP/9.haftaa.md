# 9.Hafta

- 15.Ders ve 16.Ders notları.

## İçindekiler

- [9.Hafta](#9hafta)
  - [İçindekiler](#i̇çindekiler)
  - [std::format Kütüphanesi](#stdformat-kütüphanesi)
    - [Custom Fomratting](#custom-fomratting)
    - [vFormat Fonksiyonu](#vformat-fonksiyonu)
  - [Aggregate Type](#aggregate-type)
    - [Semantik tarafı](#semantik-tarafı)
    - [Koşulları](#koşulları)

---

> 19_08_2023

---

## std::format Kütüphanesi

`[[fill]align] [sign][#][0][width][.precision][type]`

### Custom Fomratting

- Parso fonksiyonun normalde `constexpr` fonksiyon olması bekleniyor, fakat bazı derleyiciler bu fonkksiyonun `constexpr` olması durumunda hata veriyor.
- - Parametresi `std::format_parse_context &` türünden olmalı, geri dönüş değeri de bu sınıfın `iterator` türünden olmalı.
- - `"{:12}"` elimizde olsun ve `begin()` fonksiyonu burada `12}`nin başını gösteriyor. `end()` fonksiyonu ise yazının sonunu gösteriyor. `ali{:<2.f}\n` olsaydı `end()` fonksiyonu '\n' karakterini gösterirdi.s
- - Birden fazla küme parantezi olsaydı bu işlem her bir küme parantezi için ayrı ayrı yapılacaktı. Parse fonksiyonu braclet'ın kapandığı konumu döndürmesi gerekiyor. Yanş begin fonksiyonunndan aldığımız konumdan başlayarak kapann küme parantezinin konumunu döndürmesi gerekiyor.
- Bir de format fonksiyonu yazmamaız gerekiyor, 1. parametre basttırılcak sınıf neseis, 2. parametre `format_context`.
- - Bu fonksiyon `format_to` fonksiyonunun geri dönüş değeri veriyor.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
class std::formatter<Mint> {
public:
    constexpr auto parse(format_parse_context& ctx) {
        auto iter = ctx.begin();
        while (iter != ctx.end() && *iter != '}') {
            if (*iter < '0' || *iter > '9') {
                //exception throw edilebilir.
                //throw std::format_error{"invalid width character"};
                throw std::format_error{std::format("invalid width character: {}", *iter)};
            }
            m_width = m_width * 10 + (*iter - '0');
            ++iter;
        }            

        return iter;
    }

   auto format(const Mint& m, format_context& ctx) 
   {
        //return std::format_to(ctx.out, "Mint: {}", m.get());
        return std::format_to(ctx.out(),"{:{}}",m.get(),m_width);
   }
   int m_width{};
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{:15}", m) << endl; //begin fonksiyonu 1'in konumunu döndürecek 15'i bir tam sayı değeri olarak alacagız
}
```

- Tüm parametre özelliklerini tutmak istiyorsak format kütüphanesinin specializasyonları var. Int örneği için standart kütüphanenin bir specializasyonu var.

Bunu 2 farklı şekilde yapabiliriz. Sınıfımızda veri elemanı tutarak formatlamayı bu nesneye yaptırabiliriz ya da kalıtımdan yararlanarak yapabiliriz.

- derleyiciye bağlı olarak mutable keyword'ünü eklememiz gerekebilir.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
class std::formatter<Mint> {
public:
    // mutable  std::formatter<int> mf;
    std::formatter<int> mf;
    //constexpr olması da sentaks hatası oluşturuyor olabilir.
    //constexpr auto parse(format_parse_context& ctx) 
    auto parse(format_parse_context& ctx) 
    {
        return mf.parse(ctx);
    }

   auto format(const Mint& m, format_context& ctx) 
   {
        return mf.format(m.get(), ctx);
   }

   int m_width{};
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{0:$>15} {0:_<15",m); 
}
```

- Kalıtım ile:

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
struct std::formatter<Mint> : std::formatter<int>
{
    auto format(const Mint& m, auto& ctx)
    {
        return std::formatter<int>::format(m.get(), ctx);
    }
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{0:$>15} {0:_<15",m); 
}
```

- Kalıtım ile custom type için:

```cpp
#include <format>
#include <iostream>


enum class Fruit
{
    Apple,
    Orange,
    Banana
};

template<>
struct std::formatter<Fruit> : public std::formatter<std::string>
{
    auto format(Fruit f, std::format_context& ctx)
    {
        std::string name;
        switch (f)
        {
        using enum Fruit;
        case Apple:
            name = "Apple";
            break;
        case Orange:
            name = "Orange";
            break;
        case Banana:
            name = "Banana";
            break;
        default:
            name = "Unknown";
            break;
        }
        return std::formatter<std::string>::format(name, ctx);
    }  
};

int main()
{
    Fruit f = Fruit::Apple;
    std::cout << std::format("Fruit: {:_<16}",f); 
}
```

Oluşturulabilir.

- Constexpr ve mutable olması ile ilgili olan durumlar derleyiciye bağlı olarak değişebilir. Bunun için koşulları aşağıdaki gibi sınayabiliriz.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
struct std::formatter<Mint> : std::formatter<int>
{
#if __cpp_lib_format < 202106
    mutable //in case the standard formatters have a non-const format
#endif
    std::formatter<int>mf;
#if __cpp_lib_format >= 202106 //in case standard formatters don't support constexpr parse() yet
    constexpr
#endif
    auto parse(format_parse_context& ctx)
    {
        return mf.parse(ctx);
    }
  auto format(const Mint& m, format_context& ctx)
  {
    return mf.format(m.get(), ctx);
  }
};

int main()
{
    using namespace std;
    Mint m(145);

}
```

- Şimdiye kadar kullandığımız türler compile-time'da belirtilen string alıyordu.

### vFormat Fonksiyonu

Argümanları doğrudan geçmiyoruz ve make_format fonksiyonun geri dönüş değerini geçiyoruz.

```c++
int main()
{
    using namespace std;
    const char *p = "|{:<12}|";
    char str[20] = "";
    cout << "formatlama bilgisi : ";
    cin >> str;
    int x = 456;
    //auto str = format(str,x); Sentaks hatası
    auto name = std::vformat(str, std::make_format_args(x));
    cout << name << "\n";
}
```

## Aggregate Type

- Bilesşik türler. Sentaksı ayrı ve semantik yapısı ayrı.

### Semantik tarafı

Non static veri elemanlarını doğrudan kullanıma açan sınıflar, bu sınıfların veri elemanları için bir koruma yok.

- Neden? Sınıfları 2'ye ayırmak gerekiyor. Data hiding yapan sınıflar => sınıfın invariantlarının olması ve sınıfın bu invariantlarınıı kendi kontrol ediyor. Invariantlar tutmadığında exception throw edebiliriz.
- Aggregate olup olmamasını belirleyen dilin kurallarınca belirleniyor.
- Bir sınıf olabilir fakat.
- Dizi türleri kesinlikle aggregate type olarak kabul ediliyor. `string x[5]` türü de bir aggregate type.

### Koşulları

1. User-declared constructor'ları olmamalı. C++20 öncesinde user-provided constructor'ları olmamalı idi.
2. Non-static veri elemanlarının tamamı public olmalı. C++17 öncesi bunu test etmek için bir meta-function yoktu. `is_aggregate` meta-function'ı eklendi.
3. Aggragate typelar, aggregate olmayan türden veri elemanları alabiliyor.
4. C++17 ile kalıtımla elde edilen sınıflar aggregate olabiliyor.

```cpp
#include <type_traits>
struct A {
    int x;    double d;     char c;
};
struct B {
    int x;    double d;     char c;
private: //protected olabilir.
    int a;
};
struct A1 {
    std::string x;    double d;     char c;
};
class Myclass{};

struct MDer : Myclass
{ int a, b;}
struct MDer1 :protected Myclass
{ int a, b;}
struct SDer : std::string
{ int a, b;}

int main()
{
    static_assert(std::is_aggregate_v<A>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<B>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<std::string>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<sA1>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<Mder>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<Mder1>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<SDer>, "not an aggregate"); 

}
```