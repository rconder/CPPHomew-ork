# 8.Hafta

## İçindekiler

- [8.Hafta](#8hafta)
  - [İçindekiler](#i̇çindekiler)
  - [C++20 std::format Kütüphaesi](#c20-stdformat-kütüphaesi)
    - [printf ve iostream kütüphanelerinin dezavantajları ve avantajları](#printf-ve-iostream-kütüphanelerinin-dezavantajları-ve-avantajları)
    - [std::format](#stdformat)
    - [Yazma alanı genişliği ve Width](#yazma-alanı-genişliği-ve-width)

---

> 8.Hafta 14_12_08_2023

---

> consteval anahtar sözcüğü işlendikten sonra da lambda konusnu işleyeceğiz.

## C++20 std::format Kütüphaesi

### printf ve iostream kütüphanelerinin dezavantajları ve avantajları

- Çıkış akımına bir yazıyı formatlı bir şekilde yazdırmak sorunlu bir durumdu. C'deki printf ve snprintf fonskiyonlarının yaptığı iş.
- C++20 öncesi 2 seçeneğimiz vardı:
- - Formatlamayı C'den gelen fonskyionlara yaptırmak.
- - ios kütüphanesinin formatlama özelliklerini kullanmak.
- Fakat bu iki seçenek de dezavatajları vardı.

C'den gleen printf fonksiyonlar:

`int printf(const char *pfm, ...)` şeklinde bir fonksiyon. `int sprintf(char *buf, const char *pfm, ...)` ve snprintf ilaveten dizinin boyutunu alıyor, `int fprintf(FILE *f, const char *pfm, ...)` şeklinde fonksiyonlar var. 3'ününde geri dönüş değeri yazdığı karakter sayısı.

- **dezavantajı**: Tüm variadic fonksiyonlar içerisinde type-safe olmaması, fonksiyon beklediği argüman türünü biliyor ve programcıdan da buna uyulmasını bekliyor.
- Variadic parametre için bir şekilde fonksiyon çağırısında gönderilen argümanların sayısını kontrol etmek zorundayız. C++ içerisinde böyle bir kısıt yok. C'deki fonksiyonlar da 3 teknik var.
- - ilk parametreye argüman sayısı gönderilmesi
- - Sentinel değeri kullanılabilir örneğin `-1` in başka bir argğüman olarak gönderilebilir
- - Fonksiyonun ilk parametresini yazı isteyen fonksiyon ve bu yazının içerisinde gönderilen argüman sayısını kullanmak.

- **Avantajlar**: Yeni derleyiciler ile kısmen hızlı.
- Argümanlar ile formatlamasında kullanılacak conversion specifier'ları ayrı ayrı görebiliyoruz. Locale ayarlarına göre formatlama yapabiliyoruz.

C++'ın iostream kütüphanesi:

- En büyük dezavantajı hantal olması
- Fakat tpye-safe operator overloading kullanıyor.
- Custom typelar için özelleştirilebiliyor. İstediğimiz format özellikleri ile kullanabiliyoruz. Birden fazla buffer nesnesi aynı bufffere'ı kullaılabiliyor.
- Fakat formatlama state kullanımını çok karmaşık olması ayrı bir negatif.

Bunların ortasını bulabilmek için 2 tarafında güzel özelliklerini alıp std::format kütüphanesi eklendi ve bu kütüphanenin mimari **Victor Zverovich**.

- std::format bize bir formatlanmış string döndürüyor ve opeator<< ile çıkış akımın yazdırabiliyoruz. Örneğin on/off bayrakları için:

```c++
int main()
{
    using namespace std;
    ios_base::fmtflags; //Her string nesnesi bunu tutuyor ve bitsel manipülasyon yapabiliyoruz.
    cout.setf(ios::boolalpha); //
    cout.unsetf(ios::boolalpha); //
    cout.flags(); //flags'lerin durumunu alıyoruz.

    cout.flags(cout.flags() | ios::boolalpha);
    cout.flags(cout.flags() & ~ios::boolalpha);
}
```

- Fromat state'ini resetleemiz gerekiyor olabilir bunun için artık formatlama işlemlerini bir nesne üzerinden yapabiliyoruz. Her formatlama özelliğiyi de on/off gibi değil birden fazla seçenek var.`os.setf(ios::left, ios::adjustfield);` -> standart çıkış bufferını yazıcak.

- Bir zor kısım ise operator overloading kısmı,

```c++
int main()
{
  using namespace std;
  int x = 10;
  double dval = 3.14;
  cout << ival << " " << dval << "\n"; // 10 3.14
  cout.setf(ios::hex, ios::basefield); 
  cout << ival;
  cout.setf(ios::uppercase);
  cout.setf(ios::scientific, ios::floatfield);  
  cout << dval;
}
```

- Bunun için daha karmaşık bir yapı ile yapıyoruz. Burada function pointer alan operator overload fonksiyonu çağırıdığımzda ostream-manipulatörleri ( örneğin endl fonksiyonu). Tanımlayarak daha kolay bir yapı oluşturulmaya çalışılmış

```c++
class
{
  public:
    int ival;
    double dval;
    ostream &operator<<(int);
    ostream &operator<<(double);
    ostream &operator<<(void *);
    ostream &operator<<(ostream &(*pf)(ostream &));
    {
      return pf(*this);
    }
};
std::ostream & Hex(std::ostream &os)
{
  os.setf(ios::hex, ios::basefield);
  return os;
}
cout << 47892 << Hex << 47802 ; //cout'un format statetini değiştirmiş oluyoruz.
//bu şekildel birden fazla manipülator var.
```

```c++
std::ostream & dl(std::stream&os)
{
  return os << "------------------------------------------------------\n";
}
int main()
{
  using namespace std;
  cout << 10 << dl << 20 << dl << 30 << dl;
}
```

- Parametreli manipülatörde yazabilirdik.

```c++
class sp{
public:
  sp(std::size_t n = 1) : mn{n} {}
  friend std::ostream & operator<<(std::ostream&os, const sp& x)
  {
    auto n = x.m_n;
    while(n--)
      os << ' ';
    return os;
  }
private:
  std::size_t mn;
};

int main()
{
  using namespace std;
  int x{12};
  double dval{3.14};
  string str{"Ali"};
  cout << x << sp(3) << dval << sp(5) << str << dl;
}
```

- Bütün bu yapı std::format ile daha kolay bir şekilde yapılıyor.

### std::format

Başlık dosyası: `<format>`
Kütüphane: `std::format`

- Format fonksiyonun ilk parametresi string_view, compile time'da değeri belli olan bir string olmak zorudna, eğer bu programın run-time'da belli olucaksa ayrı bir fonksiyon çağırılıyor.

```c++
int main()
{
  using namespace std;
  cout << format("bu bir string"); //bu ifadenin geri dönüş değeri std::string, burada bu string oluşturma maileyeti var.
  std::string name{"deneme"};
  int n {6}
  cout << format("{} bugun {} tane kitap satin aldi",name, n );
  cout << format("{1} {0} {1}",name, n );
  cout << format("{0} bugun {0} tane kitap satin aldi",name);
}
```

- Poisitional Placeholder index kullanabiliyoruz. `{0} {1} {2}` gibi.

```c++
int main()
{

  using namespace std;
  std::string name{"deneme"};
  four(int i = 0; i< 128; i++)
  {
    if(isprintf(i))
      cout << format("{0:d} {0:#X} {0:c}\n",i);
  }
}
```

- Ezber için

`[[fill]align] [sign][#][0][width][.precision][type]`

- fill: doldurma karakteri
- align: left, right, center
- sign: tam sayılar için +, - yazılsın mı yazılmasın mı onu belirliyor.
- `#`: Type'i modify etmek için kullanılıyor. Hexadecimal için örneğin. Showbase yapıyor.
- 0: Tam sayılar için işaret varsa onu 0'larla dolduruyor.
- width: minimum yazma alanı genişlik.
- '%d, %i ....` kullanılan conversion specifier'lar

- Eğer default değerler kullanılmak istenirse bunun küme parantazi içerisi boş bırakılabilir.
- Her türün allignmentı aynı değil.

- Belirli forlama özelliklerini dinamik olarakta alabiliyoruz.
- Geçerli olmayan bir format değilse *exception* throw ediyor.

### Yazma alanı genişliği ve Width

```c++
int main()
{
  using namespace std;
  int x = 4539;
  cout << format("|{{{}}}|",x);
  cout << format("|{:12}|", x);
}
```