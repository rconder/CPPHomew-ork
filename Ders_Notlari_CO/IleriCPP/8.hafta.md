# 8.Hafta

## İçindekiler

- [8.Hafta](#8hafta)
  - [İçindekiler](#i̇çindekiler)
  - [C++20 std::format Kütüphaesi](#c20-stdformat-kütüphaesi)

---

> 8.Hafta 14_12_08_2023

---

> consteval anahtar sözcüğü işlendikten sonra da lambda konusnu işleyeceğiz.

## C++20 std::format Kütüphaesi

- Çıkış akımına bir yazıyı formatlı bir şekilde yazdırmak sorunlu bir durumdu. C'deki printf ve snprintf fonskiyonlarının yaptığı iş.
- C++20 öncesi 2 seçeneğimiz vardı:
- - Formatlamayı C'den gelen fonskyionlara yaptırmak.
- - ios kütüphanesinin formatlama özelliklerini kullanmak.
- Fakat bu iki seçenek de dezavatajları vardı.

C'den gleen printf fonksiyonlar:

`int printf(const char *pfm, ...)` şeklinde bir fonksiyon. `int sprintf(char *buf, const char *pfm, ...)` ve snprintf ilaveten dizinin boyutunu alıyor, `int fprintf(FILE *f, const char *pfm, ...)` şeklinde fonksiyonlar var. 3'ününde geri dönüş değeri yazdığı karakter sayısı.

- **dezavantajı**: Tüm variadic fonksiyonlar içerisinde type-safe olmaması, fonksiyon beklediği argüman türünü biliyor ve programcıdan da buna uyulmasını bekliyor.
- Variadic parametre için bir şekilde fonksiyon çağırısında gönderilen argümanların sayısını kontrol etmek zorundayız. C++ içerisinde böyle bir kısıt yok. C'deki fonksiyonlar da 3 teknik var.
- - ilk parametreye argüman sayısı gönderilmesi
- - Sentinel değeri kullanılabilir örneğin `-1` in başka bir argğüman olarak gönderilebilir
- - Fonksiyonun ilk parametresini yazı isteyen fonksiyon ve bu yazının içerisinde gönderilen argüman sayısını kullanmak.

- **Avantajlar**: Yeni derleyiciler ile kısmen hızlı.
- Argümanlar ile formatlamasında kullanılacak conversion specifier'ları ayrı ayrı görebiliyoruz. Locale ayarlarına göre formatlama yapabiliyoruz.

C++'ın iostream kütüphanesi:

- En büyük dezavantajı hantal olması
- Fakat tpye-safe operator overloading kullanıyor.
- Custom typelar için özelleştirilebiliyor. İstediğimiz format özellikleri ile kullanabiliyoruz. Birden fazla buffer nesnesi aynı bufffere'ı kullaılabiliyor.
- Fakat formatlama state kullanımını çok karmaşık olması ayrı bir negatif.

Bunların ortasını bulabilmek için 2 tarafında güzel özelliklerini alıp std::format kütüphanesi eklendi ve bu kütüphanenin mimari **Victor Zverovich**.

- std::format bize bir formatlanmış string döndürüyor ve opeator<< ile çıkış akımın yazdırabiliyoruz. Örneğin on/off bayrakları için:

```c++
int main()
{
    using namespace std;
    ios_base::fmtflags; //Her string nesnesi bunu tutuyor ve bitsel manipülasyon yapabiliyoruz.
    cout.setf(ios::boolalpha); //
    cout.unsetf(ios::boolalpha); //
    cout.flags(); //flags'lerin durumunu alıyoruz.

    cout.flags(cout.flags() | ios::boolalpha);
    cout.flags(cout.flags() & ~ios::boolalpha);
}
```

