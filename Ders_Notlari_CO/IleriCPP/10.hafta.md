# 10.Hafta

## İçindekiler

- [10.Hafta](#10hafta)
  - [İçindekiler](#i̇çindekiler)
  - [Constexpr Fonksiyonlar](#constexpr-fonksiyonlar)
    - [Consteval fonksiyonlar](#consteval-fonksiyonlar)
    - [Constinit Fonksiyonlar](#constinit-fonksiyonlar)
  - [Attributelar](#attributelar)
    - [\[\[nodiscard\]\] attribute](#nodiscard-attribute)
  - [Concpetler](#concpetler)
    - [Conceptlerin Tanımlanması](#conceptlerin-tanımlanması)
      - [Requires Clause](#requires-clause)
        - [Conceptler ile birlikte kullanımı](#conceptler-ile-birlikte-kullanımı)
      - [Requires Expression](#requires-expression)

## Constexpr Fonksiyonlar

### Consteval fonksiyonlar

- Bu fonksiyona yapılan çağırıların hepsi compile-time içerisinde değerlendirilmek zorunda, compile-time context'i içerisinde kullanılmaması sentaks hatası oluşturuyor.

### Constinit Fonksiyonlar

- Bu fonksiyonun compile-time init şekilde olması daha iyi olabilirdi çünkü buradaki context compile-time init'e karşılık geliyor. Statik veri değişkenlerin initialization sonucu static init fail olabilir.
- `constinit` keyword'ü ile derleyiciye değişkenin constant initialize edilmesini garanti edebiliyor.

```cpp
constinit int x = 0;
//constinii = constexpr - conts;
```

- Bu ifadelere sabit bir ifade ile değer vermemiz zorunlu.
- Ama burada değişkenin değerini değiştirebildiğimiz için `constinit = constexpr - const`

```cpp
constexpr int foo(int x)
{
    return x*6;
}

constexpr int x = foo(5);
constinit int y = foo(6);

int main()
{
    y++;
}
```

- Y değişkenini başka bir sınıf içerisinde kullanıyor olsa bile `constinit` anahtar sözcüğü ile bu değişkenin compile-time'da initialize ediyoruz.

Hangi değişkenleri `constinit` ile tanımlamalayabiliriz?

- Global değişkenleri
- static yerel değişkenleri
- sınıfların static veri elemanlarını

```cpp
constinit int x = 10; // OK
int fo()
{
    static constinit int z = 30; // OK
}

class Myclass
{
public:
    static constinit int x = 10; // OK
};
```

```cpp
constexpr std::array<int, 4> get_array()
{
    return {1, 2, 3, 4};
}

constinit auto g_ar4  = gee_array(); // OK

int main()
{
    for(auto i : g_ar4)
    {
        std::cout << i << "\n";
    }

    g_ar4[1]++;
    g_ar4[2] += 100;
    for(auto i : g_ar4)
    {
        std::cout << i << "\n";
    }
}
```

- Templateler içinde kullanabiliriz.

```cpp
template <std::size_t N>
constinit std::array<int, N> get_array()
{
    std::array<int, N> ar;
    for(std::size_t i = 0; i < N; i++)
    {
        ar[i] = i;
    }
    return ar;
}

constinit auto g_ar4 = get_array<4>();

int main()
{
    for(auto i : g_ar4)
    {
        std::cout << i << "\n";
    }
    for_each(begin(g_ar4), end(g_ar4), [](int& x){ ++x; });
    for(auto i : g_ar4)
    {
        std::cout << i << "\n";
    } 
}
```

- `constinit` ile `const` kullanabiliriz fakat bunun yerine constexpr kullanabiliriz.

## Attributelar

- Derleyiciyi yönlendirmek için ve koda okuyana bilgi vermek için kullanılabilir. Derleyiciler daha önceden extension mekanizması ile bunu sağlıyabiliyordu.
- Dile eklenmesi ile derleyiciden bağımsız olarak bir standart yapı eklendi.
- Programcıyı korumaya yönelik.
- Bazen kodun yanlış yazılmasını engelemek için kullanıldığı gibi bazen de spesifik durumlarda bu yapının bilinçli olarak kullanıldığını belirtmek için kullanılabiliyor.
- Derleyiciler veya programcılar kendi attributelarını oluşturulabiliyor.

Sentaksı `[[attribute]]`

### [[nodiscard]] attribute

Bir öğenin discard edilmesinin logic bir hata olduğunu belirtmek için kullanılıyor. Derleyiciyi de uyarı mesajı vermeye teşvik ediyor.

- Fonksiyonun geri dönüş değeri tamamlayıcı bir değer değilse
- Çağıran kodun discard edebileceği bir hata kodu değilse ve bu bir risk içeriyorsa.
- C++17 ile geldi.
- C++20 ile
- - string literal opsiyonel `[[nodiscard("reason")]] function()` duruma göre reason'ı uyarı mesajı olarak yazdırıyor.

```cpp
[[nodiscard]] int foo(int);
int main()
{
    foo(10); // warning
}
```

- Eğer geri dönüş değerini bilerek ve isteyerek kullanmıyorsak bunu `void` türüne cast edebiliriz.

- Türleri de niteleyebiliyoruz
- - Eğer geri dönüş değeri referans veya pointer ise burada geri dönüş değerinin discard edilmesi bir warning oluşturmayabilir.

```cpp
class  [[nodiscard]] Myclass{};
Myclass foo();
Myclass bar();
int main()
{
    auto m = foo();
    bar(); // compiler will result a warning
}
```

- Sınıfların constructorları da `[[nodiscard]]` ile nitelenebilir.

```cpp
class Myclass
{
public:
    [[nodiscard]] Myclass(int x);
};
int main()
{
    Myclass(10); // warning
    static_cast<Myclass>(12); // warning
}
```

- Standart kütüphanede de bazı fonksiyonlar C++20 ile bazı fonksiyonlar `nodiscard` ile bildirilmiş olabilir.
- - Örneğin Vector sınıfının empty fonksiyonu.

```cpp
int main()
{
    std::vector vec{2,5,7,9};
    vec.size();
}
```

## Concpetler

C++20 ile yapılan majör bir eklenti. Olabilecek tek eleştiri bu özelliğin çok geç gelmiş olması.

Template kodları constraint etmek için kullanılıyor. Template kodların derleyiciye kod yazdıran kodlar.

- Function template: ürünü bir fonksiyon ve buna bu fonksiyon türünün specialization'ı oluyor.
- Class template: ürünü bir sınıf ve bu sınıfa sınıf template'inin bir specialization'ı oluyor.
- Variable template: ürünü bir variable
- Alias template: Ürünü bir tür.

Burada şablonlar oluşturulurken kısıtlamalar olabilir. Örneğin bir şablon sadece tam sayılar için uygun olabilir.

- Şablonda bu kısıtlamayı anlatan/bildiren bir veri yok.
- Template'e eskiden yanlış bir değişken verildiğinde çok büyük bir hata mesajı veriyor.
- Compile time içerisinde derleyicinin üzerindeki yükü azaltmak.
- Bir veya birden fazla constraint sağlanmadığında hangi constraint'in sağlanmadığı hakkında bir hata mesajı verilsin.
- Ve buradaki constraint'lerin bir kısmı standart hale getirilsin, bunlara **concept** diyelim.
- Kendi kısıtlamalarımızı oluşturabilmemiz yanında standart'tan  gelen kısıtlmaları da kullanabilelim.
- Kod seçiminde de kullanılabiliyor.

Comceptlerin dile eklemesi ile birlikte ranges kütüphanesi iş görüyor.

```cpp
template <std::integral T>
void func(T x)
{
    std::cout <<"tam sayi " <<  x << "\n";
}
template<std::floating_point T>
void func(T x)
{
    std::cout << x << "\n";
}

void foo(std::integral auto x)
{
    std::cout << "tam sayi " << x << "\n";
}

int main()
{
    func(23L);
    func(3.4F);
}
```

- Concept'in kendisi hem başlık dosyasının ismi hem de concept'in ismi olabilir. Templateler ile de arttı. Concept template kategorisi de dil eklendi ve bu bize constraint'lerin isimlendirilmesi konusunda da fayda sağlıyor.

---

Concept öncesinde

- Sadece tam sayı türleri ile kısıtlamak istiyorsak

```cpp
template <typename T, std::enable_if_t<std::is_integral_v<T>>* =nullptr >
void foo(T);

template <typename T>
std::enable_if_t<std::is_integral_v<T>öT> bar(T);

template <typename T>
void baz(T, std::enable_if_t<std::is_integral_v<T>>*p = nullptr);

int main()
{
    foo(10);
    bar(20);
    baz(30);
    foo(3.4); // Sentaks hatası oluşacaktı
}
```

---

Bir template'in kısıtlaması var ve bu kısıtlamaya uyulmasın

```cpp
template <typename T>
void print(const T& x)
{
    std::cout << x << "\n";
}
int main()
{
    print(10);
    print(3.4);
    print("ali"s);
    
    std::vector vec{1,2,3,4,5};
    //print(vec); vector için ostream'e insert edecek bir fonksiyon yok.
}
```

Artık bir template'i birden fazla araç kullanarak constrait edebiliyoruz.

```cpp
template <typename T>
void foo(const T& x)
{
    int t = x;
    std::cout << x << "\n";
}

int main()
{
   //foo(std::string{"ali"}); sentaks hatası mesajı çok uzun ve karışık oluyor.
}
```

auto keyword'ü ile template olarak yazabiliyoruz.

```cpp
temaplta <typename T>
class Myclass
{
public:
    void funct(auto x);
};
```

### Conceptlerin Tanımlanması

#### Requires Clause

- 2 farklı şekilde tanımlanabilir.
- - prefix
- - trailing

`requires sizeof(T) > 2`

```cpp
template<typename T>
requires (sizeof(T) > 2)  void foo(T x)
 void foo(T x) requires (sizeof(T) > 2) //parametre değişkenin ismini buurada kullanabiliyoruz.
//her iki yerde de kullanabiliyoruz.
{
}
int main()
{
    //foo('A'); //sentaks hatası. 
}
```

- Hem başlangıcında hem de sonunda kullanabiliriz.

```cpp
template <typename T>
requires std::is_integral_v<T> void foo(T x) requires std::is_signed_v<T>
//requires std::is_integral_v<T> && std::is_signed_v<T> void foo(T x) şeklinde de yazbilirdiik.
{
    std::cout << x << "\n";
}
{
    std::cout << x << "\n";
}
int main()
{
    foo(10);
    foo(3.4); //sentaks hatası
}
```

- Logic değil operatörünü kullanırsak requires clause'u parantez içerisine almalıyız.

##### Conceptler ile birlikte kullanımı

- Yukarıdaki constraintleri isimlendiriyoruz ve tekrar tekrar yazma zahmetinden kurtulabiliyoruz.
- Doğrudan requires clause'da kullanabiliyoruz. Hem prefix hem de trailing olarak kullanabiliyoruz.

```cpp
template <typename T>
concept Integral = std::is_integral_v<T>;

template <typename T>
concept SignedIntegral = Integral<T> && std::is_signed_v<T>;

//constrained template parameter.
template <Integral T, Integral U>
class Myclass{};
```

```cpp
template <typename T>
concept as_int = std::integral<T> || std::is_covertible_v<T, int>;

template <as_int T>
class Myclass{};

struct Cans{};

int main()
{
    Myclass<int> m1;
    //Myclass<Cans> m2; Sentaks hatası
}
```

- auto'nun kullanıldığı yerde bunu kullanabiliyoruz.

```cpp
template <typename T>
concept as_int = std::integral<T> || std::is_covertible_v<T, int>;

void func(as_int auto x)
{
    std::cout << x << "\n";
}
```

- Sadece fonksiyon şablonlarında değil member fonksiyon template'lerde de kullanabiliyoruz.

```cpp
class Myclass
{
public:
    void foo(std::integral auto);
};
```

- auto'nun kullanıldığı çoğu yerde de kullanabiliyoruz.

```c++
std::integral auto bar(int x)
{
    return x*x;
// return x*3.4; sentaks hatası bu ifadenin türü integral türünü karşılamıyor.
}
int foo()
int main()
{
    std::integral auto x = foo(); //çıkarım yapılan türün sadece integral olması durumunda bu kod  geçerli oluyor.

    vector<int> ivec(100);
    for(std::integral auto x : ivec)
        std::cout << x << "\n";
}
```

- Sabit ifadesi ile de kullanabiliyoruz. Çok daha karmaşık bir concept ile de kullanabilioyruz.

```c++
template <typename T>
void func(T x)
{
    if constexpr(std::integral<T>)
    {
        std::cout << x << "\n";
    }
    else if constexpr(std::floating_point<T>)
    {
        std::cout << "floating pıint \n";
    }
    else
    {
        std::cout << "other type\n";
    }
}
int main()
{
    func(10);
    func(3.4);
    func("ali"s);
}
```

```cpp
template <typename T>
concept additive = requires(T xö T y){
    x+y; // T'türünden 2 nesnse toplandığında geçerli olucak
    x-y; // T'türünden 2 nesnse çıkartıldığında geçerli olucak
};

template <typename T>
void func(T x)
{
    if constexpr(additive<T>)
    {
        std::cout << x << "\n";
    }
    else
    {
        std::cout << "not additive\n";
    }
}

int main()
{   int x = 10;
    int *p = &x;
    func(x);
    funct(p);
}
```

- constexpr fonksiyonları da kullanabiliyoruz.

```c++
template <std::size_t N>
requires (std::has_single_bits(N)) && (N>32)
class Myclass{};

int main()
{
    //Myclass<5> m1;
    //Myclass<45> m1;
    Myclass<64> m1;
};
```

. Isprime örneği

```c++
constexpr bool isprime(int x)
{
    if(x<2)
        return false;
    if (x %2 == 0) return x == 2;
    if (x %3 == 0) return x == 3;
    if (x %5 == 0) return x == 5;

    for(int i{7}; i *i <= x ; i+2)
        if(x%i == 0)
            return false;
    return true;
}

template <int N>
requires isprime(N)
class Myclass {};

template <int N>
concept Prime = isprime(N);

template <int N>
requires Prime<N> 
void func();

int main()
{
    Myclass <18> x;//sentaks hatası
    func<19>();
//func<6>(); sentaks hatası
}
```

#### Requires Expression

- Boolean bir değer üretiyor.
- Blok içerisinde birden fazla constraint tanımlayabilmek için değişken yapabiliyoruz.
- Bu ifadeler yürütülmüyorlar.
- Birden fazla kategöride bir şeyler belirtebiliyoruz.
- - simple requirements: ifadenin geçerli olup olmadığını test ediyoruz.

```cpp
template <typename T>
concept Den = requires(T x) {
    x++; //örneğin int türü ++ operatörünü destekliyor ve geçerli
};

template <typename T>
concept Den1 = requires(T x) {
    x == nullptr;
};

template <typename T>
concept Den2 = requires(T x) {
    std::is_integral_v<T>;
};

struct A{};
int main()
{
    static_assert(Den<int>);
    static_assert(Den<int*>);
    static_assert(Den<std::vector<int>::iterator>);
    //static_assert(Den<A>);
    constexpr auto b = Den1<std::unique_ptr<int>>; //true uniuqe_ptr nullptr ile fonksiyon ile karşılaştırılabiliyor
    constexpr auto c = Den2<double> ; //true
}
```

- type Requirements:
- - Derleyici bir türün var ve geçerli olduğunu sınamak zorunda

```c++
template <typename T>
concept Den = requires(T x) {
    typename T::value_type;
};



int main()
{
    constexpr auto b = Den<int>;
    constexpr auto b1 = Den<std::vector<int>>;
}
```

---

18_27_08_2023

---

- type parametresinin veya non-type parametresinin requires clause içerisinde geçmesi zorunlu değil.

```cpp
template <typename T>
    requires true
class Myclass{};

int main()
{
    Myclass<int> m1;
}
```

- standart kütüphanede de conceptler var, bunları kullanmak için `concepts` başlık dosyasını eklememiz gerekiyor.

```cpp
#include <concepts>
template <typename T>
requires std::is_pointer_v<T> || std::same_as<T, std::nullptr_t>
void foo(T);

int main()
{
    int ival {10};
    foo(nullptr);
    foo(&ival);
}
```

- T türünden geçici bir nesnse oluşturarak kullanmak istersek o türün default constructor'ı olması lazım bu durumda sentaks hatası vermemesi için declval aşağıdaki gibi çağırıldığında default constructor'ı olmöasına gerek yok.
- optional nesnesi de dereferenc edilebiliyor ve bu nesne dereference edildiğinde çağırılan fonksiyonun geri dönüş değeri int& türünden bir nesne.

```cpp
template <typename T>
 requires std::integral<std::remove_reference_t<decltype(*std::declval<T>())>>
/*
İçeriden dışarıya doğru 
- decltype ile T türünden bir nesne oluşturuyoruz. 
- Referans türüyose referanslığından kurtarıp, eğer T'türünden bir nesne referanslıktan sıyrılıdğında bir integral türüne dönüşebiliyorsa bu şablonu kullanabiliriz.
*/
void foo(T);

int main()
{
    int x{};
    double d{};
    std::optional opt{10};
    //foo(&x);
    //foo(&d);
    //foo(&opt);

}
```

- Aşağıdaki kodda veya ifadesi ile oluşturulan ifadenin hepsinin geçerli bir ifade olması gerekiyor.l

```cpp
template <typename T, typename U>
concept cden = requires(T x, U y){
    //*y > x; //2.tamplate parametresi türünden bir nesne dereferans edildiğinde o 1. template parametresi türünden bir nesne ile karşılaştırılabiliyor olması gerekiyor.
    x.foo() || y.bar(); //x.foo() veya y.bar() çağrılabiliyor olması gerekiyor anlamına gelmiyor!!!!!!!!!!!!
};

struct A{void foo();}
struct B{}
int main()
{
    constexpr auto b = cden<A,B>; 
}
```

- Eğer veya şeklinde yapmak istiyorsak

```cpp
template <typename T, typename U>
concept cden = requires(T x){
    x.foo();
}
|| 
requires(T x){
    x.bar();
};
```

3 türde requirement ifadesi var:

- simple requirements
- type requirements
- compound requirements

```cpp
template <typename T>
concept cden = requires(T x){
    x.foo();
};
//T türünün çağırılabilir bir foo fonksiyonu olması lazım.
```

- type requirement için
- T'nin print fonksiyonun çağrılabilir olması, first ve secont type'larının olması gerekiyor.

```cpp
template <typename T>
concept cden = requires(T x){
    x.print();
    typename T::value_type::first_type;
    typename T::value_type::second_type;
};
```

```c++
template <typename T>
concept cden = requires(typename T::value_type x) {std::cout << x;};

using mytype = std::vector<int>;
int main()
{
    static_ssert(cden<mytype>);
}
```

- Compound requirements:

Burada sentaks:

```c++
template <typename T>
concept cden = requires(T x){
    {x.foo()}; // bu küme parantezsiz yazmak ile aynı
    {x.bar()}noexcept;
        
};
```