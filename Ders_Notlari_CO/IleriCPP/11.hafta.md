# Conceptler

Conceptler ile yeni algoritmalar için kendi constraintlerini oluşturuyorlar ve bu sayıda birden fazla avantaj elde edilmiş oluyor.

```c++
int main()
{
    using namespace std;
    vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    ranges::sort(v); //artık bu şekilde çağırıyoruz.
}
```

## C++20 Gelen Yeni Özellikler

### Bitsel İşlemler ve Bitler

- Negatif tam sayı gösterimi C++20'den önce farklı şekilde yapılabilirdi artık 20'den sonra 2'yü tümleyen yapılması garanti altına alındı.

- İşaretli bir int türden değişkeninin operandın sola doğru kaydırma operandı olduğunda, UB oluşturuyordu ve artık C++20 ile bu ifade geçerli.

```c++
int main()
{
    using namespace std;
    int x = -1;
    cout << x << "\n"; //
    x <<=1;
    cout << x << "\n"; // 
    std::cout <<std::format("{0:032b}  {0}",x, x);
}
```

Sağdan yapılan besleme ile artık bu ifade 0 olmak zorunda.

- Soldan yapılan feed eskiden implemantasyona bağlı idi. Artık bu sign extension şeklinde olacağı garanti altında.

- İşaretli tam-sayılar ve işaretsiz tam sayıların karşılaştırılıması daha önceden uyarı mesajı veriyordu. Size fonksiyonu yanına `ssize()` fonksiyonu eklendi ve bu fonksiyonun dönüş değeri artık işaretli bir sayı türünden bir değer döndürüyor.

```c++
int main()
{
    std::vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    for (int i = 0; i < size(ivec); ++i)  //ADL - Argument Dependend Lookup
    {
        cout << ivec[i] << "\n";
    }
}
```

-  yapıların *bitfield members* alanları olabiliyor

```c++
struct A
{
    int a : 3;
    int b : 4;
    int c : 5;
};
```

gibi. Burada kaç bit olacağını gösteren ifadeler de constexpr olmak zorunda. Bunlar sınıfın üyesi, C++20 öncesinde bunlar `default member initializer` olamazdı. C++20 ile birlikte yapıların bitfield memberlarına default member initializer atanabilir.

```c++
struct A
{
    int a : 3{2};
    int b : 4{2};
    int c : 5{2};
};
```

#### include\<bit\>

Sistem programlama tarafında kullanılabilen constexpr bağlamında kullanılabilen fonksiyonlar.

```c++
#include <bit>
```

- `rotatae_left` ve `rotate_right` fonksiyonları
- `bit_ceil` ve `bit_floor` fonksiyonları
- `has_single_bit` fonksiyonu,
- `count_leadign_zeros`, `count_trailing_zeros` ve `popcount` fonksiyonları
- `count_right_zeroes` ve `count_right_ones` fonksiyonları

Compile time'da constexpr gereken bağlamda kullanılmaya zorlanırsa geri dönüş değeri verilebiliyor.

- `std::bit_cast`: Şimdiye kadar bazı durumlarda UB oluşturan, farklı türden bir değerin aynı büyüklükten farklı bir türden kullanılmasını sağlayan fonksiyon.
- Modern C++ ile tamsayı ile önemli eklemeler yapıldı ve artık bir sabiti 2lik sayı sisteminde yazabiliyoruz. Digit separatorler ile birlikte kullanılabiliyor. `x = 0b1010'1010'1010'1010;`
  
```c++
int main()
{
    using namespace std;
    uint16_t x = 0b1010'1010'1010'1010;
    //[[fill]align][sign][#][0][width][,][.precision][type]
    cout << format("{0:016b} {0:8}\n",x);
    cout << format("{0:016b} {0:8}\n",rotl(x,2));//rotate left için bitsel bir operatör yok 2.parametreye negatif değer 
    //geçebiliyoruz ve böylece ters yönde dönmüş oluyoruz. rotr(x,2) olmuş gibi düşünülebilir.
}
```

- bit_floor ve bit_ceiling 2 tabanına göre bu işlemleri gerçekleştiriyor.
- PowerOfTwo için artık bir constexpr fonksiyon var.

```c++
int main()
{
    using namespace std;
    has_single_bit(0b1000); //true
    has_single_bit(0b1001); //false
}
```

##### Bit Cast

Bazı durumlarda bir değişkenin türünü değiştirip aynı bitleri başka bir türdenmiş gibi ele almak istiyoruz. Bu durumda 