<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>3&period;Hafta</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension bierner.markdown-preview-github-styles */
html,
body,
.github-markdown-body {
    padding: 0 !important;
    max-width: auto !important;
}

.github-markdown-body {
    background-color: var(--color-canvas-default);
    color: var(--color-fg-default);
}

.github-markdown-body {
    border: 1px solid transparent;
    box-sizing: border-box;
    margin: 0 auto;
    width: 100% !important;
}

.github-markdown-content {
    padding: 32px !important;
    max-width: 980px;
    min-width: 200px;
    margin: 0 auto;
}


.vscode-body.scrollBeyondLastLine {
    margin-bottom: 0;
}
.vscode-body.scrollBeyondLastLine .github-markdown-body {
    padding-bottom: calc(100vh + 10px) !important;
}

.github-markdown-body blockquote {
    background-color: initial;
}

.github-markdown-body pre {
    color: initial;
    border: none;
}

.github-markdown-body code {
    color: inherit;
}

.github-markdown-body pre code {
    color: initial;
}

.github-markdown-body code > div {
    background: none
}

.github-markdown-body.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

.vscode-dark.showEditorSelection .code-line:hover:before {
    border-left: 3px solid var(--color-fg-default);
}
.github-markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-default, var(--color-canvas-default));
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.github-markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.github-markdown-body h1:hover .anchor .octicon-link:before,
.github-markdown-body h2:hover .anchor .octicon-link:before,
.github-markdown-body h3:hover .anchor .octicon-link:before,
.github-markdown-body h4:hover .anchor .octicon-link:before,
.github-markdown-body h5:hover .anchor .octicon-link:before,
.github-markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.github-markdown-body details,
.github-markdown-body figcaption,
.github-markdown-body figure {
  display: block;
}

.github-markdown-body summary {
  display: list-item;
}

.github-markdown-body [hidden] {
  display: none !important;
}

.github-markdown-body a {
  background-color: transparent;
  color: var(--fgColor-accent, var(--color-accent-fg));
  text-decoration: none;
}

.github-markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.github-markdown-body b,
.github-markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dfn {
  font-style: italic;
}

.github-markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body mark {
  background-color: var(--bgColor-attention-muted, var(--color-attention-subtle));
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body small {
  font-size: 90%;
}

.github-markdown-body sub,
.github-markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.github-markdown-body sub {
  bottom: -0.25em;
}

.github-markdown-body sup {
  top: -0.5em;
}

.github-markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--bgColor-default, var(--color-canvas-default));
}

.github-markdown-body code,
.github-markdown-body kbd,
.github-markdown-body pre,
.github-markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.github-markdown-body figure {
  margin: 1em 40px;
}

.github-markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--borderColor-default, var(--color-border-default));
  border: 0;
}

.github-markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.github-markdown-body [type=button],
.github-markdown-body [type=reset],
.github-markdown-body [type=submit] {
  -webkit-appearance: button;
}

.github-markdown-body [type=checkbox],
.github-markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.github-markdown-body [type=number]::-webkit-inner-spin-button,
.github-markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.github-markdown-body [type=search]::-webkit-search-cancel-button,
.github-markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.github-markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.github-markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.github-markdown-body a:hover {
  text-decoration: underline;
}

.github-markdown-body ::placeholder {
  color: var(--fgColor-muted, var(--color-fg-subtle));
  opacity: 1;
}

.github-markdown-body hr::before {
  display: table;
  content: "";
}

.github-markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.github-markdown-body td,
.github-markdown-body th {
  padding: 0;
}

.github-markdown-body details summary {
  cursor: pointer;
}

.github-markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.github-markdown-body a:focus,
.github-markdown-body [role=button]:focus,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:focus:not(:focus-visible),
.github-markdown-body [role=button]:focus:not(:focus-visible),
.github-markdown-body input[type=radio]:focus:not(:focus-visible),
.github-markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.github-markdown-body a:focus-visible,
.github-markdown-body [role=button]:focus-visible,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:not([class]):focus,
.github-markdown-body a:not([class]):focus-visible,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.github-markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border: solid 1px var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-bottom-color: var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--borderColor-neutral-muted, var(--color-neutral-muted));
}

.github-markdown-body h1,
.github-markdown-body h2,
.github-markdown-body h3,
.github-markdown-body h4,
.github-markdown-body h5,
.github-markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.github-markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.github-markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.github-markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.github-markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--fgColor-muted, var(--color-fg-muted));
}

.github-markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.github-markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-left: .25em solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body ul,
.github-markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.github-markdown-body ol ol,
.github-markdown-body ul ol {
  list-style-type: lower-roman;
}

.github-markdown-body ul ul ol,
.github-markdown-body ul ol ol,
.github-markdown-body ol ul ol,
.github-markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.github-markdown-body dd {
  margin-left: 0;
}

.github-markdown-body tt,
.github-markdown-body code,
.github-markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.github-markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.github-markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.github-markdown-body input::-webkit-outer-spin-button,
.github-markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.github-markdown-body::before {
  display: table;
  content: "";
}

.github-markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body>*:first-child {
  margin-top: 0 !important;
}

.github-markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.github-markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.github-markdown-body .absent {
  color: var(--fgColor-danger, var(--color-danger-fg));
}

.github-markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.github-markdown-body .anchor:focus {
  outline: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre,
.github-markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.github-markdown-body blockquote>:first-child {
  margin-top: 0;
}

.github-markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.github-markdown-body h1 .octicon-link,
.github-markdown-body h2 .octicon-link,
.github-markdown-body h3 .octicon-link,
.github-markdown-body h4 .octicon-link,
.github-markdown-body h5 .octicon-link,
.github-markdown-body h6 .octicon-link {
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  visibility: hidden;
}

.github-markdown-body h1:hover .anchor,
.github-markdown-body h2:hover .anchor,
.github-markdown-body h3:hover .anchor,
.github-markdown-body h4:hover .anchor,
.github-markdown-body h5:hover .anchor,
.github-markdown-body h6:hover .anchor {
  text-decoration: none;
}

.github-markdown-body h1:hover .anchor .octicon-link,
.github-markdown-body h2:hover .anchor .octicon-link,
.github-markdown-body h3:hover .anchor .octicon-link,
.github-markdown-body h4:hover .anchor .octicon-link,
.github-markdown-body h5:hover .anchor .octicon-link,
.github-markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.github-markdown-body h1 tt,
.github-markdown-body h1 code,
.github-markdown-body h2 tt,
.github-markdown-body h2 code,
.github-markdown-body h3 tt,
.github-markdown-body h3 code,
.github-markdown-body h4 tt,
.github-markdown-body h4 code,
.github-markdown-body h5 tt,
.github-markdown-body h5 code,
.github-markdown-body h6 tt,
.github-markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2,
.github-markdown-body summary h3,
.github-markdown-body summary h4,
.github-markdown-body summary h5,
.github-markdown-body summary h6 {
  display: inline-block;
}

.github-markdown-body summary h1 .anchor,
.github-markdown-body summary h2 .anchor,
.github-markdown-body summary h3 .anchor,
.github-markdown-body summary h4 .anchor,
.github-markdown-body summary h5 .anchor,
.github-markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.github-markdown-body ul.no-list,
.github-markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.github-markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.github-markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.github-markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.github-markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.github-markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.github-markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.github-markdown-body ul ul,
.github-markdown-body ul ol,
.github-markdown-body ol ol,
.github-markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.github-markdown-body li>p {
  margin-top: 16px;
}

.github-markdown-body li+li {
  margin-top: .25em;
}

.github-markdown-body dl {
  padding: 0;
}

.github-markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.github-markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body table th,
.github-markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body table td>:last-child {
  margin-bottom: 0;
}

.github-markdown-body table tr {
  background-color: var(--bgColor-default, var(--color-canvas-default));
  border-top: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body table tr:nth-child(2n) {
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
}

.github-markdown-body table img {
  background-color: transparent;
}

.github-markdown-body img[align=right] {
  padding-left: 20px;
}

.github-markdown-body img[align=left] {
  padding-right: 20px;
}

.github-markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.github-markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.github-markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body span.frame span img {
  display: block;
  float: left;
}

.github-markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.github-markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.github-markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.github-markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-left span {
  margin: 13px 0 0;
}

.github-markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body code,
.github-markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
}

.github-markdown-body code br,
.github-markdown-body tt br {
  display: none;
}

.github-markdown-body del code {
  text-decoration: inherit;
}

.github-markdown-body samp {
  font-size: 85%;
}

.github-markdown-body pre code {
  font-size: 100%;
}

.github-markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.github-markdown-body .highlight {
  margin-bottom: 16px;
}

.github-markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.github-markdown-body .highlight pre,
.github-markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border-radius: 6px;
}

.github-markdown-body pre code,
.github-markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.github-markdown-body .csv-data td,
.github-markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.github-markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--bgColor-default, var(--color-canvas-default));
  border: 0;
}

.github-markdown-body .csv-data tr {
  border-top: 0;
}

.github-markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--bgColor-muted, var(--color-canvas-subtle));
  border-top: 0;
}

.github-markdown-body [data-footnote-ref]::before {
  content: "[";
}

.github-markdown-body [data-footnote-ref]::after {
  content: "]";
}

.github-markdown-body .footnotes {
  font-size: 12px;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-top: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body .footnotes ol {
  padding-left: 16px;
}

.github-markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.github-markdown-body .footnotes li {
  position: relative;
}

.github-markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--borderColor-accent-emphasis, var(--color-accent-emphasis));
  border-radius: 6px;
}

.github-markdown-body .footnotes li:target {
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.github-markdown-body [popover] {
  background-color: canvas;
  border: initial solid;
  border-color: initial;
  border-image: initial;
  color: initial;
  height: fit-content;
  inset: 0;
  margin: auto;
  overflow: auto;
  padding: .25em;
  position: fixed;
  width: fit-content;
  z-index: 2147483647;
}

.github-markdown-body [popover]:not(.\:popover-open) {
  display: none;
}

.github-markdown-body [popover]:is(dialog[open]) {
  display: revert;
}

.github-markdown-body [anchor].\:popover-open {
  inset: auto;
}

.github-markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.github-markdown-body .pl-c1,
.github-markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body .pl-e,
.github-markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .pl-smi,
.github-markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.github-markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.github-markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.github-markdown-body .pl-s,
.github-markdown-body .pl-pds,
.github-markdown-body .pl-s .pl-pse .pl-s1,
.github-markdown-body .pl-sr,
.github-markdown-body .pl-sr .pl-cce,
.github-markdown-body .pl-sr .pl-sre,
.github-markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.github-markdown-body .pl-v,
.github-markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.github-markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.github-markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.github-markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.github-markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.github-markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.github-markdown-body .pl-mh,
.github-markdown-body .pl-mh .pl-en,
.github-markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.github-markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.github-markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.github-markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.github-markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.github-markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.github-markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.github-markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.github-markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.github-markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.github-markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.github-markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.github-markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.github-markdown-body .task-list-item {
  list-style-type: none;
}

.github-markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.github-markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.github-markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.github-markdown-body .task-list-item .handle {
  display: none;
}

.github-markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.github-markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.github-markdown-body .contains-task-list {
  position: relative;
}

.github-markdown-body .contains-task-list:hover .task-list-item-convert-container,
.github-markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.github-markdown-body .QueryBuilder .qb-entity {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .QueryBuilder .qb-constant {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
[data-color-mode=light][data-light-theme=light],
[data-color-mode=dark][data-dark-theme=light],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=light_colorblind],
[data-color-mode=dark][data-dark-theme=light_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

[data-color-mode=light][data-light-theme=light_tritanopia],
[data-color-mode=dark][data-dark-theme=light_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

[data-color-mode=light][data-light-theme=light_high_contrast],
[data-color-mode=dark][data-dark-theme=light_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=dark],
[data-color-mode=dark][data-dark-theme=dark],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_dimmed],
[data-color-mode=dark][data-dark-theme=dark_dimmed],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_dimmed],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

[data-color-mode=light][data-light-theme=dark_colorblind],
[data-color-mode=dark][data-dark-theme=dark_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

[data-color-mode=light][data-light-theme=dark_tritanopia],
[data-color-mode=dark][data-dark-theme=dark_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_high_contrast],
[data-color-mode=dark][data-dark-theme=dark_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

/*!
  Theme: GitHub
  Description: Highlight-js port of github.com theme
  Author: github.com
  Maintainer: @SNDST00M, @mjbvz
  Updated: 2021-12-08
*/
.markdown-body pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
}

.markdown-body code.hljs {
  padding: 3px 5px;
}

/*!
  Theme: GitHub
  Description: Theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.markdown-body .hljs {
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
}

.markdown-body .hljs-doctag,
.markdown-body .hljs-keyword,
.markdown-body .hljs-meta .hljs-keyword,
.markdown-body .hljs-template-tag,
.markdown-body .hljs-template-variable,
.markdown-body .hljs-type,
.markdown-body .hljs-variable.language_ {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .hljs-title,
.markdown-body .hljs-title.class_,
.markdown-body .hljs-title.class_.inherited__,
.markdown-body .hljs-title.function_ {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .hljs-attr,
.markdown-body .hljs-attribute,
.markdown-body .hljs-literal,
.markdown-body .hljs-meta,
.markdown-body .hljs-number,
.markdown-body .hljs-operator,
.markdown-body .hljs-selector-attr,
.markdown-body .hljs-selector-class,
.markdown-body .hljs-selector-id,
.markdown-body .hljs-variable {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-meta .hljs-string,
.markdown-body .hljs-regexp,
.markdown-body .hljs-string {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .hljs-built_in,
.markdown-body .hljs-symbol {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .hljs-code,
.markdown-body .hljs-comment,
.markdown-body .hljs-formula {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .hljs-name,
.markdown-body .hljs-quote,
.markdown-body .hljs-selector-pseudo,
.markdown-body .hljs-selector-tag {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .hljs-subst {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-section {
  color: var(--color-prettylights-syntax-markup-heading);
  font-weight: bold;
}

.markdown-body .hljs-bullet {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .hljs-emphasis {
  color: var(--color-prettylights-syntax-constant);
  font-style: italic;
}

.markdown-body .hljs-strong {
  color: var(--color-prettylights-syntax-constant);
  font-weight: bold;
}

.markdown-body .hljs-addition {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .hljs-deletion {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <div
            class="github-markdown-body"
            data-color-mode="auto"
            data-light-theme="light"
            data-dark-theme="dark"
        >
            <div class="github-markdown-content"><h1 id="3hafta">3.Hafta</h1>
<h2 id="i̇çindekiler">İçindekiler</h2>
<ul>
<li><a href="#3hafta">3.Hafta</a>
<ul>
<li><a href="#i%CC%87%C3%A7indekiler">İçindekiler</a></li>
<li><a href="#perfect-forwarding">Perfect Forwarding</a>
<ul>
<li><a href="#auto-"><code>auto &amp;&amp;</code></a>
<ul>
<li><a href="#return-value-perfect-passing">Return value perfect passing</a></li>
<li><a href="#perfect-returning">Perfect Returning</a>
<ul>
<li><a href="#decltypeauto">decltype(auto)</a></li>
</ul>
</li>
<li><a href="#reference-qualifier">Reference Qualifier</a></li>
</ul>
</li>
<li><a href="#universal-referans-olmayan-fakat-%C3%B6yle-g%C3%B6z%C3%BCken-senaryolar">Universal Referans Olmayan Fakat Öyle Gözüken Senaryolar</a></li>
</ul>
</li>
<li><a href="#move-only-types">Move Only Types</a></li>
<li><a href="#stlde-move-semantics-ve-perfect-forwarding">STL'de Move Semantics ve Perfect Forwarding</a>
<ul>
<li><a href="#algoritmalar%C4%B1">Algoritmaları</a></li>
<li><a href="#remove--remove_if--unique">remove &amp; remove_if &amp; unique</a></li>
<li><a href="#emplace">Emplace</a></li>
<li><a href="#copy_backward-algoritmas%C4%B1">Copy_backward algoritması</a></li>
<li><a href="#move_backward-algoritmas%C4%B1">Move_backward algoritması</a></li>
<li><a href="#move-iterat%C3%B6r-adapt%C3%B6r%C3%BC">Move Iteratör Adaptörü</a></li>
</ul>
</li>
<li><a href="#literal-operator-functions">Literal Operator Functions</a>
<ul>
<li><a href="#userdefined-literal">Userdefined Literal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="perfect-forwarding">Perfect Forwarding</h2>
<p><code>std::forward&lt;&gt;</code> kullanımını incelemiştik.</p>
<p>Lambda ifadelerinde türün elimizde olmadığından bahsetmiştik.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-keyword">auto</span>&amp;&amp; t){
        std::forward&lt;<span class="hljs-keyword">decltype</span>(t)&gt;(t);
    };
    <span class="hljs-comment">// C++20 ile</span>
    <span class="hljs-keyword">auto</span> fn1 = []&lt;<span class="hljs-keyword">typename</span> T&gt;(T &amp;&amp; t){   
        std::forward&lt;T&gt;(t);
    };
}
</code></pre>
<p>Kısaltımlış template sentaksı da eklendi</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T x)</span></span>;
<span class="hljs-comment">//C++20 ile aşağıdaki gibi yazılabilir.</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> &amp;&amp;x)</span></span>;
</code></pre>
<ul>
<li>Universasl reference'ı sadece perfect forwarding için kullanmak zorudnda değiliz ve terimde de bir uyuşmazlık oluşuyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">(std::string iterator beg, std::string::iterator end)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;non const semantics on the passed range \n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">navigate</span><span class="hljs-params">(std::string::const_iterator beg, std::string::const_iterator end)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;const semantics on the passed range \n&quot;</span>;
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_contianer</span><span class="hljs-params">(T &amp;&amp;t)</span>
</span>{
    <span class="hljs-built_in">navigate</span>(std::<span class="hljs-built_in">begin</span>(t), std::<span class="hljs-built_in">end</span>(t));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name{<span class="hljs-string">&quot;mutable test&quot;</span>}
    std::string <span class="hljs-type">const</span> cname{<span class="hljs-string">&quot;imutable test&quot;</span>};    
    <span class="hljs-built_in">process_contianer</span>(name); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(cname); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::string{<span class="hljs-string">&quot;temporary&quot;</span>}); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::<span class="hljs-built_in">move</span>(name)); <span class="hljs-comment">// non const semantics on the passed range</span>
    <span class="hljs-built_in">process_contianer</span>(std::<span class="hljs-built_in">move</span>(cname)); <span class="hljs-comment">// non const semantics on the passed range</span>
}
</code></pre>
<p>navigate fonksiyonun 2tane overloadi var birinin parametreleri const diğerininki const olmayan iterator. <code>process_container</code> için de const'uluk korunuyor ve çağrı buna göre yapılıyor.</p>
<p>Kendimiz de constluğa bağlı generic bir fonksiyonda oluşturabiliriz.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; )</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_const_v&lt;std::<span class="hljs-type">remove_reference_t</span>&lt;T&gt;&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;const &quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;non const &quot;</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_lvalue_reference_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::string name{<span class="hljs-string">&quot;non const test&quot;</span>}
    <span class="hljs-built_in">func</span>(name); <span class="hljs-comment">// non const</span>
    std::string cname{<span class="hljs-string">&quot;const test&quot;</span>}
    <span class="hljs-built_in">func</span>(cname); <span class="hljs-comment">// const</span>

    <span class="hljs-built_in">func</span>(Myclass{}); <span class="hljs-comment">// non const</span>
    Myclass c;
    <span class="hljs-built_in">func</span>(c); <span class="hljs-comment">// non const</span>
    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(c)); <span class="hljs-comment">// non const</span>
}
</code></pre>
<blockquote>
<p>Buradaki if constexpre run time'a değil compile time ile alakalı bir fonksiyon.</p>
</blockquote>
<p>Universal reference parametre birden fazla yerde kullanılabiliyor ve burada value-category dependent code yazabiliyoruz. type_Traits kütüphanesi ile T türünün hakkındaki bilgileri sorgulayabiliyoruz</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T,T)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// burada sentaks hatası yok</span>
    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2.</span>); <span class="hljs-comment">// Sentaks hatası</span>
    <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;ali&quot;</span>,<span class="hljs-string">&quot;ayse&quot;</span>); <span class="hljs-comment">//sentaks hatası değil </span>
}
</code></pre>
<p>Derleyici açısından ilk argümana bakılırsa T int, ikinci argümana bakılırsa T double. Burada sentaks hatası oluşuyor.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;,T&amp;)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;ali&quot;</span>,<span class="hljs-string">&quot;ayse&quot;</span>); <span class="hljs-comment">//SENTAKS HATASI</span>
}
</code></pre>
<p>Burada aynı sentaks hatası oluşuyor çünkü çıkarım <code>const char [4]</code>, <code>const char[5]</code> olarak yapılıyor.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;T&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name); <span class="hljs-comment">// SENTAKS HATASI</span>
}
</code></pre>
<p>Bu sentaks hatasının nedeni 1.parametrenin çıkarımı T'nin string olması üzerine, 2.parametre içinse T'nin çıkarımı T&amp; olarak ve string &amp; olarak yapılıyor. Bu yüzden hata oluşuyor.</p>
<ul>
<li>remove_reference kullanarak bu sorunu çözebiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;std::<span class="hljs-type">remove_referednce_t</span>&lt;T&gt;&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<ul>
<li>2 tane template parametre kullanarak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElemType, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::vector&lt;ElemType&gt; &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<ul>
<li>Ya da container türünü template parametresi olarak alabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Container &amp;vec, T &amp;&amp;val)</span>
</span>{
    vec.<span class="hljs-built_in">push_back</span>(std::forward&lt;T&gt;(val));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::vector&lt;std::string&gt; vec;
    std:string name;
    <span class="hljs-built_in">insert</span>(vec, name);
}
</code></pre>
<h3 id="auto-"><code>auto &amp;&amp;</code></h3>
<ul>
<li>auto &amp;&amp; ile universal reference'ı kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {}; 

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-keyword">auto</span> &amp;&amp;r1 = Myclass{}; <span class="hljs-comment">// Myclass = </span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r2 = m; <span class="hljs-comment">// auto = Myclass &amp; reference collapsing ile Myclass &amp; oluyor</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r3 = cm;
    <span class="hljs-keyword">auto</span> &amp;&amp;r4 = std::<span class="hljs-built_in">move</span>(m);
    <span class="hljs-keyword">auto</span> &amp;&amp;r5 = std::<span class="hljs-built_in">move</span>(cm);
}
</code></pre>
<blockquote>
<p>fonksiyonun parametresi T'türü için yapılan çıkarım nasıl yapılıyorsa, auto için ayapılan çıkarım da aynı şekilde yapılıyor. Buradaki çıkarım <code>auto</code> için yapılıyor. Template çıkarımı da T'türü için çıkarım yapııyor.</p>
</blockquote>
<p>Kullanılmasının gerekli olduğu senaryolar:</p>
<ul>
<li>Forwarding reference olarak kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;&amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;&amp;)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;

    <span class="hljs-keyword">auto</span> &amp;&amp;r1 = Myclass{}; 
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r1)&gt;(r1)); <span class="hljs-comment">// foo(Myclass{}) arasında bir fark yok</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r2 = m;
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r2)&gt;(r2)); <span class="hljs-comment">// foo(Myclass &amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r3 = cm;
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r3)&gt;(r3)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r4 = std::<span class="hljs-built_in">move</span>(m);
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r4)&gt;(r4)); <span class="hljs-comment">// foo(Myclass &amp;&amp;)</span>
    <span class="hljs-keyword">auto</span> &amp;&amp;r5 = std::<span class="hljs-built_in">move</span>(cm);
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r5)&gt;(r5)); <span class="hljs-comment">// foo(const Myclass &amp;&amp;)    </span>
}
</code></pre>
<p>Doğrudan argüman olarak göndermek ile argüman olarak göndereceiğimiz ifadeye universal referans bağladık ve bunu fonksiyona argüman olarak forward ederek kullandık.</p>
<h4 id="return-value-perfect-passing">Return value perfect passing</h4>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {};
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;&amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Myclass &amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(Myclass &amp;)\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp;&amp;)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(const Myclass &amp;&amp;)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">const</span> Myclass &amp; <span class="hljs-title">func_const_lref</span><span class="hljs-params">(<span class="hljs-type">const</span> Myclass &amp; str)</span></span>{ <span class="hljs-keyword">return</span> str;}
<span class="hljs-function">Myclass &amp; <span class="hljs-title">func_non_const_lref</span><span class="hljs-params">(Myclass &amp; str)</span></span>{ <span class="hljs-keyword">return</span> str;}
<span class="hljs-function">Myclass &amp;&amp; <span class="hljs-title">func_ref</span><span class="hljs-params">(Myclass &amp;&amp; str)</span></span>{ <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);}
<span class="hljs-function">Myclass <span class="hljs-title">func_value</span><span class="hljs-params">(Myclass str)</span></span>{ <span class="hljs-keyword">return</span> str;}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_rref</span>(Myclass{})); <span class="hljs-comment">// foo(Myclass &amp;&amp;) yukarıdaki fonksiyonlardan parametresi  Myclass &amp;&amp; olan&#x27;ın çağırılması lazım.</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_non_const_lref</span>(m)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_const_lref</span>(cm)); <span class="hljs-comment">// foo(const Myclass &amp;)</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">func_value</span>(m)); <span class="hljs-comment">// foo(Myclass &amp;&amp;)</span>
}
</code></pre>
<p>Func_rref fonksiyonuna geçici nesne yolladık ve geçilen argümanı move etti. Geri dönüş değerini perfect forward aetmek için özel bir şey yapmamıza gerek yok.</p>
<p>Fakat biz bu geri dönüş değerini bir fonksiyonda tutmak ve daha sonra bu değişkeni kullanarak fonksiyon çağırısını yapmak istiyorsak bu durumda <code>auto &amp;&amp;</code> kullanmak zorudnayız.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T &amp;&amp;t)</span>
</span>{
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(t)));
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    <span class="hljs-comment">//Type  ret = bar(std::forward&lt;T&gt;(t));</span>
    <span class="hljs-comment">//foo(ret); //buradaki ret&#x27;in türü ne olucak. Bu l&#x27;artık l value oluyor</span>
    <span class="hljs-keyword">auto</span> &amp;&amp; ret = <span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(t));
    <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;(ret));
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : ivec)
    {
        i = <span class="hljs-number">10</span>;
    }
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
}
</code></pre>
<p>Fakat eğer vector'ün bool specializasyonu varsa bu durumda partial specializasyonu var.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;


    <span class="hljs-keyword">auto</span> x = ivec[<span class="hljs-number">2</span>]; <span class="hljs-comment">//burada proxy object döndürüyor.</span>
    <span class="hljs-comment">//x bir vector&#x27;un bool açılımının referansı türü nested type</span>
    <span class="hljs-keyword">auto</span> x = ivec.<span class="hljs-keyword">operator</span>[](<span class="hljs-number">2</span>); 
    ivec[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// yazıldığında</span>
    ivec.<span class="hljs-keyword">operator</span>[](<span class="hljs-number">3</span>).<span class="hljs-keyword">operator</span>=(<span class="hljs-literal">true</span>); <span class="hljs-comment">// yazılmış oluyor.</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec){ cout&lt;&lt; val; }
    <span class="hljs-comment">/*derleyicinin ürettiği psuedo kod
    auto &amp;&amp;rng = ivec; 
    auto pos = rng.begin();
    auto end = rng.end();
    for(;pos != end; ++pos)
    {
        auto temp = *pos; eğer  val referans türü olsaydı auto &amp;temp olurdu, sağ taraf referans türü olsaydı auto &amp;&amp;temp olurdu.
    }
    */</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : ivec){ i = <span class="hljs-literal">true</span>;  }
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec){ cout&lt;&lt; val; }

    <span class="hljs-keyword">auto</span> iter = ivec.<span class="hljs-built_in">begin</span>();
    iter.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">0</span>) = <span class="hljs-literal">true</span>; <span class="hljs-comment">//bu bize referans dödnüremeyeceğine göre, proxy nesnesi dönüyor</span>
    <span class="hljs-comment">//reference nested type&#x27;ından nesneye yapılmış oluyor.</span>
}
</code></pre>
<blockquote>
<p>Vector'un bool açılımının 2 sorunu var 1.container değil, 2.bool tutmuyor. :D</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">reference</span>
    {
        <span class="hljs-keyword">operator</span>=(<span class="hljs-type">bool</span>);
        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;
    }
    reference <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> idx);
};
</code></pre>
<p>Eğer <code>auto val</code> yerine <code>auto &amp;&amp;val</code> olsaydı bu durumun bir etkisi olmayacaktı.</p>
<p>Aşağıdaki kodda amaç öyle bir fill fonksiyonu oluşturmakki 1.argümandaki container'a 2.parametredeki val değerini yerleştirmek.</p>
<ul>
<li><code>auto &amp;&amp;</code> kullanarak sentaks hatasının önüne geçilebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fill</span><span class="hljs-params">(C &amp; con, <span class="hljs-type">const</span> T&amp; val)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; elem : con)
    <span class="hljs-comment">//Sentaks hatasını engellemek için universal refeerans kullanmak gerekiyor. </span>
    {
        elem = val;
    }
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fill_2</span><span class="hljs-params">(C &amp; con, <span class="hljs-type">const</span> T&amp; val)</span>
</span>{
    <span class="hljs-keyword">auto</span> &amp;&amp;rng = con;
    <span class="hljs-keyword">auto</span> pos = rng.<span class="hljs-built_in">begin</span>();
    <span class="hljs-keyword">auto</span> end = rng.<span class="hljs-built_in">end</span>();
    <span class="hljs-keyword">for</span>(;pos != end; ++pos)
    {
        <span class="hljs-keyword">auto</span> &amp;elem = *pos; <span class="hljs-comment">//pos.operator*() bu fonksiyonun geri dönüş değeri referans ve r-value expression</span>
        <span class="hljs-comment">//sentaks hatasının nedeni l-value referansa  r-value expression atanması</span>
        *pos = val;
    }
}

<span class="hljs-function">inr <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-built_in">Fill</span>(ivec, <span class="hljs-number">10</span>);
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : ivec)
    {
        cout&lt;&lt; val;
    }

    vector&lt;string&gt; svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : svec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-built_in">Fill</span>(svec, <span class="hljs-string">&quot;necati&quot;</span>);
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : svec)
    {
        cout&lt;&lt; val;
    }
    vector&lt;<span class="hljs-type">bool</span>&gt; bvec{<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : bvec)
    {
        cout&lt;&lt; val;
    }
    <span class="hljs-comment">//Fill(bvec, true); //SENTAKS HATASI</span>
    cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<h4 id="perfect-returning">Perfect Returning</h4>
<p>Amacımız foo'nun geri döndürdüğü gibi olduğu gibi func fonksiyonun aynı geri dönüş değerini döndürmek istiyoruz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
??? <span class="hljs-built_in">func</span>(T &amp;&amp;t)
{
    <span class="hljs-built_in">foo</span>(std::forward&lt;T&gt;(t));
}
</code></pre>
<p>Geri dönüş değeri yerine <code>decltype(auto)</code> yazmamız gerekiyor. Peki bu ne demek?</p>
<h5 id="decltypeauto">decltype(auto)</h5>
<p><strong>decltype</strong> için 2 farklı decltype var.</p>
<ol>
<li>Operandı olan ifadenin bir isim formunda olması, declaration türünü elde ediyor</li>
<li>Eğer bir expression olursa, bu durumda ifadenin değer kategorisi oluyor:</li>
</ol>
<ul>
<li>PRvalue ==&gt; T</li>
<li>Lvalue ==&gt; T&amp;</li>
<li>Xvalue ==&gt; T&amp;&amp;</li>
</ul>
<p>decltype(auto)' da ise, tıpkı auto da olduğu bir değişkene ilk değer verdiğimizde, <code>auto</code>nun kurallarına göre değil de <code>decltype</code>a göre belirleniyor.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> &amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> &amp;&amp; <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">f1</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> expr; <span class="hljs-comment">// int &amp; f1() return type</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = x; <span class="hljs-comment">// int y = x;</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) z = <span class="hljs-number">4</span>; <span class="hljs-comment">// int z = 4;</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) t = <span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// int &amp; t = foo();</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) u = <span class="hljs-built_in">bar</span>(); <span class="hljs-comment">// int &amp;&amp; u = bar();</span>
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) y = (x); <span class="hljs-comment">// x ile yukarıdaki farklı anlamlara geliyor</span>
    
    <span class="hljs-type">int</span> m{}, * ptr{&amp;m};
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) r = m;
    <span class="hljs-comment">//decltpye(auto) ilave bir deklaratör alamıyor.</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{

};

<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">foo</span><span class="hljs-params">(Myclass m)</span>
</span>{
    <span class="hljs-comment">//return m; // Myclass</span>
    <span class="hljs-comment">//return (m); // Myclass &amp; olurdu ve otomatik ömürlü bir nesneye referans döndürmüş olur ve hata olurdu.</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_A</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> i; }
<span class="hljs-comment">//decltype(auto) fn_B(int i){ return (i); } </span>
<span class="hljs-comment">//Sentaks hatası fonksiyonun geri dönüş değeri int &amp; otomatik ömürlü nesneyi döndürüyor</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_C</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> (i+<span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_D</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> i++; }
<span class="hljs-comment">// Yok çünkü son ek ++ operatörü oluşturduğu ifade PR-value expression ve geri dönüş değeri int</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_E</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> ++i;}
<span class="hljs-comment">// Ön ek ++ operatörü oluşturduğu ifade L-value expression ve geri dönüş değeri int &amp; otamtik ömürlü nesneye referans dönüyor.</span>
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_F</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>{  <span class="hljs-keyword">return</span> (i &gt;= <span class="hljs-number">0</span> ? i : <span class="hljs-number">0</span>); }
<span class="hljs-comment">// Bir problem yok, çünkü ternary operatorünün operandları PR-value expression ve geri dönüş değeri int</span>
d<span class="hljs-comment">//ecltype(auto) fn_G(int i, int j) {  return i &gt;= j ? i : j; }</span>
<span class="hljs-comment">// ternary operatör&#x27;Ün return ifadesinin kategörüsü gene int &amp; döndürüyor</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> {  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; };
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">fn_H</span><span class="hljs-params">()</span></span>{   <span class="hljs-keyword">return</span> (S{});}
<span class="hljs-comment">// İfade PR-value expression ve geri dönüş değeri S</span>
<span class="hljs-comment">//decltype(auto)fn_I(){  return (S{}.i);}</span>
<span class="hljs-comment">// R-value nesnelerin non-static veri elemanlarına erişim ifadesi X-value expression ve dönüş değeri int &amp;&amp; oluyor ve geçici nesneye referans dönüyor.</span>
</code></pre>
<p>O zaman bizim bunu perfect return etmemiz için</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;typenamem T&gt;
<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">foo</span><span class="hljs-params">(T &amp;&amp;val)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bar</span>(std::forward&lt;T&gt;(val));
}

<span class="hljs-comment">// lambda fonksiyonları için trailing return type kullanmamız gerekiyor.</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-keyword">auto</span> &amp;&amp;r) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bar</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(r)&gt;(r));
    }
}
</code></pre>
<ul>
<li>Fonksiyonun geri dönüş değerini <code>decltype(auto)</code> ile bildirilen bir değişkende tuttuk. Böylece geri dönüş değeri hergangi bir valueType olabilir. Eğer burada geri dönüş değeri:</li>
<li>
<ul>
<li>R-value referans türü ise, <code>if constexpr</code> ile bu saptanıyor.</li>
</ul>
</li>
<li>
<ul>
<li>ret value olabilir.</li>
</ul>
</li>
<li>
<ul>
<li>L-value referans olabilir. Bu iki durumda ya value return ya da l-value referans return ediyoruz.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">call</span><span class="hljs-params">(Func f, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret {<span class="hljs-built_in">f</span>(std::forward&lt;Args&gt;(args)...)};
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_rvalue_refeerence_v&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title">std::move</span><span class="hljs-params">(ret)</span></span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> ret; 
}
</code></pre>
<p>Bunu bir lambda fonksiyonu ile de yapabiliriz.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> &amp;&amp;...args) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);
    };
    <span class="hljs-keyword">auto</span> f1 = [](<span class="hljs-keyword">auto</span> &amp;&amp;...args) -&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>)
    {
        <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) ret = <span class="hljs-built_in">func</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_rvalue_reference_v&lt;<span class="hljs-keyword">decltype</span>(ret)&gt;)</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title">std::move</span><span class="hljs-params">(ret)</span></span>;
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> ret;
    }
}
</code></pre>
<ul>
<li>C++23 öncesinde ki sorun, hayatı bitmiş bir nesneye tekrar kullanmaya çalışıyoruz ve dangling reference oluyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">create_svec</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span>(std::string s : <span class="hljs-built_in">create_svec</span>()){}
    <span class="hljs-comment">// Aşağıdaki 3 döngüde tanımsız davranış oluşturuyor</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)){} <span class="hljs-comment">// </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>()[<span class="hljs-number">0</span>]){} <span class="hljs-comment">// </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c: <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">front</span>()){} <span class="hljs-comment">//</span>
}
<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r1 = <span class="hljs-built_in">create_svec</span>(); <span class="hljs-comment">//life extension var.</span>
    <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">creae_svec</span>(); <span class="hljs-comment">//SENTAKS HATASI sağ taraf değeri sol refereansa bağlanamaz life extension yok </span>
    vector&lt;std::string&gt; &amp;&amp;r2 = <span class="hljs-built_in">create_svec</span>();

     <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r3 = <span class="hljs-built_in">create_svec</span>().<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//UNDEFINED BEHAVIOR. Burada life extension yok, </span>
}
</code></pre>
<p>Yukarıdaki kodların sorununu anlamak için aşağıdkai kodu inceleyelim.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    ~<span class="hljs-built_in">Myclass</span>(){ std::cout&lt;&lt; <span class="hljs-string">&quot;object Destructed....\n&quot;</span>;}
    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getVec</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>{
        <span class="hljs-keyword">return</span> ivec;
    }
<span class="hljs-keyword">private</span>:
    std::vector&lt;<span class="hljs-type">int</span>&gt; ivec{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
};
<span class="hljs-function">Myclass <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Myclass{};
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    {
        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r = <span class="hljs-built_in">foo</span>();
        cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..1\n&quot;</span>
    }<span class="hljs-comment">//obje burada destruyor olmalı</span>
    {
        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; r = <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">getVec</span>(); <span class="hljs-comment">//life-extension yok, obje burada destruct ediliyor</span>
        <span class="hljs-comment">//r&#x27;yi kullansaydık tanımsız bir davranış oluşturmuş oluyor.</span>
        cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..2\n&quot;</span>
    }
    cout&lt;&lt; <span class="hljs-string">&quot;main devam ediyor..3\n&quot;</span>
}
</code></pre>
<p>C++23 ile bu implementasyon değişti. Umulmadık ve beklenmedik durumlar oluşuyor. Bu bizi neden ilgilendiriyor.</p>
<h4 id="reference-qualifier">Reference Qualifier</h4>
<p>Bir üye fonksiyonun hangi değer kategorisindeki nesneler ile çalışabileceğini gösteriyor. Örneğin l-value referansı ile nitelendirilimş bir üye fonksiyon.</p>
<p>Aşağıdaki gibi bir fonksiyon yazılıdığına bir kopyalama oluyor. Fakat bunun geri dönüş değerini <code>const referans</code> yapılarak bir erişim verilebilir.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">std::string <span class="hljs-title">get_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> m_str;}
<span class="hljs-keyword">private</span>:
    std::string m_str;
};

<span class="hljs-function">Myclass <span class="hljs-title">create_myclass</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Myclass{};
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : <span class="hljs-built_in">create_myclass</span>().<span class="hljs-built_in">get_str</span>()){}
}
</code></pre>
<p>Aşağıdaki kullanımlar legal fakat bunların semantik bir anlamı yok.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Nec</span>{};
<span class="hljs-function">Nec <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">foo</span>() = <span class="hljs-built_in">foo</span>()
    Nec{} = <span class="hljs-built_in">Nec</span>();
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;</span>; <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>&amp;&amp;</span>; <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>; <span class="hljs-comment">//şeklinde de olaiblir.</span>
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    m.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;m)</span>
    Myclass{}.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    std::<span class="hljs-built_in">move</span>(m).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    m.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>
    m.<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">//SENTAKS HATASI</span>

    cm.<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">//</span>
}
</code></pre>
<ul>
<li>Overload da edilebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;l-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>&amp;&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;r-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;const l-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp;</span>{ std::cout&lt;&lt; <span class="hljs-string">&quot;const r-value reference qualifier\n&quot;</span>; } <span class="hljs-comment">//l-value reference qualifier</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-type">const</span> Myclass cm;
    m.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;m) </span>
    cm.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;cm)</span>
    Myclass{}.<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;Myclass{})</span>
    <span class="hljs-built_in">move</span>(m).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;m)</span>
    <span class="hljs-built_in">move</span>(cm).<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// foo(&amp;&amp;cm)</span>
}
</code></pre>
<ul>
<li>Bazı senaryolarda bu çok büyük bir hata olabilir. Örneğin</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span></span>{    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(bool)\n&quot;</span>;}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::string)</span>  </span>{    std::cout&lt;&lt; <span class="hljs-string">&quot;foo(std::string)\n&quot;</span>;}
<span class="hljs-function">std::string <span class="hljs-title">getStr</span><span class="hljs-params">()</span></span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;necati&quot;</span>;}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//if(getstr() = &quot;necati&quot;)  //SENTAKS HATASI çünkü boola dönüştürülemez.</span>
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">getstr</span>() == <span class="hljs-string">&quot;necati&quot;</span>);
    <span class="hljs-built_in">foo</span>(<span class="hljs-built_in">getstr</span>() = <span class="hljs-string">&quot;necati&quot;</span>); <span class="hljs-comment">// Sentaks hatası yok ve parametresi string olan fonksiyon çağırılıyor.</span>
    <span class="hljs-comment">// ilk olarak atama operatörü çağırılıyor ve bu atama operatör fonksiyonu reference qualifier değil ve teknik bir engel yok.</span>
    <span class="hljs-comment">// bu kod foo(getstr().operator=(&quot;necati&quot;)) şeklinde çalışıyor. Operator atama fonksiyonun geri dönüş değeri *this. ve string overload&#x27;da çalışır.</span>
}
</code></pre>
<p>Move semantiği ile kullanımına bir örnek</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string &amp;name) : m_name{name}{}
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> &amp;&amp;</span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;r-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(m_name); }
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;l-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> m_name; }
    <span class="hljs-function">std::string &amp; <span class="hljs-title">get_name</span><span class="hljs-params">()</span> &amp; </span>{  std::cout&lt;&lt; <span class="hljs-string">&quot;const l-value reference qualifier\n&quot;</span>; <span class="hljs-keyword">return</span> m_name; }
<span class="hljs-keyword">private</span>:
    std::string m_name;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T &amp;&amp;x)</span>
</span>{
    <span class="hljs-keyword">auto</span> name = std::forward&lt;T&gt;(x).<span class="hljs-built_in">get_name</span>();
    std::cout&lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person p{<span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-type">const</span> Person cp{<span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-built_in">foo</span>(p); <span class="hljs-comment">// l-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(cp); <span class="hljs-comment">// l-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(Person{<span class="hljs-string">&quot;necati&quot;</span>}); <span class="hljs-comment">// r-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(p)); <span class="hljs-comment">// r-value reference qualifier</span>
    <span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(cp)); <span class="hljs-comment">// l-value reference qualifier</span>
}
</code></pre>
<h3 id="universal-referans-olmayan-fakat-öyle-gözüken-senaryolar">Universal Referans Olmayan Fakat Öyle Gözüken Senaryolar</h3>
<p>Örneğin aşağıdaki kod universal referansı değil, const sağ taraf referans.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;&amp;)</span></span>{}
</code></pre>
<p>Nested type'lar, burada x'in türü sağ taraf referansı.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Con &amp; x, <span class="hljs-keyword">typename</span> Con::value_type &amp;&amp;)</span></span>{}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::vector&lt;T&gt; &amp;&amp;)</span></span>{}
</code></pre>
<p>generic bir sınıfta kullandığımız zaman universal referans <strong>olmayan</strong> bir fonksiyon yazmış oluyoruz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;&amp;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;push(const T &amp;&amp;)\n&quot;</span>;
        m_con.<span class="hljs-built_in">push_back</span>(val);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T &amp;&amp;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;push(T &amp;&amp;)\n&quot;</span>;
        m_con.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(val));
    }

<span class="hljs-keyword">private</span>:
    std::vector&lt;T&gt; m_con;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Stack&lt;std::string&gt; istack;
    std::string str{<span class="hljs-string">&quot;lvalue&quot;</span>};
    istack.<span class="hljs-built_in">push</span>(str);
    istack.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(str));
}
</code></pre>
<p>Fonksiyonun parametresi ne olmalı?</p>
<ul>
<li>Elimizde bir sınıf türünden parametre alan ve salt okuma yapan bir fonksiyon olsun:</li>
<li>
<ul>
<li>Eğer bu string'in tersten okunması gerekiyorsa</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str)</span>
</span>{
    <span class="hljs-keyword">auto</span> stem = str;
    <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());
}
</code></pre>
<blockquote>
<p>ADL: Argument Dependent Lookup: Eğer fonksiyonua gönderilen agümanlardan biri bir namespace içerisinde tanımlanmış türe ilişkin ise, o zaman fonksiyon ismi o namespace içerisinde de aranır.</p>
</blockquote>
<h2 id="move-only-types">Move Only Types</h2>
<p>Sınıflar problem domainindeki varlıkları temsil etme amacı olarak kullanılıyor ve bu varlıklardan bazıları kopyalamaya uygun ya da birden fazla probleme yol açılıyor. Sınıflar bunu engellemek için kopyalamaya karşı kapatılıyor. Fakat bu varlık eğer bir kaynağı tutuyorsa o kaynağı tekrar kullanmak için move edilebiliyor.</p>
<p>Bu sınıfı:</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;) = <span class="hljs-keyword">default</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;) = <span class="hljs-keyword">default</span>;
};
</code></pre>
<p>Tanımlayabiliyoruz. Move memberlar için 2 seçeneğimiz var, bu memberları biz yazabiliriz ya da compiler bunu bizim için yazabilir.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(MoveOnly m)</span>
</span>{
    std::cout&lt;&lt; <span class="hljs-string">&quot;func(MoveOnly m)\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    MoveOnly m;
    <span class="hljs-built_in">func</span>(m); <span class="hljs-comment">// SENTAKS HATASI</span>
    <span class="hljs-built_in">func</span>(std::<span class="hljs-built_in">move</span>(m)); <span class="hljs-comment">// MoveOnly(MoveOnly&amp;&amp;)</span>
}
</code></pre>
<hr>
<p><strong>Inittializer List Hatırlatma</strong>:</p>
<ul>
<li>Container'lar söz konusu olduğunda <strong>initializer listleri</strong> var:</li>
<li>
<ul>
<li>Derleyici burada arka planda bir array oluşturuluyor ve bu arrayin öğelerini initializer listteki öğelerle hayata başlıyor ve burada bir <strong>kopyalama</strong> oluyor.</li>
</ul>
</li>
<li>
<ul>
<li>Yani bunları move only type'lar ile kullanamıyoruz. Initializer listessi arka planda 2 tane pointer tutuyor (Biri başlangıcını öbürü de bittiği yerini tutuyor).</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::initializer_list&lt;MoveOnly&gt; ilist)</span>
</span>{
    cout &lt;&lt; <span class="hljs-string">&quot;&amp;ilist &quot;</span>&lt;&lt; &amp;ilist&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;dizi adresi &quot;</span>&lt;&lt; ilist.<span class="hljs-built_in">begin</span>()&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::initializer_list&lt;<span class="hljs-type">int</span>&gt; mylist{<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>};
    cout &lt;&lt; <span class="hljs-string">&quot;&amp;ilist &quot;</span>&lt;&lt; &amp;mylist&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;dizi adresi &quot;</span>&lt;&lt; mylist.<span class="hljs-built_in">begin</span>()&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">func</span>(mylist);
}
</code></pre>
<ul>
<li>Size veya distance fonksiyonu çağırılarak boyutu elde edilebilir. For-based range loop ile de kullanılabilir.</li>
<li>Constructor'larda kullanılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>{
    std::vector&lt;<span class="hljs-type">int</span>&gt; ivec{a,b,c};
    ivec = {a,b,c};
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;<span class="hljs-type">int</span>&gt; ivec{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
}
</code></pre>
<ul>
<li>Initializer list parametreli bir constructor'ın önceliği daha yüksek.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span>){ std::cout&lt;&lt; <span class="hljs-string">&quot;Myclass(int)\n&quot;</span>; }
    <span class="hljs-built_in">Myclass</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt;){ std::cout&lt;&lt; <span class="hljs-string">&quot;Myclass(std::initializer_list&lt;int&gt;)\n&quot;</span>; }
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass myNec{<span class="hljs-number">10</span>};
    <span class="hljs-function">Myclass <span class="hljs-title">myNec1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;
}
</code></pre>
<p>Burada gennnellikle string sınıfı için soruluyor.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    cout &lt;&lt; <span class="hljs-built_in">string</span>(<span class="hljs-number">66</span>,<span class="hljs-string">&quot;X&quot;</span>)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; string{<span class="hljs-number">66</span>,<span class="hljs-string">&quot;X&quot;</span>}&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">19</span>,<span class="hljs-number">10</span>).<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; vector&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-number">19</span>,<span class="hljs-number">10</span>}.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<blockquote>
<p>STL'de genellikle insert işlemlerinde ayrı ayrı çağırmak yerine tek bir fonksiyon çağrısı ile yapabiliyorsak o çağrı ile yapabiliriz.</p>
</blockquote>
<hr>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-comment">//vecotr&lt;MoveOnly&gt; ivec{MoveOnly{}, MoveOnly{}, MoveOnly{}}; // SENTAKS HATASI çünkü burada kopyalama semantiği işliyor.</span>
    <span class="hljs-function">vector&lt;MoveOnly&gt; <span class="hljs-title">myvec</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;
    <span class="hljs-comment">//for(auto x : myvec){} //SENTAKS HATASI çünkü burada gene kopyalama yapılıyor.</span>
}
</code></pre>
<p><code>print_tr()</code> fonksiyonu ile amacımız sınıfın hangi özelliklere sahip olduğunu görmek.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MoveOnly</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MoveOnly</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-built_in">MoveOnly</span>(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MoveOnly&amp;) = <span class="hljs-keyword">delete</span>;
    <span class="hljs-built_in">MoveOnly</span>(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly(MoveOnly&amp;&amp;)\n&quot;</span>; }
    MoveOnly&amp; <span class="hljs-keyword">operator</span>=(MoveOnly&amp;&amp;){ std::cout&lt;&lt; <span class="hljs-string">&quot;MoveOnly&amp; operator=(MoveOnly&amp;&amp;)\n&quot;</span>; }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_tr</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_default_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;default constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not default constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_destructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;destructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not destructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_copy_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;copy constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not copy constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_copy_assignable_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;copy assignable\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not copy assignable\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_move_constructible_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;move constructible\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not move constructible\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_move_assignable_v&lt;T&gt;)</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;move assignable\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        std::cout&lt;&lt; <span class="hljs-string">&quot;not move assignable\n&quot;</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>{}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">print_tr</span>&lt;Myclass&gt;();
    <span class="hljs-built_in">print_tr</span>&lt;MoveOnly&gt;();
}
</code></pre>
<h2 id="stlde-move-semantics-ve-perfect-forwarding">STL'de Move Semantics ve Perfect Forwarding</h2>
<ul>
<li>
<p>iostream sınıfı</p>
</li>
<li>
<p>ofs move-only bir sınıf olmasına rağmen nesneyi döndürdü.</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span>

<span class="hljs-function">std::ofstream <span class="hljs-title">create_file</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;name)</span>
</span>{
    std::ofstream ofs{name};
    <span class="hljs-keyword">if</span>(!ofs)
    {
        <span class="hljs-keyword">throw</span> std::runtime_error{ name + <span class="hljs-string">&quot;File cannot be opened&quot;</span>};
    }
    <span class="hljs-keyword">return</span> ofs;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(std::ofstream ofs)</span></span>{}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::ofstream &amp; ofs)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> ofs = <span class="hljs-built_in">create_file</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);
    <span class="hljs-comment">//write(ofs); SENTAKS HATASI çünkü kopyalamaya karşı kapalı.</span>
    <span class="hljs-comment">//write(std::move(ofs)); </span>
    <span class="hljs-built_in">func</span>(ofs); <span class="hljs-comment">// bu aktarımda dikkatli olmak gerekiyor</span>
    <span class="hljs-comment">//Burada dosyanın durumunu bilmemiz için func fonksiyonunun ne yaptığını bilemiyoruz.</span>
}
</code></pre>
<ul>
<li>string sınıfı</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    string str{<span class="hljs-string">&quot;dogruyum\ncaliskanim\nbuyuklerimi saymak\nkucuklerimi sevmek\n&quot;</span>};
    istringstream iss{str};
    string name; 
    iss &gt;&gt; name;<span class="hljs-comment">//geline(iss,name) de yapabilirdik.</span>
    cout &lt;&lt;<span class="hljs-string">&quot;|&quot;</span> &lt;&lt; name &lt;&lt;<span class="hljs-string">&quot;|\n&quot;</span>
}
</code></pre>
<p>Modern cpp ile bu inserter ve extractor'un sağ taraf referansllı overloadları da ekledi</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string str{<span class="hljs-string">&quot;dogruyum\ncaliskanim\nbuyuklerimi saymak\nkucuklerimi sevmek\n&quot;</span>};
    <span class="hljs-type">int</span> x = <span class="hljs-number">345</span>;
    string name {<span class="hljs-string">&quot;cansin&quot;</span>};
    <span class="hljs-type">double</span> dval = <span class="hljs-number">4.2</span>;
    <span class="hljs-keyword">auto</span> s = (ostringstream <span class="hljs-built_in">oss</span>()&lt;&lt; x &lt;&lt; name &lt;&lt; dval).<span class="hljs-built_in">str</span>();
    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

    ofstream ofs{<span class="hljs-string">&quot;test.txt&quot;</span>};

}
</code></pre>
<ul>
<li>Bir vector taşındığı zaman, moved-from state'deki vector'ün size'ı 0 oluyor. Bu standartlarda garantili bir durum.</li>
</ul>
<h3 id="algoritmaları">Algoritmaları</h3>
<h3 id="remove--remove_if--unique">remove &amp; remove_if &amp; unique</h3>
<ul>
<li>Stl'deki bazı silme algoritmaları biz farkında olmasakta taşınmaya neden olabilir. Algoritmaların çoğunun parametreleri iterator olduğu için silme işlemleri yapamıyor ve bu algoritmalar o range'teki öğeeleri arrange ediyorlar.</li>
<li>Öğelerin sayısı değişmiyor fakat bazı öğeler moved-from state'de olabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ForIt, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;
<span class="hljs-function">ForIt <span class="hljs-title">Remove</span><span class="hljs-params">(ForIt first, ForIt last, <span class="hljs-type">const</span> T &amp;val)</span>
</span>{
    first = std::<span class="hljs-built_in">find</span>(first, last, val);
    <span class="hljs-keyword">if</span>(first != last)
         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = first; ++i != last;)
             <span class="hljs-keyword">if</span>(!(*i == val))
                *first++ = std::<span class="hljs-built_in">move</span>(*i); <span class="hljs-comment">//Burada neseneler moved-from state kalıyor olabilir.</span>
     <span class="hljs-keyword">return</span> first;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ForIt, <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryPred</span>&gt;
<span class="hljs-function">ForIt <span class="hljs-title">remove_if</span><span class="hljs-params">(ForIt first, ForIt last, UnaryPred f)</span>
</span>{
    first = std::<span class="hljs-built_in">find_if</span>(first, last, f);
    <span class="hljs-keyword">if</span>(first != last)
         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = first; ++i != last;)
             <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">f</span>(*i))
 
                *first++ = std::<span class="hljs-built_in">move</span>(*i);
     <span class="hljs-keyword">return</span> first;
}
</code></pre>
<blockquote>
<p>Remove bir range'teki öğeleri logic silme işlemine tabi tutuyor. Remove_if bir unaryPredicat'in true değer verdiği durumlarda logic silme yapıyor.
Unique ise aynı değere sahip üyelerin sayısını 1'e indiriyor.</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt; svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>, <span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">remove_if</span>(svec.<span class="hljs-built_in">begin</span>(),svec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> string &amp;s){ <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>) != std::string::npos;});
    <span class="hljs-type">int</span> cnt{};
    <span class="hljs-keyword">while</span>(iter != svec.<span class="hljs-built_in">end</span>())
    {
        cout&lt;&lt; ++cnt; &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*iter++ &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        
    }
}
</code></pre>
<p>Sınıfın veri elemanlarını initalize etmek için birden fazla yöntem kullanıyor olabiliriz. Josutis 3 tane ayrı sınıf oluşturuyor.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClassic</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonClassic</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
<span class="hljs-keyword">private</span>:
std::string m_name;
std::string m_surname;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInitMove</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonInitMove</span>(std::string name, std::string surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
<span class="hljs-keyword">private</span>:
    std::string m_name;
    std::string m_surname;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInitOverload</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">PersonInitOverload</span>(std::string name, std::string surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, std::string&amp;&amp; surname) : m_name{name}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, std::string&amp;&amp; surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">const</span> std::string &amp;surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{name}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(std::string&amp;&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *surname) : m_name{std::<span class="hljs-built_in">move</span>(name)}, m_surname{surname}{}
    <span class="hljs-built_in">PersonInitOverload</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, std::string&amp;&amp; surname) : m_name{name}, m_surname{std::<span class="hljs-built_in">move</span>(surname)}{}  
<span class="hljs-keyword">private</span>:
    std::string m_name;
    std::string m_surname;
};

<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pname = <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;
<span class="hljs-type">const</span> <span class="hljs-type">char</span>* psurname = <span class="hljs-string">&quot;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&quot;</span>;

<span class="hljs-keyword">using</span> Person = PersonClassic;
<span class="hljs-comment">//using Person = PersonInitOverload;</span>
<span class="hljs-comment">//using Person = PersonInitMove;</span>
 
std::<span class="hljs-function">chrono::nanoseconds <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>
</span>{
    std::chrono::nanoseconds total_duration{};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;num ; ++i)
    {
        <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;N&#x27;</span>)</span></span>;
        <span class="hljs-function">std::string <span class="hljs-title">surname</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-string">&#x27;S&#x27;</span>)</span></span>;
        <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
        Person px{pname, psurname};
        Person p1{name, surname};
        Person p3{std::<span class="hljs-built_in">move</span>(name), std::<span class="hljs-built_in">move</span>(surname)};
        <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();
        total_duration += end - start;
    }
    <span class="hljs-keyword">return</span> total_duration;
}

<span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">100&#x27;000</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">measue</span>(<span class="hljs-number">20</span>);
    std::chrono::nanoseconds nanosecond_duration{<span class="hljs-built_in">measure</span>(n)};
    std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt;millisecond_duration{nanosecond_duration};
    std::cout&lt;&lt; <span class="hljs-string">&quot;test resuls for &quot;</span>&lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; runs\n&quot;</span> &lt;&lt; millisecond_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ms\n&quot;</span>;
    std::cout&lt;&lt; <span class="hljs-string">&quot;test resuls for &quot;</span>&lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; runs\n&quot;</span> &lt;&lt; nanosecond_duration.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ns\n&quot;</span>;
}
</code></pre>
<p><a href="https://www.onlinegdb.com/online_c++_compiler">onlinegdb</a></p>
<p>En yavaş çalışan parametresi const referans olan. En hızlı çalışan ise move olan.</p>
<h3 id="emplace">Emplace</h3>
<ul>
<li>Push back eklenecek nesnenin nerede construct edildiğini biliyor. Sol referans olan overload'ın da copy-constructor çağırıyor, sağ taraf referansta olan ise move constructor'ı çağırıyor.</li>
<li>Emplace back C++17 ile artık geri dönüş değeri var ve <code>constexpr T&amp;</code> dönüyor.</li>
<li>
<ul>
<li>emplace yapıldığında ne copy ne de move constructor çağırılıyor. Burada container'ın allocator'ının edindiği alanda nesneyi oluşturuyor. Move-only bir sınıf içerisinde bu çağırılabilir.</li>
</ul>
</li>
<li>
<ul>
<li>emplace back çağırıldığında argümanların gönderildiği constructor'da diğer sınıf nesneleri için move-constructor'ı çağırabiliyor.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Allocator = std::allocator&lt;T&gt;&gt;
<span class="hljs-keyword">class</span> Vector
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">void</span> <span class="hljs-built_in">push_back</span>(<span class="hljs-type">const</span> T &amp;val)
    {
        <span class="hljs-comment">//new(place)T(t);</span>
        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, val);
        ++m_size;
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T &amp;&amp;val)</span>
    </span>{
        <span class="hljs-comment">//new(place)T(std::move(t));</span>
        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, std::<span class="hljs-built_in">move</span>(val));
        ++m_size;
    }
    
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T&amp; <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-comment">//new(place)T(std::forward&lt;Args&gt;(args)...</span>

        <span class="hljs-keyword">if</span>(m_size == m_capacity)
            <span class="hljs-built_in">reserve</span>(m_capacity * <span class="hljs-number">2</span>);
        m_allocator.<span class="hljs-built_in">construct</span>(m_elem + m_size, std::forward&lt;Args&gt;(args)...);
        ++m_size;
        <span class="hljs-keyword">return</span> m_elem[m_size - <span class="hljs-number">1</span>];
    }
<span class="hljs-keyword">private</span>:
 
};

<span class="hljs-comment">//Emplace_back 2. faydası, birden fazla parametreli olan olabilir.</span>

vector&lt;Fighter&gt; fvec;
fvec.<span class="hljs-built_in">emplace_back</span>(exp1, exp2, exp3); <span class="hljs-comment">//bu argümanlarda sınıfın constructor&#x27;ına geçiriliyor </span>
<span class="hljs-comment">// ve  bunlar R-value expresionsa bunlar için de move constructor çağırılıyor.</span>
</code></pre>
<h3 id="copy_backward-algoritması">Copy_backward algoritması</h3>
<p>Elimizde bir vektör var ve</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;nutility.h&quot;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    <span class="hljs-built_in">iota</span>(ivec.<span class="hljs-built_in">begin</span>(),ivec.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);
    <span class="hljs-built_in">print</span>(ivec);
    <span class="hljs-comment">//ilk 1.öğeyi 3.öğeye gelecek şekilde kopyalamak istiyorsak.</span>
    <span class="hljs-built_in">copy_backward</span>(ivec.<span class="hljs-built_in">begin</span>(), ivec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">5</span>, ivec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">7</span>); <span class="hljs-comment">//yazma range&#x27;nin end iterator&#x27;ü</span>
    <span class="hljs-built_in">print</span>(ivec);
}
</code></pre>
<blockquote>
<p><code>std::iota(ivec.begin(),ivec.end(),0)</code> ile 0'dan başlayarak 10'a kadar olan sayıları ivec'e atıyoruz.
copy_backward ile reverse copy arasında fark var.</p>
</blockquote>
<p>Copy_backward:</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
OutIter <span class="hljs-title">Copy</span><span class="hljs-params">(InIter first, InIter last, OutIter dest_first)</span>
</span>{
    <span class="hljs-keyword">while</span> (first != last)
    {
        *dest_first++ = *first++;
    }
    <span class="hljs-keyword">return</span> dest_first;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> BidIt1, <span class="hljs-keyword">typename</span>  BidIt2&gt;
BidIt2 <span class="hljs-title">CopyBackward</span><span class="hljs-params">(BidIt1 first, BidIt1 last, BidIt2 dest_last)</span>
</span>{
    <span class="hljs-keyword">while</span>(last != first)
        *--dest_last = *--last;
    <span class="hljs-keyword">return</span> dest_last;
}
</code></pre>
<h3 id="move_backward-algoritması">Move_backward algoritması</h3>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InIter, <span class="hljs-keyword">typename</span> OutIter&gt;
OutIter <span class="hljs-title">Move</span><span class="hljs-params">(InIter first, InIter last, OutIter dest_first)</span>
</span>{
    <span class="hljs-keyword">while</span> (first != last)
    {
        *dest_first++ = std::<span class="hljs-built_in">move</span>(*first++);
    }
    <span class="hljs-keyword">return</span> dest_first;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> BidIt1, <span class="hljs-keyword">typename</span>  BidIt2&gt;
BidIt2 <span class="hljs-title">MoveBackward</span><span class="hljs-params">(BidIt1 first, BidIt1 last, BidIt2 dest_last)</span>
</span>{
    <span class="hljs-keyword">while</span>(last != first)
        *--dest_last = std::<span class="hljs-built_in">move</span>(*--last);
    <span class="hljs-keyword">return</span> dest_last;
}
</code></pre>
<p>Örneğin:</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt; sv{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>, <span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">destvec</span><span class="hljs-params">(svec.size())</span></span>;
    <span class="hljs-built_in">copy</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), destvec.<span class="hljs-built_in">begin</span>());
    <span class="hljs-built_in">print</span>(destvec);
    <span class="hljs-type">int</span> count{};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name:svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }        
    cout&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-built_in">move</span>(svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>(), destvec.<span class="hljs-built_in">begin</span>());
    count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name:svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
    }   
}
</code></pre>
<h3 id="move-iteratör-adaptörü">Move Iteratör Adaptörü</h3>
<p>Move iteratör C++11 ile dile eklendi.</p>
<p><strong>Adaptör</strong>: Adaptör tasarım paternini implemente eden bir sınıf. STL içinde:</p>
<ul>
<li>Fonksiyon adaptörleri: Bir callable alıyor ve bir callable geri veriyor.</li>
<li>Container adaptörleri: <code>Stack</code>, <code>queue</code>, <code>priority_queue</code>. Bir container'ı data member olarak alıyorlar ve o container'ın interfaceini kullanarak kendi interface'ini oluşturuyorlar.</li>
<li>Iterator adaptörleri: <code>reverse_iterator</code>, <code>move_iterator</code>, Bir tane iteratörü alıyor ve onun interface'ini kendi kullanım amacına göre uyarlıyor.</li>
</ul>
<p>2 şekilde adaptör oluşturulabilir:</p>
<ul>
<li>Biri container adaptörü gibi veri elemanı yaparak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
     </span>{
        mc.<span class="hljs-built_in">func</span>();
     }
<span class="hljs-keyword">private</span>:
    C mc;
};
</code></pre>
<ul>
<li>Kalıtım yoluyla:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myiterator</span> : <span class="hljs-keyword">public</span> Iter
{

};
</code></pre>
<p><code>move_iterator&lt;vector&lt;int&gt;::iterator&gt; iter;</code> gibi kullanılabilir.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-function"><span class="hljs-keyword">typename</span> std::move_iterator&lt;Iter&gt; <span class="hljs-title">MakeMoveIterator</span><span class="hljs-params">(Iter it)</span>
</span>{
    <span class="hljs-keyword">return</span> std::move_iterator&lt;Iter&gt;{it};
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-comment">//biz move iterator oluşturmak istiyoruz </span>
    
    <span class="hljs-comment">//1.si açıkça türü yazmak</span>
    moev_iterator&lt;vector&lt;string&gt;::iterator&gt; iter{svec.<span class="hljs-built_in">begin</span>()};

    <span class="hljs-comment">//2.si CTAD kullanılarak. C++17 ve sonrasında geldi </span>
    move_iterator iter2{svec.<span class="hljs-built_in">begin</span>()};

    <span class="hljs-comment">//3.sü ise bir fabrika fonksiyonu ile</span>
    <span class="hljs-keyword">auto</span> miter = <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">begin</span>());    
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    <span class="hljs-keyword">auto</span> miter = <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">begin</span>());
    <span class="hljs-keyword">auto</span> name = *miter;
    cout&lt;&lt; svec[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//ilk öğe taşınmış durumda ve 0 oluyor.</span>
}
</code></pre>
<p>Move iteratör dikkatli olunmak zorunda çünkü eğer bu nesne 2.kez dereferense ederse move-from state'deki nesneyi kullanmış oluyoruz ve bu tanımsız davranış oluşturuyor.</p>
<ul>
<li>Bu öğeleri container'ın üyelerini kullanarak yeni bir container'da kullanmış olmak istiyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vecor&lt;string&gt;svec{<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-string">&quot;veli&quot;</span>, <span class="hljs-string">&quot;selami&quot;</span>, <span class="hljs-string">&quot;necati&quot;</span>};
    vecor&lt;string&gt;svec1{svec.<span class="hljs-built_in">begin</span>(), svec.<span class="hljs-built_in">end</span>()}; <span class="hljs-comment">//copy constructor çağırıldı.</span>

    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; name : svec1)
    {
        cout&lt;&lt; ++cnt &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    vector&lt;string&gt;mvsvec{move_iterator{svec.<span class="hljs-built_in">begin</span>()}, move_iterator{svec.<span class="hljs-built_in">end</span>()}}; <span class="hljs-comment">//move constructor çağırıldı.</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; name : svec1)
    {
        cout&lt;&lt; ++cnt &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">(std::string s)</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;fonksiyona gelen sisim&quot;</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt;svec;
    <span class="hljs-built_in">rfill</span>(svec,<span class="hljs-number">10</span>,rname); <span class="hljs-comment">//nutility.h&#x27;dan geliyor ve vector&#x27;ü random olarak dolduruyor.</span>
    <span class="hljs-comment">//fonksiyona içinde i &#x27;harfi geçenleri fonksiyona göndermek istiyoruz.</span>
    for_each(svec.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">make_move_iterator</span>(svec.<span class="hljs-built_in">end</span>()),
    <span class="hljs-comment">//referans olursa sentaks hatası olur çünkü r-value dönüşmüş olur</span>
    <span class="hljs-comment">//[](string &amp;str) </span>
    <span class="hljs-comment">//[](string &amp;&amp;str) bu-da olmaz çünkü hala l-val expression. Bunun için do_something&#x27;te move yapmamız lazım.</span>
    [](string str) 
    {
        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;i&#x27;</span>) != string::npos)
            <span class="hljs-built_in">do_something</span>((str));
    });
    
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name : svec)
    {
        cout&lt;&lt; ++count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
}
</code></pre>
<h2 id="literal-operator-functions">Literal Operator Functions</h2>
<ul>
<li>Bir tamsayı sabitini yazarken digit separator kullanılabiliyor.</li>
</ul>
<p><code>87'13821312'2132313'</code> gibi. Kullanılabiliyor. Magic numberlar ile kullanıldığın da bu kodun okunabilirliğini arttırıyor. Hangi sayı türü ile yazıldığının sabitin hangi tabanda yazıldığı ile alakası yok <code>0x1a'cff</code>.</p>
<h3 id="userdefined-literal">Userdefined Literal</h3>
<p>Dilin core sentaksı içerisinde nasıl kullanılan sabitler olduğu gibi. Biz de kendi sabitlerimizi oluşturabiliyoruz.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-number">354u</span>;
    <span class="hljs-string">&quot;alican&quot;</span>s;
}
</code></pre>
<ul>
<li>STL'in sunduğu literal operatörler.</li>
<li>Programcının kendisi de böyle fonksiyonları tanımlayabiliyor ve programcının oluşturduğu türler için de kullanılabiliyor.</li>
</ul>
<p><code>743ms</code> yazdığımızda burada bir fonksiyon çağırısı yapılıyor. Biz böyle bir ifadeyi derleyici bazı fonksiyonlar var ise bunu bir çağrı koduna değiştiriyor. Burada çağırılan free function <code>constexpr</code> bir fonksiyonda olabilir ve buradan elde edilen ifade bir compile time sabiti oluyor.</p>
<ul>
<li>Bu fonksiyonların görünür olması durumunda isimleri ile çağırabiliyoruz.</li>
</ul>
<ol>
<li>Bu fonksiyonlar keyfi olarak parametre türleri alamıyor. Parametre değişkenlerinin hangi türden olabileceğine ait sentaks kuralları var.</li>
<li>Fonksiyonun sadece parametrelerine ilişkin bir kural var geri dönüş değeri için programcıyı engelleyen bir durum yok.</li>
<li>Suffix olarak kullanılan isim fonksiyonun ismi ve programcının yazacağı custom type için <code>_&lt;isim&gt;</code> şeklinde olmalı.</li>
</ol>
<p>Bunlar 2 ayrı kategoride oluyor:</p>
<ul>
<li>
<p><strong>Cooked</strong>: Eğer bir tam sayı kullanarak ve ona son ek eklenecekse, derleyici bu ifadeyi doğrudan bir tam sayı olarak gönderiyor.
<code>312321_m</code> =&gt; <code>operator&quot;&quot;_m(unsigned long long)</code> ile türden unsigend long long paramtresine 312321 olarak gönderiliyor.</p>
</li>
<li>
<p><strong>Uncooked</strong>: Çağırılan fonksiyonun parametresi c-string ve bu yukardaki gibi bir fonksiyon ise <code>operator&quot;&quot;_m(const char *p)</code> bu fonksiyona &quot;312321&quot; olarak gönderiliyor ve artık bu yazıyı karakter karakter olarak dolaşabiliriz.</p>
</li>
<li>
<p>Tam sayı ve gerçek sayılar için cooked/uncooked yazma şansımız var.</p>
</li>
<li>
<p>Bu fonksiyonları namespace içerisinde sun.</p>
</li>
<li>
<p><strong>unsigned long long</strong>/<strong>char</strong> olmalı</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)
{
    std::cout&lt;&lt;<span class="hljs-string">&quot;operator_k -&gt;  val = &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">sqrt</span>(val));
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">843712</span>_sr;
    cout&lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">auto</span> = <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-number">843712</span>); <span class="hljs-comment">//şeklinde de çağırılabilir.</span>
}
</code></pre>
<ul>
<li><strong>uncooked</strong> olarak bu fonksiyon yazılsaydı:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_sr(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)
{
    std::cout&lt;&lt;<span class="hljs-string">&quot;operator_k -&gt;  val = &quot;</span> &lt;&lt; std::<span class="hljs-built_in">strlen</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">while</span>(*p)
    {
        std::cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)*p&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        ++p;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> val = <span class="hljs-number">823.3232</span>_sr
}
</code></pre>
<p>Öyle bir son ek olsunki 2'lik sayı sisteminde bir sayıya denk gelsin</p>
<pre><code class="language-c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span>_b2(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)
{
    <span class="hljs-type">int</span> val{};
    <span class="hljs-keyword">while</span>(*p)
    {
        <span class="hljs-keyword">if</span>(*p == <span class="hljs-string">&#x27;0&#x27;</span>|| *p == <span class="hljs-string">&#x27;1&#x27;</span>)
            val = val * <span class="hljs-number">2</span> + (*p - <span class="hljs-string">&#x27;0&#x27;</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">throw</span> std::invalid_argument{<span class="hljs-string">&quot;invalid binary digit&quot;</span>};
        ++p;
    }
    <span class="hljs-keyword">return</span> val;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> val = <span class="hljs-number">101011101</span>_b2;
}
</code></pre>
<ul>
<li>Gerçek sayı sabiti içinse <code>long double val</code> türden bir değişken olmak zorunda.</li>
</ul>
</div>
        </div>
            
            
        </body>
        </html>