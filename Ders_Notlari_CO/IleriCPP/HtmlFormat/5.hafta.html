<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>5&period;Hafta</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension bierner.markdown-preview-github-styles */
html,
body,
.github-markdown-body {
    padding: 0 !important;
    max-width: auto !important;
}

.github-markdown-body {
    background-color: var(--color-canvas-default);
    color: var(--color-fg-default);
}

.github-markdown-body {
    border: 1px solid transparent;
    box-sizing: border-box;
    margin: 0 auto;
    width: 100% !important;
}

.github-markdown-content {
    padding: 32px !important;
    max-width: 980px;
    min-width: 200px;
    margin: 0 auto;
}


.vscode-body.scrollBeyondLastLine {
    margin-bottom: 0;
}
.vscode-body.scrollBeyondLastLine .github-markdown-body {
    padding-bottom: calc(100vh + 10px) !important;
}

.github-markdown-body blockquote {
    background-color: initial;
}

.github-markdown-body pre {
    color: initial;
    border: none;
}

.github-markdown-body code {
    color: inherit;
}

.github-markdown-body pre code {
    color: initial;
}

.github-markdown-body code > div {
    background: none
}

.github-markdown-body.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

.vscode-dark.showEditorSelection .code-line:hover:before {
    border-left: 3px solid var(--color-fg-default);
}
.github-markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-default, var(--color-canvas-default));
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.github-markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.github-markdown-body h1:hover .anchor .octicon-link:before,
.github-markdown-body h2:hover .anchor .octicon-link:before,
.github-markdown-body h3:hover .anchor .octicon-link:before,
.github-markdown-body h4:hover .anchor .octicon-link:before,
.github-markdown-body h5:hover .anchor .octicon-link:before,
.github-markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.github-markdown-body details,
.github-markdown-body figcaption,
.github-markdown-body figure {
  display: block;
}

.github-markdown-body summary {
  display: list-item;
}

.github-markdown-body [hidden] {
  display: none !important;
}

.github-markdown-body a {
  background-color: transparent;
  color: var(--fgColor-accent, var(--color-accent-fg));
  text-decoration: none;
}

.github-markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.github-markdown-body b,
.github-markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dfn {
  font-style: italic;
}

.github-markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body mark {
  background-color: var(--bgColor-attention-muted, var(--color-attention-subtle));
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body small {
  font-size: 90%;
}

.github-markdown-body sub,
.github-markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.github-markdown-body sub {
  bottom: -0.25em;
}

.github-markdown-body sup {
  top: -0.5em;
}

.github-markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--bgColor-default, var(--color-canvas-default));
}

.github-markdown-body code,
.github-markdown-body kbd,
.github-markdown-body pre,
.github-markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.github-markdown-body figure {
  margin: 1em 40px;
}

.github-markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--borderColor-default, var(--color-border-default));
  border: 0;
}

.github-markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.github-markdown-body [type=button],
.github-markdown-body [type=reset],
.github-markdown-body [type=submit] {
  -webkit-appearance: button;
}

.github-markdown-body [type=checkbox],
.github-markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.github-markdown-body [type=number]::-webkit-inner-spin-button,
.github-markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.github-markdown-body [type=search]::-webkit-search-cancel-button,
.github-markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.github-markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.github-markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.github-markdown-body a:hover {
  text-decoration: underline;
}

.github-markdown-body ::placeholder {
  color: var(--fgColor-muted, var(--color-fg-subtle));
  opacity: 1;
}

.github-markdown-body hr::before {
  display: table;
  content: "";
}

.github-markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.github-markdown-body td,
.github-markdown-body th {
  padding: 0;
}

.github-markdown-body details summary {
  cursor: pointer;
}

.github-markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.github-markdown-body a:focus,
.github-markdown-body [role=button]:focus,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:focus:not(:focus-visible),
.github-markdown-body [role=button]:focus:not(:focus-visible),
.github-markdown-body input[type=radio]:focus:not(:focus-visible),
.github-markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.github-markdown-body a:focus-visible,
.github-markdown-body [role=button]:focus-visible,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:not([class]):focus,
.github-markdown-body a:not([class]):focus-visible,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.github-markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border: solid 1px var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-bottom-color: var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--borderColor-neutral-muted, var(--color-neutral-muted));
}

.github-markdown-body h1,
.github-markdown-body h2,
.github-markdown-body h3,
.github-markdown-body h4,
.github-markdown-body h5,
.github-markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.github-markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.github-markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.github-markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.github-markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--fgColor-muted, var(--color-fg-muted));
}

.github-markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.github-markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-left: .25em solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body ul,
.github-markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.github-markdown-body ol ol,
.github-markdown-body ul ol {
  list-style-type: lower-roman;
}

.github-markdown-body ul ul ol,
.github-markdown-body ul ol ol,
.github-markdown-body ol ul ol,
.github-markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.github-markdown-body dd {
  margin-left: 0;
}

.github-markdown-body tt,
.github-markdown-body code,
.github-markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.github-markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.github-markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.github-markdown-body input::-webkit-outer-spin-button,
.github-markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.github-markdown-body::before {
  display: table;
  content: "";
}

.github-markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body>*:first-child {
  margin-top: 0 !important;
}

.github-markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.github-markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.github-markdown-body .absent {
  color: var(--fgColor-danger, var(--color-danger-fg));
}

.github-markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.github-markdown-body .anchor:focus {
  outline: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre,
.github-markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.github-markdown-body blockquote>:first-child {
  margin-top: 0;
}

.github-markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.github-markdown-body h1 .octicon-link,
.github-markdown-body h2 .octicon-link,
.github-markdown-body h3 .octicon-link,
.github-markdown-body h4 .octicon-link,
.github-markdown-body h5 .octicon-link,
.github-markdown-body h6 .octicon-link {
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  visibility: hidden;
}

.github-markdown-body h1:hover .anchor,
.github-markdown-body h2:hover .anchor,
.github-markdown-body h3:hover .anchor,
.github-markdown-body h4:hover .anchor,
.github-markdown-body h5:hover .anchor,
.github-markdown-body h6:hover .anchor {
  text-decoration: none;
}

.github-markdown-body h1:hover .anchor .octicon-link,
.github-markdown-body h2:hover .anchor .octicon-link,
.github-markdown-body h3:hover .anchor .octicon-link,
.github-markdown-body h4:hover .anchor .octicon-link,
.github-markdown-body h5:hover .anchor .octicon-link,
.github-markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.github-markdown-body h1 tt,
.github-markdown-body h1 code,
.github-markdown-body h2 tt,
.github-markdown-body h2 code,
.github-markdown-body h3 tt,
.github-markdown-body h3 code,
.github-markdown-body h4 tt,
.github-markdown-body h4 code,
.github-markdown-body h5 tt,
.github-markdown-body h5 code,
.github-markdown-body h6 tt,
.github-markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2,
.github-markdown-body summary h3,
.github-markdown-body summary h4,
.github-markdown-body summary h5,
.github-markdown-body summary h6 {
  display: inline-block;
}

.github-markdown-body summary h1 .anchor,
.github-markdown-body summary h2 .anchor,
.github-markdown-body summary h3 .anchor,
.github-markdown-body summary h4 .anchor,
.github-markdown-body summary h5 .anchor,
.github-markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.github-markdown-body ul.no-list,
.github-markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.github-markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.github-markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.github-markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.github-markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.github-markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.github-markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.github-markdown-body ul ul,
.github-markdown-body ul ol,
.github-markdown-body ol ol,
.github-markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.github-markdown-body li>p {
  margin-top: 16px;
}

.github-markdown-body li+li {
  margin-top: .25em;
}

.github-markdown-body dl {
  padding: 0;
}

.github-markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.github-markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body table th,
.github-markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body table td>:last-child {
  margin-bottom: 0;
}

.github-markdown-body table tr {
  background-color: var(--bgColor-default, var(--color-canvas-default));
  border-top: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body table tr:nth-child(2n) {
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
}

.github-markdown-body table img {
  background-color: transparent;
}

.github-markdown-body img[align=right] {
  padding-left: 20px;
}

.github-markdown-body img[align=left] {
  padding-right: 20px;
}

.github-markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.github-markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.github-markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body span.frame span img {
  display: block;
  float: left;
}

.github-markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.github-markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.github-markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.github-markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-left span {
  margin: 13px 0 0;
}

.github-markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body code,
.github-markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
}

.github-markdown-body code br,
.github-markdown-body tt br {
  display: none;
}

.github-markdown-body del code {
  text-decoration: inherit;
}

.github-markdown-body samp {
  font-size: 85%;
}

.github-markdown-body pre code {
  font-size: 100%;
}

.github-markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.github-markdown-body .highlight {
  margin-bottom: 16px;
}

.github-markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.github-markdown-body .highlight pre,
.github-markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border-radius: 6px;
}

.github-markdown-body pre code,
.github-markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.github-markdown-body .csv-data td,
.github-markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.github-markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--bgColor-default, var(--color-canvas-default));
  border: 0;
}

.github-markdown-body .csv-data tr {
  border-top: 0;
}

.github-markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--bgColor-muted, var(--color-canvas-subtle));
  border-top: 0;
}

.github-markdown-body [data-footnote-ref]::before {
  content: "[";
}

.github-markdown-body [data-footnote-ref]::after {
  content: "]";
}

.github-markdown-body .footnotes {
  font-size: 12px;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-top: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body .footnotes ol {
  padding-left: 16px;
}

.github-markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.github-markdown-body .footnotes li {
  position: relative;
}

.github-markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--borderColor-accent-emphasis, var(--color-accent-emphasis));
  border-radius: 6px;
}

.github-markdown-body .footnotes li:target {
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.github-markdown-body [popover] {
  background-color: canvas;
  border: initial solid;
  border-color: initial;
  border-image: initial;
  color: initial;
  height: fit-content;
  inset: 0;
  margin: auto;
  overflow: auto;
  padding: .25em;
  position: fixed;
  width: fit-content;
  z-index: 2147483647;
}

.github-markdown-body [popover]:not(.\:popover-open) {
  display: none;
}

.github-markdown-body [popover]:is(dialog[open]) {
  display: revert;
}

.github-markdown-body [anchor].\:popover-open {
  inset: auto;
}

.github-markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.github-markdown-body .pl-c1,
.github-markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body .pl-e,
.github-markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .pl-smi,
.github-markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.github-markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.github-markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.github-markdown-body .pl-s,
.github-markdown-body .pl-pds,
.github-markdown-body .pl-s .pl-pse .pl-s1,
.github-markdown-body .pl-sr,
.github-markdown-body .pl-sr .pl-cce,
.github-markdown-body .pl-sr .pl-sre,
.github-markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.github-markdown-body .pl-v,
.github-markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.github-markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.github-markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.github-markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.github-markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.github-markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.github-markdown-body .pl-mh,
.github-markdown-body .pl-mh .pl-en,
.github-markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.github-markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.github-markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.github-markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.github-markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.github-markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.github-markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.github-markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.github-markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.github-markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.github-markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.github-markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.github-markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.github-markdown-body .task-list-item {
  list-style-type: none;
}

.github-markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.github-markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.github-markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.github-markdown-body .task-list-item .handle {
  display: none;
}

.github-markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.github-markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.github-markdown-body .contains-task-list {
  position: relative;
}

.github-markdown-body .contains-task-list:hover .task-list-item-convert-container,
.github-markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.github-markdown-body .QueryBuilder .qb-entity {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .QueryBuilder .qb-constant {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
[data-color-mode=light][data-light-theme=light],
[data-color-mode=dark][data-dark-theme=light],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=light_colorblind],
[data-color-mode=dark][data-dark-theme=light_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

[data-color-mode=light][data-light-theme=light_tritanopia],
[data-color-mode=dark][data-dark-theme=light_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

[data-color-mode=light][data-light-theme=light_high_contrast],
[data-color-mode=dark][data-dark-theme=light_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=dark],
[data-color-mode=dark][data-dark-theme=dark],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_dimmed],
[data-color-mode=dark][data-dark-theme=dark_dimmed],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_dimmed],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

[data-color-mode=light][data-light-theme=dark_colorblind],
[data-color-mode=dark][data-dark-theme=dark_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

[data-color-mode=light][data-light-theme=dark_tritanopia],
[data-color-mode=dark][data-dark-theme=dark_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_high_contrast],
[data-color-mode=dark][data-dark-theme=dark_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

/*!
  Theme: GitHub
  Description: Highlight-js port of github.com theme
  Author: github.com
  Maintainer: @SNDST00M, @mjbvz
  Updated: 2021-12-08
*/
.markdown-body pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
}

.markdown-body code.hljs {
  padding: 3px 5px;
}

/*!
  Theme: GitHub
  Description: Theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.markdown-body .hljs {
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
}

.markdown-body .hljs-doctag,
.markdown-body .hljs-keyword,
.markdown-body .hljs-meta .hljs-keyword,
.markdown-body .hljs-template-tag,
.markdown-body .hljs-template-variable,
.markdown-body .hljs-type,
.markdown-body .hljs-variable.language_ {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .hljs-title,
.markdown-body .hljs-title.class_,
.markdown-body .hljs-title.class_.inherited__,
.markdown-body .hljs-title.function_ {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .hljs-attr,
.markdown-body .hljs-attribute,
.markdown-body .hljs-literal,
.markdown-body .hljs-meta,
.markdown-body .hljs-number,
.markdown-body .hljs-operator,
.markdown-body .hljs-selector-attr,
.markdown-body .hljs-selector-class,
.markdown-body .hljs-selector-id,
.markdown-body .hljs-variable {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-meta .hljs-string,
.markdown-body .hljs-regexp,
.markdown-body .hljs-string {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .hljs-built_in,
.markdown-body .hljs-symbol {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .hljs-code,
.markdown-body .hljs-comment,
.markdown-body .hljs-formula {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .hljs-name,
.markdown-body .hljs-quote,
.markdown-body .hljs-selector-pseudo,
.markdown-body .hljs-selector-tag {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .hljs-subst {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-section {
  color: var(--color-prettylights-syntax-markup-heading);
  font-weight: bold;
}

.markdown-body .hljs-bullet {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .hljs-emphasis {
  color: var(--color-prettylights-syntax-constant);
  font-style: italic;
}

.markdown-body .hljs-strong {
  color: var(--color-prettylights-syntax-constant);
  font-weight: bold;
}

.markdown-body .hljs-addition {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .hljs-deletion {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <div
            class="github-markdown-body"
            data-color-mode="auto"
            data-light-theme="light"
            data-dark-theme="dark"
        >
            <div class="github-markdown-content"><h1 id="5hafta">5.Hafta</h1>
<h2 id="i̇çindekiler">İçindekiler</h2>
<ul>
<li><a href="#5hafta">5.Hafta</a>
<ul>
<li><a href="#i%CC%87%C3%A7indekiler">İçindekiler</a></li>
<li><a href="#stdoptional">std::optional</a>
<ul>
<li><a href="#nesnesini-nas%C4%B1l-olu%C5%9Ftururuz">Nesnesini nasıl oluştururuz?</a></li>
<li><a href="#eri%C5%9Fmenin-yollar%C4%B1">Erişmenin yolları</a></li>
<li><a href="#in_place-ve-make_optional">In_place ve make_optional</a></li>
<li><a href="#kullan%C4%B1ld%C4%B1%C4%9F%C4%B1-temalar">Kullanıldığı Temalar</a></li>
<li><a href="#%C3%BCye-fonksiyonlar%C4%B1">Üye Fonksiyonları</a></li>
<li><a href="#ta%C5%9F%C4%B1nma-semanti%C4%9Fi">Taşınma semantiği</a></li>
</ul>
</li>
<li><a href="#stdvariant">std::variant</a>
<ul>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#hangi-alternatifin-tutuldu%C4%9Funu-%C3%B6%C4%9Frenme">Hangi alternatifin tutulduğunu öğrenme</a></li>
<li><a href="#yard%C4%B1mc%C4%B1-s%C4%B1n%C4%B1flar">Yardımcı sınıflar</a>
<ul>
<li><a href="#in_place_index_t-ve-in_place_type_t">in_place_index_t ve in_place_type_t</a></li>
</ul>
</li>
<li><a href="#sizeof">Sizeof</a></li>
<li><a href="#varianta-eri%C5%9Fme">Varianta erişme</a>
<ul>
<li><a href="#get-fonksiyonu">Get Fonksiyonu</a></li>
<li><a href="#get-if-fonksiyonu">Get-if fonksiyonu</a></li>
<li><a href="#atama-yapma-yollar%C4%B1">Atama Yapma Yolları</a></li>
<li><a href="#monostate-s%C4%B1n%C4%B1f%C4%B1">monostate sınıfı</a></li>
<li><a href="#visitor-paterni">Visitor paterni</a></li>
</ul>
</li>
<li><a href="#overloader-idiomu">Overloader Idiom'u</a></li>
<li><a href="#kullan%C4%B1m-senaryolar%C4%B1">Kullanım Senaryoları</a></li>
</ul>
</li>
<li><a href="#stdany">std::any</a>
<ul>
<li><a href="#typeid-ve-typeinfo-s%C4%B1n%C4%B1f%C4%B1">typeid ve typeinfo sınıfı</a></li>
<li><a href="#any-s%C4%B1n%C4%B1f%C4%B1-devam">any sınıfı devam</a></li>
<li><a href="#tuttu%C4%9Fu-t%C3%BCre-eri%C5%9Fme">Tuttuğu Türe erişme</a></li>
<li><a href="#tuttu%C4%9Fu-de%C4%9Fere-eri%C5%9Fme">Tuttuğu değere erişme</a></li>
<li><a href="#any-%C3%BCye-fonksiyonlar%C4%B1">Any Üye Fonksiyonları</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>08_22_07_2023</p>
</blockquote>
<hr>
<h2 id="stdoptional">std::optional</h2>
<ul>
<li>It is recommended to use <code>optional&lt;T&gt;</code> sin situations where theere is exactly one, clear ( to all parties) reason for having no value of type T, and where the lack of a value is as natural as having any regular value of type T.</li>
</ul>
<h3 id="nesnesini-nasıl-oluştururuz">Nesnesini nasıl oluştururuz?</h3>
<ul>
<li>Default initialize edilmiş bir <code>optional</code> nesnesi, <code>std::nullopt</code> durumunda. Default construct edilmiş nesnesi default contsrukt edilmiş bir <code>T</code> türünden nesnesine sahip değil.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    std::optional&lt;<span class="hljs-type">int</span>&gt; opt; <span class="hljs-comment">// default initialize edilmiş bir nesne</span>
    <span class="hljs-built_in">boolalpha</span>(cout);
    cout &lt;&lt; boolalpha;
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    
    <span class="hljs-keyword">if</span>(op) { cout &lt;&lt; <span class="hljs-string">&quot;bir deger var\n&quot;</span>; }
    <span class="hljs-keyword">else</span> { cout &lt;&lt; <span class="hljs-string">&quot;deger yok\n&quot;</span>; }
    cout &lt;&lt; ( op == <span class="hljs-literal">nullopt</span>)&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; 
}
</code></pre>
<h3 id="erişmenin-yolları">Erişmenin yolları</h3>
<ul>
<li>Tipik bir sarmalıyıcı olduğu için doğrudan değiştirilecek bir nesne de kullanabiliriz.</li>
<li>
<ul>
<li>Eğer boş bir optional nesnesine erişmeye çalışırsak, undefined behavior oluşur.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    std::optional&lt;string&gt; op{<span class="hljs-string">&quot;deneme&quot;</span>};
    cout &lt;&lt; *op&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// deneme</span>
    cout &lt;&lt; op-&gt;<span class="hljs-built_in">size</span>();
    <span class="hljs-comment">//cout &lt;&lt; *op; //Eğer boş olsaydı ub olurdu</span>
}
</code></pre>
<ul>
<li><code>op.value()</code> fonksiyonu ile de değere erişebiliriz ve bu fonksiyon çağırıldığında exception throw ediyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    std::optional&lt;string&gt; op;
    <span class="hljs-keyword">try</span> {
        cout &lt;&lt; op.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// deneme</span>
        cout &lt;&lt; op.<span class="hljs-built_in">value</span>().<span class="hljs-built_in">size</span>();
    }
    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_optional_access&amp; e) {
        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
}
</code></pre>
<ul>
<li><code>op.value_or()</code> fonksiyonu eğer optional nesnesi bir değer tutuyorsa bu değeri döndürür, eğer boş ise, parametre olarak verilen değeri döndürür.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    std::optional&lt;string&gt; op;
    cout &lt;&lt; op.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">&quot;bos&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// bos</span>
    std::optional&lt;string&gt; op2{<span class="hljs-string">&quot;deger&quot;</span>};
    cout &lt;&lt; op2.<span class="hljs-built_in">value_or</span>(<span class="hljs-string">&quot;bos&quot;</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// deger</span>
}
</code></pre>
<ul>
<li>
<p><code>value_or</code> fonksyionu <code>value</code> dan farklı olarak sol taraf referans döndürmüyor.</p>
</li>
<li>
<p>std::optional nesnesi bir referans tutamıyor fakat reference wrapper ile bunu yapabiliriz. Fabrika fonksiyonlarını kullanabiliyoruz</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string name {<span class="hljs-string">&quot;deneme&quot;</span>};
    std::optional&lt;reference_wrapper&lt;string&gt;&gt; <span class="hljs-built_in">op</span>(<span class="hljs-built_in">ref</span>(name));
    op-&gt;<span class="hljs-built_in">get</span>() +=  <span class="hljs-string">&quot;test&quot;</span>;
    <span class="hljs-comment">//CTAD</span>
    optional x = <span class="hljs-number">12</span>;
}
</code></pre>
<h3 id="in_place-ve-make_optional">In_place ve make_optional</h3>
<p>Yardımcı bir <code>in_place_t</code> nesnesi var ve bu türden bir değişkenimiz var <code>in_place</code>.</p>
<ul>
<li>Default construct edilmiş bir optional nesnesini oluşturmamız mümkün değil default olarak nesneyi construct etmiyor.</li>
<li>Eğer inplace objesi ile optional nesnesini oluşturursak, bu durumda nesne doğrudan oluşturuluyor.</li>
<li>in_place ile aldığı argümanları constructor'a parametre olarak geçiyor ve bu rargümanlar perfectforward ediliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>() {cout &lt;&lt; <span class="hljs-string">&quot;default ctor\n&quot;</span>;}
    ~<span class="hljs-built_in">Myclass</span>() {cout &lt;&lt; <span class="hljs-string">&quot;dtor\n&quot;</span>;}
    <span class="hljs-built_in">Myclass</span>( <span class="hljs-type">const</span> Myclass&amp;) {cout &lt;&lt; <span class="hljs-string">&quot;copy ctor\n&quot;</span>;}
    <span class="hljs-built_in">Myclass</span>( Myclass&amp;&amp;) {cout &lt;&lt; <span class="hljs-string">&quot;move ctor\n&quot;</span>;}
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    optional&lt;Myclass&gt; op; <span class="hljs-comment">// burada nesneyi construct etmiyor</span>
    optional&lt;Myclass&gt; op1{Myclass{}}; <span class="hljs-comment">// eğer move ctor varsaa o yoksa copy ctor çağırılıyro.</span>
    <span class="hljs-function">optional&lt;Myclass&gt; <span class="hljs-title">op</span><span class="hljs-params">(in_place)</span></span>;  <span class="hljs-comment">// doğrudan oluşturuldu</span>
    <span class="hljs-comment">// optional&lt;Date&gt; x {3,5,1987};</span>
    optional&lt;Date&gt; x {in_place, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1987</span>};
    <span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">make_optional</span>&lt;Date&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1987</span>);
    cout &lt;&lt; *x2 ;
    <span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">make_optional</span>&lt;Myclass&gt;();
    <span class="hljs-keyword">auto</span> op = std::<span class="hljs-built_in">optional</span>&lt;Myclass&gt;(in_place);
}
</code></pre>
<h3 id="kullanıldığı-temalar">Kullanıldığı Temalar</h3>
<p>Değerinin olmasının kadar olmamasının da doğal olduğu durumlar:</p>
<ul>
<li>Aramada aranan değerin olması kadar değerin olmaması gibi. Aranan değer bulunursa dolu bir optional nesnesi döndürülür, bulunmazsa boş bir optional nesnesi döndürülür.</li>
<li>Bir kişinin uygulamada nick'i olabilir/olmayabilir.</li>
<li>Fonksiyonun parametre değişkeni optional olabilir.</li>
<li>Sınıfın veri elemanı optional olabilir.</li>
<li>Karşılaştırma operatörleri ile kullanılabilir. Değerinin nullopt olup olmadığını kontrol edebiliriz.</li>
</ul>
<h3 id="üye-fonksiyonları">Üye Fonksiyonları</h3>
<ul>
<li><code>reset</code> : optional nesnesini boşaltır. Tuttuğu nesnenin destructorını çağırıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    optional&lt;string&gt; op;
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    op = <span class="hljs-string">&quot;neco&quot;</span>;
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
    op.<span class="hljs-built_in">reset</span>();
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    op =<span class="hljs-string">&quot;deneme&quot;</span>;
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
    op = <span class="hljs-literal">nullopt</span>;
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    op =<span class="hljs-string">&quot;deneme&quot;</span>;
    <span class="hljs-comment">//idiomatik</span>
    op = {};
    cout &lt;&lt; op.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
}
</code></pre>
<ul>
<li><code>swap</code> : iki optional nesnesinin değerlerini değiştirir.</li>
<li><code>emplace</code> : optional nesnesini doğrudan oluşturur. Eğer nesne dolu ise, mevcut nesneyi destroy eder ve yeni nesneyi oluşturur.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    usgin <span class="hljs-keyword">namespace</span> std;
    optional&lt;Myclass&gt;op;
    op.<span class="hljs-built_in">emplace</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;Main devam ediyor&quot;</span>;
    op.<span class="hljs-built_in">emplace</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;Main devam ediyor&quot;</span>;
}
</code></pre>
<ul>
<li>
<p><code>has_value</code> : optional nesnesinin değerinin olup olmadığını kontrol eder.</p>
</li>
<li>
<p><code>operator bool</code> : optional nesnesinin değerinin olup olmadığını kontrol eder.</p>
</li>
<li>
<p><code>operator*</code> : optional nesnesinin değerine erişir.</p>
</li>
<li>
<p><code>operator-&gt;</code> : optional nesnesinin değerine erişir.</p>
</li>
<li>
<p><code>value</code> : optional nesnesinin değerine erişir. Eğer değer yoksa exception throw eder.</p>
</li>
<li>
<p><code>value_or</code> : optional nesnesinin değerine erişir. Eğer değer yoksa parametre olarak verilen değeri döndürür.</p>
</li>
<li>
<p>Boş optional nesnesi karşılaştırıldığı zaman</p>
</li>
<li>
<p>nullopt nesnesi en küçük.</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    optional x = <span class="hljs-string">&quot;deneme&quot;</span>s;
    optional&lt;string&gt; y;

    cout &lt;&lt; (x == y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt; (y &lt; x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
    x.<span class="hljs-built_in">reset</span>();
    cout &lt;&lt; (x == y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
}
</code></pre>
<ul>
<li>bool açılımı.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    optional&lt;<span class="hljs-type">bool</span>&gt; x;
    optional&lt;<span class="hljs-type">bool</span>&gt; y{<span class="hljs-literal">true</span>};
    optional&lt;<span class="hljs-type">bool</span>&gt; z{<span class="hljs-literal">false</span>};

    cout &lt;&lt; boolalpha&lt;&lt; (x == y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt; (y &lt; z) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt;  (x == z) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
}
</code></pre>
<ul>
<li>std::optional nesnesi return eden fonksiyonlar için</li>
</ul>
<pre><code class="language-c++">
<span class="hljs-function">std::optional&lt;string&gt; <span class="hljs-title">get_name</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>
</span>{
    std::optional&lt;string&gt; name;
    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">has_nic</span>(id))
        name = <span class="hljs-string">&quot;deneme&quot;</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">//return {};</span>
        <span class="hljs-comment">//return std::optional&lt;string&gt;{};</span>
    <span class="hljs-comment">//return name;</span>
}

<span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()
{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

    <span class="hljs-keyword">if</span>(optinal&lt;string&gt; name = <span class="hljs-built_in">get_name</span>(<span class="hljs-number">12</span>))
        cout &lt;&lt; *name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">else</span>
        cout &lt;&lt; <span class="hljs-string">&quot;isim yok\n&quot;</span>;

    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">get_name</span>(<span class="hljs-number">12</span>); op)
        cout &lt;&lt; *op &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">else</span>
        cout &lt;&lt; <span class="hljs-string">&quot;isim yok\n&quot;</span>;

    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">get_name</span>(<span class="hljs-number">12</span>))
        cout &lt;&lt; *op &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">else</span>
        cout &lt;&lt; <span class="hljs-string">&quot;isim yok\n&quot;</span>;

<span class="hljs-comment">//alternatif olarak böyle de yazılabilir.</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> op = <span class="hljs-built_in">get_name</span>(<span class="hljs-number">13</span>); op-&gt;<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span>)
        cout &lt;&lt; *op &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">else</span>
        cout &lt;&lt; <span class="hljs-string">&quot;isim yok\n&quot;</span>;
}
</code></pre>
<ul>
<li>Aşağıdaki kod içerisinde, verilen container'da bulunan ilk öğenin konumunu döndüren bir fonksiyon.</li>
<li>Burada stl'den farklı olarak range almak yerine container ve predict yapıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Con, <span class="hljs-keyword">typename</span> Pred&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">find_if</span><span class="hljs-params">(Con&amp;&amp; con, Pred&amp;&amp; pred)</span>
</span>{
    <span class="hljs-keyword">using</span> std::begin, std::end;
    <span class="hljs-keyword">auto</span> beg_iter = <span class="hljs-built_in">begin</span>(c), end_iter = <span class="hljs-built_in">end</span>(c);
    <span class="hljs-keyword">auto</span> result = std::<span class="hljs-built_in">find_if</span>(beg_iter, end_iter, pred);
    <span class="hljs-keyword">using</span> iterator = <span class="hljs-keyword">decltype</span>(result);
    <span class="hljs-keyword">if</span>(result == end_iter)
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">optional</span>&lt;iterator&gt;();
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">optional</span>&lt;iterator&gt;(result);
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Con, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">find</span><span class="hljs-params">(Con&amp;&amp; c, <span class="hljs-type">const</span> T&amp; value)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_if</span>(std::forward&lt;Con&gt;(c), [&amp;ival](<span class="hljs-keyword">auto</span>&amp;&amp; x) { <span class="hljs-keyword">return</span> x == value; });
}
</code></pre>
<ul>
<li>aldıpi string'i int değere dönüştürecek ve inte dönüştürülemez ise değer döndürülmeyecek.</li>
</ul>
<pre><code class="language-c++">
<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">to_int</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span>
</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(s);
    }
    <span class="hljs-built_in">catch</span>(...) {
        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;
    }
}

<span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">to_int</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span>
</span>{
    std::optional&lt;<span class="hljs-type">int</span>&gt; ret;
    <span class="hljs-keyword">try</span>{
        ret = std::<span class="hljs-built_in">atoi</span>(s);
    }
    <span class="hljs-built_in">catch</span>(...){}

    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : {<span class="hljs-string">&quot;42&quot;</span>,<span class="hljs-string">&quot;077&quot;</span>,<span class="hljs-string">&quot;necati&quot;</span>,<span class="hljs-string">&quot;0x33&quot;</span>}) <span class="hljs-comment">// initializer list sınıfı</span>
    {
        std::optional&lt;<span class="hljs-type">int</span>&gt; op = <span class="hljs-built_in">to_int</span>(s);
        <span class="hljs-keyword">if</span>(op)
            std::cout &lt;&lt; *op &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        <span class="hljs-keyword">else</span>
            std::cout &lt;&lt; <span class="hljs-string">&quot;gecersiz\n&quot;</span>;
    }
}
</code></pre>
<h3 id="taşınma-semantiği">Taşınma semantiği</h3>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::optional&lt;std::string&gt; op1{<span class="hljs-string">&quot;deneme&quot;</span>};
    <span class="hljs-keyword">auto</span> op2 = op1; <span class="hljs-comment">//copy-semantics</span>
    cout &lt;&lt; op1-&gt;<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 6</span>
    <span class="hljs-keyword">auto</span> op3 = std::<span class="hljs-built_in">move</span>(op1); <span class="hljs-comment">//move-semantics</span>
    cout &lt;&lt; op1-&gt;<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// op1 moved from state&#x27;de</span>
}
</code></pre>
<ul>
<li>Allignment ile alakalı problem oluşturabiliyor. Allign storage kullanıldığı için</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    cout &lt;&lt;  <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 8</span>
    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(std::optional&lt;<span class="hljs-type">double</span>&gt;) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 16</span>
}
</code></pre>
<h2 id="stdvariant">std::variant</h2>
<p>Optional ya bir değer tutuyor ya da tutmuyor. Variant ise önceden saptanmış türlerden birini tutuyor. C'deki <code>union</code> türüne benzer olarak düşünülebilir. Value semantics'e de uygun oluyor.</p>
<ul>
<li>Template argümanları olan türlerden birinden değer tutuyor. Bu türlere alternatif deniyor.</li>
<li>Başlık dosyası <code>&lt;variant&gt;</code></li>
<li><code>std::monostate</code> ile nullable type (boş ) bir tür oluşturulabilir.</li>
</ul>
<pre><code class="language-c++">temaplate&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Variant</span>
{};

<span class="hljs-function">itn <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,std::string&gt;
}
</code></pre>
<blockquote>
<p>union'ları low-level kodlar dışında çok fazla kullanmamaya çalış. Birlik nesnesi hangi alternatifi tuttuğunu bilemez.</p>
</blockquote>
<ul>
<li>Burada union yerine variatn türünü kullanırsak hangi türü tuttuğunu bilecek.</li>
<li>Kaynak sızıntısına bir neden yaratmıyor.</li>
</ul>
<blockquote>
<p>Bu tür sınıflara <strong>tagged/discriminated union</strong> da deniyor.</p>
</blockquote>
<ul>
<li>Variant türü kendi içerisinde tutuyor dynamic memory allocation tutmuyor ve bu da en az en büyük boyuta sahip türe sahip olan türün boyutu kadar bir yer tutması anlamına geliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v;    
}
</code></pre>
<h3 id="constructor">Constructor</h3>
<ul>
<li>
<p>Default edilmiş bir variant nesnesi ilk alternatifi tutuyor. O de value initialize edildiği için bu variant default initialize edilebilir değilse bir sentaks hatası oluşmasına sebep olabilir.</p>
</li>
<li>
<p>Alternatiflerden birine dönüştürülecek türden bir argümanla construct edilebilir.</p>
</li>
<li>
<ul>
<li>Burada bir ambiguity oluşabilir. Eğer birden fazla alternatiften biri seçilebilir olduğunda ambiguity oluşabilir. Function overload resolution kurallarına göre seçim yapılabilir.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12</span>}; <span class="hljs-comment">// int</span>
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">3.4f</span>}; <span class="hljs-comment">// double</span>
}
</code></pre>
<h3 id="hangi-alternatifin-tutulduğunu-öğrenme">Hangi alternatifin tutulduğunu öğrenme</h3>
<ul>
<li><em>const</em> üye fonksiyonu olan indexi çağırarak hangi alternatifin tutulduğunu öğrenebiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12</span>}; <span class="hljs-comment">// int</span>
    cout &lt;&lt; v.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 0</span>
    v = <span class="hljs-number">3.4f</span>;
    cout &lt;&lt; v.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1</span>
}
</code></pre>
<ul>
<li>holds_alternative fonksiyon şablonunu çağırmak bu fonksiyon bize bool değer döndürüyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12</span>}; <span class="hljs-comment">// int</span>
    cout &lt;&lt; boolalpha &lt;&lt;<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
    cout &lt;&lt; <span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">double</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt; <span class="hljs-built_in">holds_alternative</span>&lt;string&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    v = <span class="hljs-number">3.4f</span>;
    cout &lt;&lt; <span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt; <span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">double</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// true</span>
    cout &lt;&lt; <span class="hljs-built_in">holds_alternative</span>&lt;string&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
}
</code></pre>
<ul>
<li>Bazı kontroller compile time içerisinde yapılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12</span>}; <span class="hljs-comment">// int</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">char</span>&gt;(v)) <span class="hljs-comment">// compile time hatası</span>
        cout &lt;&lt; <span class="hljs-string">&quot;char\n&quot;</span>;
}
</code></pre>
<h3 id="yardımcı-sınıflar">Yardımcı sınıflar</h3>
<h4 id="in_place_index_t-ve-in_place_type_t">in_place_index_t ve in_place_type_t</h4>
<ul>
<li>bunlar constexpr variable'lar. Bunlarda variant nesnesinin kullanıldığı alternatifi seçmek için kullanılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{in_place_index&lt;<span class="hljs-number">0</span>&gt;, <span class="hljs-number">12</span>}; <span class="hljs-comment">// int</span>
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{in_place_index&lt;<span class="hljs-number">1</span>&gt;, <span class="hljs-number">3.4f</span>}; <span class="hljs-comment">// double</span>
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{in_place_index&lt;<span class="hljs-number">2</span>&gt;, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>}; <span class="hljs-comment">// string</span>
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{in_place_type&lt;<span class="hljs-type">double</span>&gt;, <span class="hljs-number">3.4f</span>}; <span class="hljs-comment">// double</span>
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{in_place_type&lt;string&gt;, <span class="hljs-number">10</span>,A}; <span class="hljs-comment">// string</span>
}
</code></pre>
<ul>
<li>Böylece verilen değerler perfect forward ediliyor.</li>
<li>Eğer default construct etmek istiyorsak kullanılabilir.</li>
<li>Eğer variantın tuttuğu türlerden birinin constructor'u birden fazla argüman alıyorsa, bunu çağırmak için kullanılabilir.</li>
<li>Eğer bir ambiguitiy oluşmasını engellmek istiyorsak kullanılabilir.</li>
<li>Eğer birden fazla tür birbiri ile aynı ise. Bu durumda bunu belirtmek için kullanılabiliriz.</li>
</ul>
<h3 id="sizeof">Sizeof</h3>
<ul>
<li>Variant türü, alternatiflerden en büyük boyuta sahip olan türün boyutu kadar yer tutar.</li>
<li>Small buffer optimization yapmıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    cout &lt;&lt; <span class="hljs-string">&quot; int&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 4</span>
    cout &lt;&lt;<span class="hljs-string">&quot; double&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 8</span>
    cout &lt;&lt; <span class="hljs-string">&quot; string&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(string) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 32</span>
    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt;) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 24</span>
}
</code></pre>
<h3 id="varianta-erişme">Varianta erişme</h3>
<h4 id="get-fonksiyonu">Get Fonksiyonu</h4>
<ul>
<li><code>get</code> fonksiyonu ile variant nesnesinin tuttuğu türün değerine erişebiliriz. Eğer tutmadığı bir değere erişmeye çalışırsak, bir exception throw ediyor. Tanımsız bir davranış yok.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12.3</span>}; <span class="hljs-comment">// int</span>
<span class="hljs-keyword">try</span> {
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 12</span>
}
<span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_variant_access&amp; e) {
    std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
}
}
</code></pre>
<ul>
<li>Burada verilen index eğer yok ise compile time'da sentaks hatası veriyor.</li>
<li>Index ile erişmek dışında tür ile erişmek için get fonksiyonu kullanılabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12.3</span>}; <span class="hljs-comment">// int</span>
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 12</span>
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-type">double</span>&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 12.3</span>
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;string&gt;(v) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// exception</span>
}
</code></pre>
<h4 id="get-if-fonksiyonu">Get-if fonksiyonu</h4>
<ul>
<li>Exception throw etmiyor ve pointer semantiği ile kullanılıyor. Eğer doğru olmayan alternatif seçilmişse nullptr döndürüyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v{<span class="hljs-number">12.3</span>}; <span class="hljs-comment">// int</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;v)) <span class="hljs-comment">// p nin türü int * </span>
        cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 12</span>
    <span class="hljs-keyword">else</span>
        cout &lt;&lt; <span class="hljs-string">&quot;int değil\n&quot;</span>;
}
</code></pre>
<ul>
<li>Bu şekilde aşağıdaki gibi bir kolaylık sağlıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;mustafa&quot;</span>)</span></span>;
    <span class="hljs-keyword">if</span> (vx.<span class="hljs-built_in">index</span>() == <span class="hljs-number">2</span>) 
    {
        std::cout « <span class="hljs-string">&quot;alternative string : &quot;</span> « <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(vx) &lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">holds_alternative</span>&lt;string&gt;(vx)) 
    {
        std::cout « <span class="hljs-string">&quot;alternative string : &quot;</span> « <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(vx) « <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sptr = get_if&lt;string&gt;)
    {
        std::cout « <span class="hljs-string">&quot;alternative string : &quot;</span> « *sptr « <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
}
</code></pre>
<ul>
<li>if-else merdiveni kullanarak buradan variantın elde ettiği değer elde edilebilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;mustafa&quot;</span>)</span></span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sptr = <span class="hljs-built_in">get_if</span>&lt;string&gt;(&amp;vx))
    {
        std::cout « <span class="hljs-string">&quot;alternative string : &quot;</span> « *sptr « <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> dptr = <span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">double</span>&gt;(&amp;vx))
    {
        std::cout « <span class="hljs-string">&quot;alternative double : &quot;</span> « *dptr « <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> iptr = <span class="hljs-built_in">get_if</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;vx))
    {
        std::cout « <span class="hljs-string">&quot;alternative int : &quot;</span> « *iptr « <span class="hljs-string">&#x27;\n&#x27;</span>;
    }

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">holds_alternative</span>&lt;string&gt;(vx))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative string : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;string&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">double</span>&gt;(vx))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative double : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-type">double</span>&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">int</span>&gt;(vx))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative int : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }

    <span class="hljs-keyword">if</span>(vx.<span class="hljs-built_in">index</span>() == <span class="hljs-number">2</span>)
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative string : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vx.<span class="hljs-built_in">index</span>() == <span class="hljs-number">1</span>)
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative double : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vx.<span class="hljs-built_in">index</span>() == <span class="hljs-number">0</span>)
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;alternative int : &quot;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(vx) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }   
}
</code></pre>
<ul>
<li>Bazı durumlarda C++ yeni standartlar ile backward-compatibility kırılabiliyor. Aşağıdaki kodda C++17'de bool seçilirken, c++20'de string seçiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">bool</span>, string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;mustafa&quot;</span>)</span></span>;
    cout &lt;&lt; vx.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 1 fakat eğer bu kod C++17 olsaydı bool </span>
}
</code></pre>
<ul>
<li>Kodun daha kolay okunabilmesi için aşağıdaki gibi bir kod yazılabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">idx</span> : <span class="hljs-type">size_t</span> {age,wage,name};
    <span class="hljs-keyword">using</span> Age = <span class="hljs-type">int</span>;
    <span class="hljs-keyword">using</span> Wage = <span class="hljs-type">double</span>;
    <span class="hljs-keyword">using</span> Name = string;
    <span class="hljs-function">variant&lt;Age,Wage,Name&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;test&quot;</span>)</span></span>; <span class="hljs-comment">// ayni ya int ya double ya da string</span>
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;age&gt;(vx);
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;Age&gt;(vx);
}
</code></pre>
<h4 id="atama-yapma-yolları">Atama Yapma Yolları</h4>
<p>Doğrudan variant türüne ambiguity oluşturmadan dönüştürülecek bir değer ile atama yapabiliyoruz.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v; <span class="hljs-comment">// int</span>
    v = <span class="hljs-number">12</span>; <span class="hljs-comment">// int</span>
    v = <span class="hljs-number">3.4f</span>; <span class="hljs-comment">// double</span>
    v = <span class="hljs-string">&quot;neco&quot;</span>; <span class="hljs-comment">// string</span>
    v = <span class="hljs-built_in">string</span>(<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;a&#x27;</span>);
}
</code></pre>
<ul>
<li>Emplace fonskiyonu ile variant nesnesinin tuttuğu türden bir atama yapabiliriz. Eski değeri destroy eder ve yeni değer oluşturuyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; v; <span class="hljs-comment">// int</span>
    v.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">12</span>); <span class="hljs-comment">// int</span>
    v.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">3.4f</span>); <span class="hljs-comment">// double</span>
    v.<span class="hljs-built_in">emplace</span>&lt;string&gt;(<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// string</span>
}
</code></pre>
<h4 id="monostate-sınıfı">monostate sınıfı</h4>
<p>Variant başlık dosyasında std::monostate isimli bir sınıf var ve bu bir örüntü, buradaki tüm alternatifler tek bir değere sahip. Bize iki avantaj sağlıyor.</p>
<ul>
<li>Tek bir state'e sahip olduğu için karşılaştırma işlemlerinde variantın boş olması anlamına geliyor.</li>
<li>Varaintların kullanıldığı bazı türler için default constructor olmuyor bu durumda monostate kullanılıyor.</li>
</ul>
<p>Tipik olarak variant ilk alternatif yapılıyor.</p>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> {<span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>) {}};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> {<span class="hljs-built_in">B</span>(<span class="hljs-type">int</span>) {}};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> namespcae std;
    <span class="hljs-comment">//variant&lt;B,A&gt; vx; bu durudma sentaks hatası oluyor ve bunun yerine</span>
    variant&lt;monostate, A, B&gt; vx; <span class="hljs-comment">//</span>
}
</code></pre>
<ul>
<li>Eğer monostate durumuna çekmek istersek:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;monostate,<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-number">4.5</span>)</span></span>;
    vx ={};
    vx = monostate{};
    vx.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">0</span>&gt;();
    vx.emplace&lt;monostate&gt;{};
}
</code></pre>
<h4 id="visitor-paterni">Visitor paterni</h4>
<ul>
<li>Variantlar için en sık yapılan işlem alternatife erişmek ve alternatif üzerinde işlem yapmak. Bu fonksiyon variadic bir fonksiyon şablonu ve bu fonksiyon bir veya birden fazla variantlar üzerinde işlem yapabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Visitor, <span class="hljs-keyword">class</span> Variants&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-title">visit</span><span class="hljs-params">(Visitor&amp;&amp;vis, Variants)</span>
</span></code></pre>
<ul>
<li>Visit fonksiyonu variantın seçimini kendisi yapıcak. Burada verilen callable için verilen functor classın tüm variantlar için çağırıalbilir olması gerekiyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrintVisitor</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-type">const</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><span class="hljs-type">const</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string x)</span><span class="hljs-type">const</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">IncrementVisitor</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span><span class="hljs-type">const</span>
    </span>{
        x++;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>&amp; x)</span><span class="hljs-type">const</span>
    </span>{
        x++;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(std::string&amp; x)</span><span class="hljs-type">const</span>
    </span>{
        x += <span class="hljs-string">&quot;x&quot;</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;deneme&quot;</span>)</span></span>;
    PrintVisitor pr;
    IncrementVisitor inc;
    <span class="hljs-comment">//visit(pr, vx);</span>
    <span class="hljs-built_in">visit</span>(PrintVisitor{}, vx);
    <span class="hljs-built_in">visit</span>(inc, vx);
    <span class="hljs-built_in">visit</span>(pr, vx);
}
</code></pre>
<ul>
<li>Visitor sınıfı aşağıdaki gibi de yapılabilirdi</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PrintVisitor</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span><span class="hljs-type">const</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        <span class="hljs-comment">/*kodu ayrı yapmak için*/</span>
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(std::is_same_v&lt;T,<span class="hljs-type">int</span>&gt;)</span>
        </span>{
            std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;T,<span class="hljs-type">double</span>&gt;)
        {
            std::cout&lt;&lt; <span class="hljs-string">&quot;double : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(std::is_same_v&lt;T,string&gt;)
        {
            std::cout&lt;&lt; <span class="hljs-string">&quot;string : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
    }
    <span class="hljs-comment">//böyle yazmak yerine</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; x)</span><span class="hljs-type">const</span>
    </span>{
        std::cout&lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};
</code></pre>
<ul>
<li>Visiter için birden fazla sınıf yazmamız mümkün.</li>
<li>Burada kullanılan sınıf functor sınıf olduğu için lambda ifadesi de kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-string">&quot;deneme&quot;</span>)</span></span>;
    <span class="hljs-built_in">visit</span>([](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x) { std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; }, vx);
}
</code></pre>
<hr>
<blockquote>
<p>09_23_07_2023</p>
</blockquote>
<hr>
<ul>
<li>Birden fazla variant nesnesi üzerinde işlem yapmak için vereceğimiz callable'un 2 argümanı olabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DenVis</span>
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U &gt;
    <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> U&amp; y)</span><span class="hljs-type">const</span>
    </span>{
        <span class="hljs-comment">//std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;</span>
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(U).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> 
        &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-comment">//bunun yerine C++20 ile gelen abbreviated function template kullanılabilir.</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y)</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(U).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> 
        &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ayri</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">const</span> std::string&amp;)</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;double string\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">(std::string, <span class="hljs-type">int</span>)</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;string int\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">int</span>)</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;double int\n&quot;</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;)</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;other -types\n&quot;</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vx</span><span class="hljs-params">(<span class="hljs-number">3.4</span>)</span></span>;
    <span class="hljs-function">variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vy</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;
    <span class="hljs-built_in">visit</span>(DenVis{}, vx, vy);
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y) { std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; };
    <span class="hljs-built_in">visit</span>(fn, vx, vy);<span class="hljs-comment">//bu da olabilir.</span>
    <span class="hljs-function">variant&lt;<span class="hljs-type">double</span>,string&gt; <span class="hljs-title">vz</span><span class="hljs-params">(<span class="hljs-number">3.4</span>)</span></span>;
    <span class="hljs-function">variant&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(<span class="hljs-string">&quot;neco&quot;</span>)</span></span>;
    <span class="hljs-built_in">visit</span>(Ayri{}, vz, vt);
}
</code></pre>
<ul>
<li>Variantı kalıtımda base class olarak kullanabiliyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Der</span> :  <span class="hljs-keyword">public</span> std::variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;
{}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    Derived d = <span class="hljs-number">12</span>;
    cout &lt;&lt; d.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 0</span>
    cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(d) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 12</span>
}
</code></pre>
<h3 id="overloader-idiomu">Overloader Idiom'u</h3>
<ul>
<li>İlk önce inharitance konusunun tekrarı</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;};
<span class="hljs-comment">//struct B : A{}; //struct B : public A{}; public yazılmasa da public oluyor.</span>
<span class="hljs-comment">//class B : A{}; //class B : private A{}; private yazılmasa da public oluyor.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Der</span> : A, B{};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    Der d;
    <span class="hljs-comment">//d.foo(12);   Sentaks hatası ambiguity olur</span>
}
</code></pre>
<p>Bunun sentaks hatası olmamasını istiyorsak sınıf içerisinde using bildirimi yapabiliriz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;};
<span class="hljs-comment">//struct B : A{}; //struct B : public A{}; public yazılmasa da public oluyor.</span>
<span class="hljs-comment">//class B : A{}; //class B : private A{}; private yazılmasa da public oluyor.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Der</span> : A, B{
    <span class="hljs-keyword">using</span> A::foo;
    <span class="hljs-keyword">using</span> B::foo;
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    Der d;
    d.<span class="hljs-built_in">foo</span>(<span class="hljs-number">12</span>); <span class="hljs-comment">// A&#x27;nın foosu int</span>
    d.<span class="hljs-built_in">foo</span>(<span class="hljs-number">3.4</span>) <span class="hljs-comment">// B&#x27;nin foosu dobule çağırılıyor.</span>
}
</code></pre>
<blockquote>
<p>Multiple inharitance ve diamond inheritance, virtual base class, konularının incelenmesi gerekiyor.</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-comment">//birden fazla template argümanı kullanılabilir.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Overloader</span> : Args... <span class="hljs-comment">// pack expansion, bir ya da birden fazla taban sınıftan elde eedebiliyoruz.</span>
{
   <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Args::operator</span><span class="hljs-params">()</span>...</span>;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{
   
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{
   
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>{
   
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   Der&lt;A,B,C&gt; y;
   Der&lt;A,B&gt;   x;
   Der&lt;A&gt;     z;

}
</code></pre>
<ul>
<li>Der kullanımında hepsi birbirinden farklı sınıflar,</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-comment">//birden fazla template argümanı kullanılabilir.</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Overloader</span> : Args... <span class="hljs-comment">// pack expansion, bir ya da birden fazla taban sınıftan elde eedebiliyoruz.</span>
{
   <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Args::operator</span><span class="hljs-params">()</span>...</span>;
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span>}</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span>}</span>;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span>}</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
   Der&lt;A,B,C&gt; y;
   Der&lt;A,B&gt;   x;
   Der&lt;A&gt;     z;
   y.<span class="hljs-built_in">fa</span>();
   y.<span class="hljs-built_in">fb</span>();
   y.<span class="hljs-built_in">fc</span>();
   <span class="hljs-comment">//y.foo(12); ambiguity oluşuyor,</span>
}
</code></pre>
<ul>
<li>Eğer D'sınıfı içerisinde taban sınıfın ismi görünür kıllınsaydı bunu yapabiliyoruz ve artık modern c++ ile variadic olarak using bildirimi yapabiliyoruz.</li>
<li>
<ul>
<li><code>using Args::foo...;</code> kodunu sınıf içerisine ekleyerek kullanabiliyoruz.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{ <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>);};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span>{ <span class="hljs-built_in">B</span>(<span class="hljs-type">double</span>);};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>{ <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span>)};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : A,B,C
{};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    D dx = {<span class="hljs-number">35</span>,<span class="hljs-number">2.3</span>,<span class="hljs-number">31</span>};
}
</code></pre>
<ul>
<li>Aşapuda decltype(fn) kullanımı C++20'ye kadar geçersizdi çünkü lambda class'ının default ctor'u yoktu ve bunun için lambda ifadesinin stateless lambda olması gerekiyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x+<span class="hljs-number">5</span>;};
    <span class="hljs-comment">//decltype(fn) x; </span>
}
</code></pre>
<ul>
<li>Closure type bir class ve bunu base class olarak kullanabiliyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">auto</span> fn = [](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x*<span class="hljs-number">4</span>;};
<span class="hljs-keyword">auto</span> fn1 = [](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x*<span class="hljs-number">5</span>;};
<span class="hljs-keyword">auto</span> fn2 = [](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x*<span class="hljs-number">6</span>;};
<span class="hljs-keyword">auto</span> fn3 = [](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x*<span class="hljs-number">7</span>;};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">decltype</span>(fn)
{
};

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">decltype</span>(fn1), <span class="hljs-keyword">decltype</span>(fn2), <span class="hljs-keyword">decltype</span>(fn3)
{
};
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : <span class="hljs-built_in">delctype</span>([](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x+<span class="hljs-number">4</span>;}), <span class="hljs-keyword">decltype</span>(fn2)
{}; 
</code></pre>
<ul>
<li>Struct C de C++17'de sentaks hatası oluyor. C++20 ile lambda ifadelerini unevulated context olarak kullanılıyor. Kullanıldığı yerlerden biri olarak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> fn = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y){<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x) &lt; <span class="hljs-built_in">abs</span>(y);};
    <span class="hljs-comment">//set&lt;int, decltype(fn)&gt;myset; C++17&#x27;de bu geçersiz fn&#x27;yi argüman olarak göndermemiz gerekiyor çünkü burada arka planda kod default constructor ediliyor.</span>
    set&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(fn)&gt;<span class="hljs-built_in">myset</span>(fn); <span class="hljs-comment">//şeklinde olması gerekiyor.</span>
    <span class="hljs-comment">//c++20 de</span>
    set&lt;<span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(
         [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)
         {<span class="hljs-keyword">return</span> abs(x) &lt; abs(y);}
    )&gt; mmmset;
}
</code></pre>
<ul>
<li>Taban sınıf olarak template argümanı olarak lambdaları kullanabiliyoruz</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Deneme</span> : Args...
{
    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Args::operator</span><span class="hljs-params">()</span>...</span>;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> f1 = [](){};
    <span class="hljs-keyword">auto</span> f2 = [](){};
    <span class="hljs-keyword">auto</span> f3 = [](){};
    Deneme&lt;<span class="hljs-keyword">decltype</span>(f1),<span class="hljs-keyword">decltype</span>(f2),<span class="hljs-keyword">decltype</span>(f3)&gt; d;
}
</code></pre>
<blockquote>
<p>Kalıtımda bir taban sınıfı birden fazla kez kullanamayız bu da f1,f2,f3'ün türlerinin aynı tür olmadığını kanıtlıyor.</p>
</blockquote>
<ul>
<li>Aşağıdaki gibi Overload sınıfını tanımlayabiliriz. C++17'de sentaks hatası oluyor çünkü <em>deduction guide</em> gerekiyor. <em>deduction guide</em> C++17 ile dile eklendi.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Overload</span> : Args...
{

};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Overload x{
        [](<span class="hljs-type">int</span> x){std::cout &lt;&lt; <span class="hljs-string">&quot;int : &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;},
        [](<span class="hljs-type">int</span> b){std::cout &lt;&lt; <span class="hljs-string">&quot;int b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;},        
    };
}
</code></pre>
<ul>
<li>Aşağıdaki kodda sentaks hatası var çünkü constructor parametresi referans olduğu T'türünün çıkarımı <code>int[10]</code>'a referans oluyor. Problem int türden bir diziyi int türden bir diziyle initialize etmek istiyoruz fakat böyle bir sentaks yok.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>
{
    <span class="hljs-built_in">Pair</span>(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> U&amp;) : <span class="hljs-built_in">mfirst</span>(t),<span class="hljs-built_in">msecond</span>(u){}
    <span class="hljs-comment">//Pair(T,U); olursa burada kopyalanma maliyeti ortaya çıkarıyor olaiblir.</span>
<span class="hljs-keyword">private</span>:
    T mfirst;
    U msecond;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]{};
    <span class="hljs-type">double</span> b[<span class="hljs-number">20</span>]{};
    Pair p1{a,b}; <span class="hljs-comment">// T : int[10] U : double[20]</span>
}
</code></pre>
<ul>
<li>Fakat burada aşağıdaki gibi tanımlasaydık artık çıkarım int <em>ve double</em> olarak yapılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>
{
    <span class="hljs-built_in">Pair</span>( T t, U u) : <span class="hljs-built_in">mfirst</span>(t),<span class="hljs-built_in">msecond</span>(u){}
    <span class="hljs-comment">//Pair(T,U); olursa burada kopyalanma maliyeti ortaya çıkarıyor olaiblir.</span>
<span class="hljs-keyword">private</span>:
    T mfirst;
    U msecond;
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]{};
    <span class="hljs-type">double</span> b[<span class="hljs-number">20</span>]{};
    Pair p1{a,b}; <span class="hljs-comment">// T : int[10] U : double[20]</span>
}
</code></pre>
<ul>
<li>Bir önceki kodda: Bu sentaksa deduction guide deniyor, Eğer 2 tane argüman geçilirse burada pairin T U açılımı kullanılacak.</li>
</ul>
<hr>
<p><strong>Deduction Guide</strong> özet</p>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>
{
    <span class="hljs-built_in">Pair</span>(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> U&amp;) : <span class="hljs-built_in">mfirst</span>(t),<span class="hljs-built_in">msecond</span>(u){}
    <span class="hljs-comment">//Pair(T,U); olursa burada kopyalanma maliyeti ortaya çıkarıyor olaiblir.</span>
<span class="hljs-keyword">private</span>:
    T mfirst;
    U msecond;
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-title">Pair</span><span class="hljs-params">(T,U)</span> -&gt; Pair&lt;T,U&gt;</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]{};
    <span class="hljs-type">double</span> b[<span class="hljs-number">20</span>]{};
    Pair p1{a,b}; <span class="hljs-comment">// T : int[10] U : double[20]</span>
}
</code></pre>
<ul>
<li>Bu parametrelerin türü <code>int *</code> türüne referans ve <code>double *</code> türüne referans olarak çıkarım yapılıyor.</li>
<li>Örneğin aşağıdaki kodda <code>const char *</code> için yapılacak çıkarımı <code>string</code> çıkarımı şekllinde yapılmasını sağlıyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
    <span class="hljs-built_in">Myclass</span>(T);
};
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) -&gt; Myclass&lt;std::string&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">Myclass <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-string">&quot;neco&quot;</span>)</span></span>;
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    list &lt;<span class="hljs-type">int</span>&gt; mylist {<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>};
    <span class="hljs-comment">//vector myvec(mylist.begin(),mylist.end());</span>
    <span class="hljs-comment">//burada vector&#x27;un int açılımı tutuluyor. Burada bir deduction guide kullanılıyor.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iter&gt;
<span class="hljs-comment">//vector(Iter, Iter) -&gt; vector&lt;typename iterator_traits&lt;Iter&gt;::value_types&gt;</span>
</code></pre>
<hr>
<ul>
<li>Overload idiomu, Bu kod C++20 ile çalışıyor. C++176 ile çalışabilmesi için <em>deduction guide</em> gerekiyor. Overolad</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Args&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Overload</span>{
<span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Args::operator</span><span class="hljs-params">()</span>...</span>;
};
<span class="hljs-comment">// template&lt;typename ...Args&gt;</span>
<span class="hljs-comment">//Overload(Args...)-&gt;Overload&lt;Args...&gt;</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,<span class="hljs-type">long</span>,string&gt;vx{<span class="hljs-string">&quot;murat&quot;</span>};
    <span class="hljs-built_in">visit</span>(Overload{
    [](<span class="hljs-type">int</span>){cout&lt;&lt; <span class="hljs-string">&quot;int\n&quot;</span>;},
    [](<span class="hljs-type">double</span>){cout&lt;&lt; <span class="hljs-string">&quot;double\n&quot;</span>;},
    [](<span class="hljs-type">long</span>){cout&lt;&lt; <span class="hljs-string">&quot;long\n&quot;</span>;}
    [](string){cout&lt;&lt; <span class="hljs-string">&quot;string\n&quot;</span>;}
}, vx);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>Başka bir örnek</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...Ts&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">overload</span> : Ts...
{
    <span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">Ts::operator</span><span class="hljs-params">()</span></span>;
};
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ...Ts&gt;
<span class="hljs-built_in">overload</span>(...Ts)-&gt;overload&lt;Ts...&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    variant&lt;<span class="hljs-type">int</span>,string&gt;<span class="hljs-built_in">vx</span>(<span class="hljs-number">00</span>);
    <span class="hljs-built_in">visit</span>(overload{
    [](<span class="hljs-type">int</span> ival){cout &lt;&lt;<span class="hljs-string">&quot;int &quot;</span>&lt;&lt; ival&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;},
    [](<span class="hljs-type">const</span> string &amp; sval){cout &lt;&lt;<span class="hljs-string">&quot;string &quot;</span>&lt;&lt; sval&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;},
    },vx
);    
    <span class="hljs-keyword">auto</span> twice = overload{
    [](std::string &amp;s){s+=s;},
    [](<span class="hljs-keyword">auto</span> &amp;i){i*=<span class="hljs-number">2</span>;},
    };<span class="hljs-number">7</span>
    <span class="hljs-built_in">visit</span>(twice,vx);
    std::cout &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(vx)&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>Eski alternatif destroy edildikten sonra, yeni alternatif oluşurken eğer constructor exception throw ederse burada variant geçersiz bir duruma geliyor. Standartlarda bunun sınanması için bir fonksiyon var. Variant nesnesinin durumunu sınamadıkça bunu bilmek mümkün değil.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">s</span>
{
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
    </span>{
        <span class="hljs-keyword">throw</span> std::runtime_error{<span class="hljs-string">&quot;hata&quot;</span>};
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    
    variant&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; var{<span class="hljs-number">12.2</span>};
    <span class="hljs-keyword">try</span>{
        var.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-number">1</span>&gt;(S{});
    }    
    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::exception &amp;ex)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;hata yakalandi  ....&quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>()&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        cout &lt;&lt; boolalpha &lt;&lt; var.<span class="hljs-built_in">valueless_by_exception</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        cout &lt;&lt; <span class="hljs-string">&quot;var.index: &quot;</span> &lt;&lt; var.<span class="hljs-built_in">index</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; 
        cout &lt;&lt; (var.<span class="hljs-built_in">index</span>() == variant_npos) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>Generic programlama için öğeler:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> vtype = std::variant&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,<span class="hljs-type">long</span>&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> n = variant_size&lt;vtype&gt;::value; <span class="hljs-comment">// n&#x27;nin değeri 3, variantın kaç </span>
    variant_alternative&lt;<span class="hljs-number">1</span>,type&gt;::type x{}; <span class="hljs-comment">//x&#x27;in türü double</span>
<span class="hljs-comment">//alias template&#x27; da var</span>
    <span class="hljs-type">variant_alternative_t</span>&lt;<span class="hljs-number">1</span>,vtype&gt;x {};
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="kullanım-senaryoları">Kullanım Senaryoları</h3>
<ul>
<li>
<p>Önceden belirlenmiş alternatiften birini tutcağını bildiğimiz tüm senaryolar için uygun.</p>
</li>
<li>
<p>Hatalar için:</p>
</li>
<li>
<ul>
<li>Fonksyion ya data'yı döndürecek ya da hata oluşursa hata türünü döndürücek.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span>{};
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ErrorType</span>{system,archive,log};

std::variant&lt;Data, ErrorType&gt;<span class="hljs-built_in">foo</span>();
</code></pre>
<ul>
<li>
<p>Komut satırı argümanları parse ederken o türden bir değer işlenebilir.</p>
</li>
<li>
<p>Fakat en önemli senaryolardan biri kalıtıma bir alternatif oluşturması ve run-time polymorphism sağlaması. Virtual-dispatch'in birden fazla maliyeti var. Derleyici run-time polymorphism'de her sınıf nesnesi için vpointer oluşturuyor. Hem  run-time da hem de bellek kullanımı açarısında maliyeti var. Hiyerarşideki tüm nesneleri için de vpointer oluyor.</p>
</li>
<li>
<ul>
<li>Ayrıca run-time başında bu tabloların oluşturulması gerekiyor.</li>
</ul>
</li>
<li>
<ul>
<li>Asıl problem virtual-dispatch'te her polymorphic nesne için allocation-deallocation var. Dinamik ömürlü nesneye bağlı olarak yüksek işlem maliyeti oluşturuyor.</li>
</ul>
</li>
<li>
<ul>
<li>Ayrıca sınıflar birbirine bağımlı hale geliyor.</li>
</ul>
</li>
<li>
<p><em>closed-hierarcy</em> daha önceden belirlenmiş ise, bu durumda varianttan yaralanabiliriz.</p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span>{<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Xls</span>{};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pdf</span>{};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Txt</span>{};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Word</span>{};

<span class="hljs-keyword">using</span> Document = std::variant&lt;Xls,Pdf,Txt,Word&gt;;
</code></pre>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Cat</span>(std::string name) : <span class="hljs-built_in">mname</span>(name){}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">meow</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; mname &lt;&lt; <span class="hljs-string">&quot; miyavladı\n&quot;</span>;
    }
<span class="hljs-keyword">private</span>:
    std::string mname;
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Dog</span>(std::string name) : <span class="hljs-built_in">mname</span>(name){}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; mname &lt;&lt; <span class="hljs-string">&quot; havladı\n&quot;</span>;
    }    
<span class="hljs-keyword">private</span>:
    std::string mname;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Lamb</span>{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Lamb</span>(std::string name) : <span class="hljs-built_in">mname</span>(name){}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bleat</span><span class="hljs-params">()</span><span class="hljs-type">const</span>
    </span>{
        std::cout &lt;&lt; mname &lt;&lt; <span class="hljs-string">&quot; mırladı\n&quot;</span>;
    }
<span class="hljs-keyword">private</span>:
    std::string mname;
};
<span class="hljs-keyword">using</span> Animal = std::variant&lt;Dog, Cat, Lamb&gt;;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnimalVoice</span>
{
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Dog &amp;d)</span><span class="hljs-type">const</span>
    </span>{
        d.<span class="hljs-built_in">bark</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Cat &amp;c)</span><span class="hljs-type">const</span>
    </span>{
        c.<span class="hljs-built_in">meow</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Lamb &amp;l)</span><span class="hljs-type">const</span>
    </span>{
        l.<span class="hljs-built_in">bleat</span>();
    }
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">bool</span> <span class="hljs-title">is_type</span><span class="hljs-params">(<span class="hljs-type">const</span> Animal&amp;s)</span>
</span>{
    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">holds_alternative</span>&lt;T&gt;(s);
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    list&lt;Animal&gt; animals;
    animals.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;Kara&quot;</span>));
    animals.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Pamuk&quot;</span>));
    animals.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Lamb</span>(<span class="hljs-string">&quot;Kuzucuk&quot;</span>));
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;a : animals)
    {
        <span class="hljs-built_in">visit</span>(AnimalVoice{}, a);
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> Animal &amp;a: animals)
    {
        <span class="hljs-keyword">switch</span>(a.<span class="hljs-built_in">index</span>())
        {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">get</span>&lt;Dog&gt;(a).<span class="hljs-built_in">bark</span>(); <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">get</span>&lt;Cat&gt;(a).<span class="hljs-built_in">meow</span>(); <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">get</span>&lt;Lamb&gt;(a).<span class="hljs-built_in">bleat</span>(); <span class="hljs-keyword">break</span>;
        }
    }
    cout &lt;&lt;<span class="hljs-string">&quot;----------------\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> Animal &amp;a: animals)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get_if</span>&lt;Dog&gt;(&amp;a))
        {
            p-&gt;<span class="hljs-built_in">bark</span>();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get_if</span>&lt;Cat&gt;(&amp;a))
        {
            p-&gt;<span class="hljs-built_in">meow</span>();
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">get_if</span>&lt;Lamb&gt;(&amp;a))
        {
            p-&gt;<span class="hljs-built_in">bleat</span>();
        }
    }
    cout &lt;&lt;<span class="hljs-string">&quot;----------------\n&quot;</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> Animal &amp;a: animals)
    {
        <span class="hljs-built_in">visit</span>(AnimalVoice{}, a);
    }
    cout &lt;&lt;<span class="hljs-string">&quot;----------------\n&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    
}
</code></pre>
<p><a href="https://onlinegdb.com/1n22gcuNe">kodun calışanı</a></p>
<h2 id="stdany">std::any</h2>
<ul>
<li>Bir sınıf şablonu değil ve any türünden bir nesne herhangi bir türe dönüştürülebiliyor. Başlık dosyası <code>&lt;any&gt;</code>.</li>
<li>Doğrudan belirli bir türlü hayata başlatabiliyoruz.</li>
<li>Böylece void pointer'a bir alternatif oluşturulmuş oluyor. <code>Void *</code> tür bilgisi bilmiyorken, any bu bilgiye sahip.</li>
<li>any türü storage'i küçük nesneleri kendi içerisindeki buffer'da tutabiliyor fakat burada kendi içinde tutmuyor ve dinamik bir bellek alanı elde edebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    any x1;
    any x2{};
    <span class="hljs-built_in">boolalpha</span>(cout);
    cout &lt;&lt; x1.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    cout &lt;&lt; x2.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// false</span>
    any a3 = <span class="hljs-number">12</span>;
    any a4{<span class="hljs-string">&quot;deneme&quot;</span>};
    any a5{<span class="hljs-string">&quot;deneme&quot;</span>s};
    any a{vector&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">56</span>}};
}
</code></pre>
<blockquote>
<p>type_id operatörünün bilinmesi gerekiyor.</p>
</blockquote>
<ul>
<li>Çünkü any sınıfı içerisinde ayrıca bir typeinfo sınıfı tutuyor.</li>
</ul>
<h3 id="typeid-ve-typeinfo-sınıfı">typeid ve typeinfo sınıfı</h3>
<ul>
<li>type_info isimli bir sınıf var ve bu sınıfı kullanmanın tek yolu type_id operatörü.</li>
<li>Var olan type_id referansı ile erişilen sınıfın üye fonksiyonları var.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//auto x = typeid(int); // type-info sınıfının copy ctor&#x27;u delete edilmiş, bu yüzden sentaks hatası oluyor.</span>
    <span class="hljs-comment">//type_info &amp;r = typeid(std::string); const referans olmadığı için sentaks hatası oluyor.</span>
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">typeid</span>(std::string);
    <span class="hljs-built_in">typeid</span>(std::string) == <span class="hljs-built_in">typeid</span>(x); <span class="hljs-comment">//r.operator== //ile iki nesneinin aynı tür olup olmadığını sınayabiliriz.</span>

}
</code></pre>
<h3 id="any-sınıfı-devam">any sınıfı devam</h3>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> sz)</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;new called&quot;</span>&lt;&lt; sz&lt;&lt;  <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">if</span>(sz == <span class="hljs-number">0</span>)
    {
        ++sz;
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-type">void</span> *p = std::<span class="hljs-built_in">malloc</span>(sz))
    {
        <span class="hljs-keyword">return</span> p;
    }
    <span class="hljs-keyword">throw</span> std::bad_alloc{};
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Den</span>
{
    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(std::any) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(std::any) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    any a = <span class="hljs-number">356</span>; <span class="hljs-comment">//int içinde buffer da tutabilir</span>
}
</code></pre>
<ul>
<li>Any türünden bir nesnenin farklı türden bir değer tutması sağlanabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    any a = <span class="hljs-number">12</span>;
    a =<span class="hljs-string">&quot;deneme&quot;</span>s;
    a = <span class="hljs-string">&quot;char&quot;</span>;
}
</code></pre>
<ul>
<li>in_place_type ile tuttuğu bellek alanında tuttuğu türden bir nesne oluşturulabilir. Bunu doğrudan kullanmak istemiyorsak <code>make_any</code> fonksiyonu kullanılabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    any a{in_place_type&lt;Date&gt;<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1955</span>};
    <span class="hljs-comment">//auto a = make_any&lt;Date&gt;(5,5,1955);</span>
    cout &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;Date&gt;(a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<h3 id="tuttuğu-türe-erişme">Tuttuğu Türe erişme</h3>
<ul>
<li>sınıfın bir type fonksiyonu var ve bu fonksiyon <code>const type_info &amp;</code> dönüyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    any a = <span class="hljs-number">12</span>;
    <span class="hljs-comment">// any a = 3.5;</span>
    <span class="hljs-comment">// any a = &quot;neco&quot;s;</span>
    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>))
        std::cout &lt;&lt; <span class="hljs-string">&quot;int\n&quot;</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">double</span>))
        std::cout &lt;&lt; <span class="hljs-string">&quot;double\n&quot;</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(string))
        std::cout &lt;&lt; <span class="hljs-string">&quot;string\n&quot;</span>;
}
</code></pre>
<ul>
<li>Eğer any nesnesi boş ise type fonksiyonu <code>void</code> döndürüyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    any a;
    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">void</span>))
        std::cout &lt;&lt; <span class="hljs-string">&quot;void\n&quot;</span>;
}
</code></pre>
<ul>
<li>Burada gene decay oluyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> ar[<span class="hljs-number">10</span>]{};
    any a = ar;
    cout&lt;&lt; boolalpha &lt;&lt; (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span> *)) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout&lt;&lt; boolalpha &lt;&lt; (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span> [<span class="hljs-number">10</span>])) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<h3 id="tuttuğu-değere-erişme">Tuttuğu değere erişme</h3>
<ul>
<li><code>any_cast&lt;tür&gt;</code> ile erişiyoruz ve eğer tuttuğu türden başka bir türe erişmeye çalışırsak <code>std::bad_cast</code> exception throw ediyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    any a = <span class="hljs-number">12</span>;
    cout &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);
    <span class="hljs-keyword">try</span>{
        cout &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">double</span>&gt;(a);
    }
    <span class="hljs-comment">//catch(const std::bad_any_cast &amp;ex)</span>
    <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_cast &amp;ex)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;exception caught : &quot;</span> &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
}
</code></pre>
<h3 id="any-üye-fonksiyonları">Any Üye Fonksiyonları</h3>
<ul>
<li>reset fonksiyonu ile boşaltabiliyoruz.</li>
<li>emplace fonksiyonu var.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    any a = <span class="hljs-built_in">make_any</span>&lt;string&gt;(<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;T&#x27;</span>);
    cout &lt;&lt; boolalpha &lt;&lt; a.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    a.<span class="hljs-built_in">reset</span>();
    cout &lt;&lt; a.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    a.<span class="hljs-built_in">emplace</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">12</span>);
    cout &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; a.<span class="hljs-built_in">has_value</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>Move semantiğinden faydalanabiliriz.</li>
</ul>
<pre><code class="language-c++">
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span>
</span>{
    any a{<span class="hljs-string">&quot;Deneme&quot;</span>s};
    <span class="hljs-keyword">auto</span> &amp;ra = <span class="hljs-built_in">any_cast</span>&lt;string&amp;&gt;(a);
    ra[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;T&#x27;</span>;
    <span class="hljs-comment">//ra.at(0) = &#x27;T&#x27;;</span>
    <span class="hljs-comment">//ra.front() = &#x27;T&#x27;;</span>
    std::cout &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;string <span class="hljs-type">const</span>&amp;&gt; (a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">auto</span> str = <span class="hljs-built_in">any_cast</span>&lt;string&amp;&amp;&gt;(<span class="hljs-built_in">move</span>(a));
    <span class="hljs-built_in">static_assert</span>(is_same_v&lt;<span class="hljs-keyword">decltype</span>(str), string&gt;);
    <span class="hljs-comment">//any_cast&lt;const string&amp;&gt;(a).size();</span>
    std::cout &lt;&lt;<span class="hljs-string">&quot;a.size() &quot;</span>&lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;string&gt;(&amp;a)-&gt;<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; 
    cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>any_cast'i <code>get_if</code> gibi kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    any a = <span class="hljs-number">12</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;a))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;int\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> ptr = <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">double</span>&gt;(&amp;a))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;double: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">any_cast</span>&lt;string&gt;(&amp;a))
    {
        std::cout &lt;&lt; <span class="hljs-string">&quot;string\n&quot;</span>;
    }
}
</code></pre>
<ul>
<li>Container ile kullanabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;any&gt; vx{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;deneme&quot;</span>s,<span class="hljs-number">34L</span>,<span class="hljs-string">&quot;alican&quot;</span>};
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;a : vx)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;a))
        {
            cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">any_cast</span>&lt;string&gt;(&amp;a))
        {
            cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">long</span>&gt;(&amp;a))
        {
            cout &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
    }
}
</code></pre>
<ul>
<li>direkt any olarak tutmak yerine pair-any gibi tutabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">using</span> tv_pair = std::pair&lt;std::string, std::any&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;tv_pair&gt; vx;
    vx.<span class="hljs-built_in">push_back</span>({<span class="hljs-string">&quot;int&quot;</span>s, <span class="hljs-number">12</span>});
    vx.<span class="hljs-built_in">push_back</span>({<span class="hljs-string">&quot;double&quot;</span>s, <span class="hljs-number">3.4</span>});
    vx.<span class="hljs-built_in">push_back</span>({<span class="hljs-string">&quot;string&quot;</span>s, <span class="hljs-string">&quot;neco&quot;</span>s});
    vx.<span class="hljs-built_in">push_back</span>({<span class="hljs-string">&quot;long&quot;</span>s, <span class="hljs-number">12L</span>});
    cout &lt;&lt; left;

    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[property,value]:vec)
    {
        <span class="hljs-keyword">if</span>(value.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>))
        {
            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; property &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(value) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">double</span>))
        {
            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; property &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">double</span>&gt;(value) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(string))
        {
            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; property &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;string&gt;(value) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">long</span>))
        {
            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; property &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; <span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">long</span>&gt;(value) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        }
    }
}
</code></pre>
</div>
        </div>
            
            
        </body>
        </html>