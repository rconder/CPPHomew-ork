<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>6&period;Hafta</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension bierner.markdown-preview-github-styles */
html,
body,
.github-markdown-body {
    padding: 0 !important;
    max-width: auto !important;
}

.github-markdown-body {
    background-color: var(--color-canvas-default);
    color: var(--color-fg-default);
}

.github-markdown-body {
    border: 1px solid transparent;
    box-sizing: border-box;
    margin: 0 auto;
    width: 100% !important;
}

.github-markdown-content {
    padding: 32px !important;
    max-width: 980px;
    min-width: 200px;
    margin: 0 auto;
}


.vscode-body.scrollBeyondLastLine {
    margin-bottom: 0;
}
.vscode-body.scrollBeyondLastLine .github-markdown-body {
    padding-bottom: calc(100vh + 10px) !important;
}

.github-markdown-body blockquote {
    background-color: initial;
}

.github-markdown-body pre {
    color: initial;
    border: none;
}

.github-markdown-body code {
    color: inherit;
}

.github-markdown-body pre code {
    color: initial;
}

.github-markdown-body code > div {
    background: none
}

.github-markdown-body.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre {
  margin-top: 16px;
  margin-bottom: 16px;
}

.vscode-dark.showEditorSelection .code-line:hover:before {
    border-left: 3px solid var(--color-fg-default);
}
.github-markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-default, var(--color-canvas-default));
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.github-markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.github-markdown-body h1:hover .anchor .octicon-link:before,
.github-markdown-body h2:hover .anchor .octicon-link:before,
.github-markdown-body h3:hover .anchor .octicon-link:before,
.github-markdown-body h4:hover .anchor .octicon-link:before,
.github-markdown-body h5:hover .anchor .octicon-link:before,
.github-markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.github-markdown-body details,
.github-markdown-body figcaption,
.github-markdown-body figure {
  display: block;
}

.github-markdown-body summary {
  display: list-item;
}

.github-markdown-body [hidden] {
  display: none !important;
}

.github-markdown-body a {
  background-color: transparent;
  color: var(--fgColor-accent, var(--color-accent-fg));
  text-decoration: none;
}

.github-markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.github-markdown-body b,
.github-markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dfn {
  font-style: italic;
}

.github-markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body mark {
  background-color: var(--bgColor-attention-muted, var(--color-attention-subtle));
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body small {
  font-size: 90%;
}

.github-markdown-body sub,
.github-markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.github-markdown-body sub {
  bottom: -0.25em;
}

.github-markdown-body sup {
  top: -0.5em;
}

.github-markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--bgColor-default, var(--color-canvas-default));
}

.github-markdown-body code,
.github-markdown-body kbd,
.github-markdown-body pre,
.github-markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.github-markdown-body figure {
  margin: 1em 40px;
}

.github-markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--borderColor-default, var(--color-border-default));
  border: 0;
}

.github-markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.github-markdown-body [type=button],
.github-markdown-body [type=reset],
.github-markdown-body [type=submit] {
  -webkit-appearance: button;
}

.github-markdown-body [type=checkbox],
.github-markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.github-markdown-body [type=number]::-webkit-inner-spin-button,
.github-markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.github-markdown-body [type=search]::-webkit-search-cancel-button,
.github-markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.github-markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.github-markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.github-markdown-body a:hover {
  text-decoration: underline;
}

.github-markdown-body ::placeholder {
  color: var(--fgColor-muted, var(--color-fg-subtle));
  opacity: 1;
}

.github-markdown-body hr::before {
  display: table;
  content: "";
}

.github-markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.github-markdown-body td,
.github-markdown-body th {
  padding: 0;
}

.github-markdown-body details summary {
  cursor: pointer;
}

.github-markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.github-markdown-body a:focus,
.github-markdown-body [role=button]:focus,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:focus:not(:focus-visible),
.github-markdown-body [role=button]:focus:not(:focus-visible),
.github-markdown-body input[type=radio]:focus:not(:focus-visible),
.github-markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.github-markdown-body a:focus-visible,
.github-markdown-body [role=button]:focus-visible,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--focus-outlineColor, var(--color-accent-fg));
  outline-offset: -2px;
  box-shadow: none;
}

.github-markdown-body a:not([class]):focus,
.github-markdown-body a:not([class]):focus-visible,
.github-markdown-body input[type=radio]:focus,
.github-markdown-body input[type=radio]:focus-visible,
.github-markdown-body input[type=checkbox]:focus,
.github-markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.github-markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border: solid 1px var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-bottom-color: var(--borderColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--borderColor-neutral-muted, var(--color-neutral-muted));
}

.github-markdown-body h1,
.github-markdown-body h2,
.github-markdown-body h3,
.github-markdown-body h4,
.github-markdown-body h5,
.github-markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.github-markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.github-markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.github-markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.github-markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--fgColor-muted, var(--color-fg-muted));
}

.github-markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.github-markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-left: .25em solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body ul,
.github-markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.github-markdown-body ol ol,
.github-markdown-body ul ol {
  list-style-type: lower-roman;
}

.github-markdown-body ul ul ol,
.github-markdown-body ul ol ol,
.github-markdown-body ol ul ol,
.github-markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.github-markdown-body dd {
  margin-left: 0;
}

.github-markdown-body tt,
.github-markdown-body code,
.github-markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.github-markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.github-markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.github-markdown-body input::-webkit-outer-spin-button,
.github-markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.github-markdown-body::before {
  display: table;
  content: "";
}

.github-markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.github-markdown-body>*:first-child {
  margin-top: 0 !important;
}

.github-markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.github-markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.github-markdown-body .absent {
  color: var(--fgColor-danger, var(--color-danger-fg));
}

.github-markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.github-markdown-body .anchor:focus {
  outline: none;
}

.github-markdown-body p,
.github-markdown-body blockquote,
.github-markdown-body ul,
.github-markdown-body ol,
.github-markdown-body dl,
.github-markdown-body table,
.github-markdown-body pre,
.github-markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.github-markdown-body blockquote>:first-child {
  margin-top: 0;
}

.github-markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.github-markdown-body h1 .octicon-link,
.github-markdown-body h2 .octicon-link,
.github-markdown-body h3 .octicon-link,
.github-markdown-body h4 .octicon-link,
.github-markdown-body h5 .octicon-link,
.github-markdown-body h6 .octicon-link {
  color: var(--fgColor-default, var(--color-fg-default));
  vertical-align: middle;
  visibility: hidden;
}

.github-markdown-body h1:hover .anchor,
.github-markdown-body h2:hover .anchor,
.github-markdown-body h3:hover .anchor,
.github-markdown-body h4:hover .anchor,
.github-markdown-body h5:hover .anchor,
.github-markdown-body h6:hover .anchor {
  text-decoration: none;
}

.github-markdown-body h1:hover .anchor .octicon-link,
.github-markdown-body h2:hover .anchor .octicon-link,
.github-markdown-body h3:hover .anchor .octicon-link,
.github-markdown-body h4:hover .anchor .octicon-link,
.github-markdown-body h5:hover .anchor .octicon-link,
.github-markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.github-markdown-body h1 tt,
.github-markdown-body h1 code,
.github-markdown-body h2 tt,
.github-markdown-body h2 code,
.github-markdown-body h3 tt,
.github-markdown-body h3 code,
.github-markdown-body h4 tt,
.github-markdown-body h4 code,
.github-markdown-body h5 tt,
.github-markdown-body h5 code,
.github-markdown-body h6 tt,
.github-markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2,
.github-markdown-body summary h3,
.github-markdown-body summary h4,
.github-markdown-body summary h5,
.github-markdown-body summary h6 {
  display: inline-block;
}

.github-markdown-body summary h1 .anchor,
.github-markdown-body summary h2 .anchor,
.github-markdown-body summary h3 .anchor,
.github-markdown-body summary h4 .anchor,
.github-markdown-body summary h5 .anchor,
.github-markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.github-markdown-body summary h1,
.github-markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.github-markdown-body ul.no-list,
.github-markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.github-markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.github-markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.github-markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.github-markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.github-markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.github-markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.github-markdown-body ul ul,
.github-markdown-body ul ol,
.github-markdown-body ol ol,
.github-markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.github-markdown-body li>p {
  margin-top: 16px;
}

.github-markdown-body li+li {
  margin-top: .25em;
}

.github-markdown-body dl {
  padding: 0;
}

.github-markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.github-markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.github-markdown-body table th,
.github-markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body table td>:last-child {
  margin-bottom: 0;
}

.github-markdown-body table tr {
  background-color: var(--bgColor-default, var(--color-canvas-default));
  border-top: 1px solid var(--borderColor-muted, var(--color-border-muted));
}

.github-markdown-body table tr:nth-child(2n) {
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
}

.github-markdown-body table img {
  background-color: transparent;
}

.github-markdown-body img[align=right] {
  padding-left: 20px;
}

.github-markdown-body img[align=left] {
  padding-right: 20px;
}

.github-markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.github-markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.github-markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body span.frame span img {
  display: block;
  float: left;
}

.github-markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.github-markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.github-markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.github-markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.github-markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-left span {
  margin: 13px 0 0;
}

.github-markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.github-markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.github-markdown-body code,
.github-markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--bgColor-neutral-muted, var(--color-neutral-muted));
  border-radius: 6px;
}

.github-markdown-body code br,
.github-markdown-body tt br {
  display: none;
}

.github-markdown-body del code {
  text-decoration: inherit;
}

.github-markdown-body samp {
  font-size: 85%;
}

.github-markdown-body pre code {
  font-size: 100%;
}

.github-markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.github-markdown-body .highlight {
  margin-bottom: 16px;
}

.github-markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.github-markdown-body .highlight pre,
.github-markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--fgColor-default, var(--color-fg-default));
  background-color: var(--bgColor-muted, var(--color-canvas-subtle));
  border-radius: 6px;
}

.github-markdown-body pre code,
.github-markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.github-markdown-body .csv-data td,
.github-markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.github-markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--bgColor-default, var(--color-canvas-default));
  border: 0;
}

.github-markdown-body .csv-data tr {
  border-top: 0;
}

.github-markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--bgColor-muted, var(--color-canvas-subtle));
  border-top: 0;
}

.github-markdown-body [data-footnote-ref]::before {
  content: "[";
}

.github-markdown-body [data-footnote-ref]::after {
  content: "]";
}

.github-markdown-body .footnotes {
  font-size: 12px;
  color: var(--fgColor-muted, var(--color-fg-muted));
  border-top: 1px solid var(--borderColor-default, var(--color-border-default));
}

.github-markdown-body .footnotes ol {
  padding-left: 16px;
}

.github-markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.github-markdown-body .footnotes li {
  position: relative;
}

.github-markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--borderColor-accent-emphasis, var(--color-accent-emphasis));
  border-radius: 6px;
}

.github-markdown-body .footnotes li:target {
  color: var(--fgColor-default, var(--color-fg-default));
}

.github-markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.github-markdown-body [popover] {
  background-color: canvas;
  border: initial solid;
  border-color: initial;
  border-image: initial;
  color: initial;
  height: fit-content;
  inset: 0;
  margin: auto;
  overflow: auto;
  padding: .25em;
  position: fixed;
  width: fit-content;
  z-index: 2147483647;
}

.github-markdown-body [popover]:not(.\:popover-open) {
  display: none;
}

.github-markdown-body [popover]:is(dialog[open]) {
  display: revert;
}

.github-markdown-body [anchor].\:popover-open {
  inset: auto;
}

.github-markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.github-markdown-body .pl-c1,
.github-markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body .pl-e,
.github-markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .pl-smi,
.github-markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.github-markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.github-markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.github-markdown-body .pl-s,
.github-markdown-body .pl-pds,
.github-markdown-body .pl-s .pl-pse .pl-s1,
.github-markdown-body .pl-sr,
.github-markdown-body .pl-sr .pl-cce,
.github-markdown-body .pl-sr .pl-sre,
.github-markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.github-markdown-body .pl-v,
.github-markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.github-markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.github-markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.github-markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.github-markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.github-markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.github-markdown-body .pl-mh,
.github-markdown-body .pl-mh .pl-en,
.github-markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.github-markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.github-markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.github-markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.github-markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.github-markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.github-markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.github-markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.github-markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.github-markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.github-markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.github-markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.github-markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.github-markdown-body .task-list-item {
  list-style-type: none;
}

.github-markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.github-markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.github-markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.github-markdown-body .task-list-item .handle {
  display: none;
}

.github-markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.github-markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.github-markdown-body .contains-task-list {
  position: relative;
}

.github-markdown-body .contains-task-list:hover .task-list-item-convert-container,
.github-markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.github-markdown-body .QueryBuilder .qb-entity {
  color: var(--color-prettylights-syntax-entity);
}

.github-markdown-body .QueryBuilder .qb-constant {
  color: var(--color-prettylights-syntax-constant);
}

.github-markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
[data-color-mode=light][data-light-theme=light],
[data-color-mode=dark][data-dark-theme=light],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light] {
  /*light*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #116329;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #953800;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #116329;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #116329;
  --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
  --color-prettylights-syntax-markup-changed-text: #953800;
  --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #1F2328;
  --color-fg-muted: #656d76;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=light_colorblind],
[data-color-mode=dark][data-dark-theme=light_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_colorblind] {
  /*light_colorblind*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #b35900;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #8a4600;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6f3800;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #6f3800;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #b35900;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #6f3800;
  --color-prettylights-syntax-markup-deleted-bg: #fff5e8;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #8a4600;
  --color-prettylights-syntax-markup-changed-bg: #ffddb0;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #b35900;
}
}

[data-color-mode=light][data-light-theme=light_tritanopia],
[data-color-mode=dark][data-dark-theme=light_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_tritanopia] {
  /*light_tritanopia*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #6e7781;
  --color-prettylights-syntax-constant: #0550ae;
  --color-prettylights-syntax-entity: #6639ba;
  --color-prettylights-syntax-storage-modifier-import: #24292f;
  --color-prettylights-syntax-entity-tag: #0550ae;
  --color-prettylights-syntax-keyword: #cf222e;
  --color-prettylights-syntax-string: #0a3069;
  --color-prettylights-syntax-variable: #a40e26;
  --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
  --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
  --color-prettylights-syntax-invalid-illegal-bg: #82071e;
  --color-prettylights-syntax-carriage-return-text: #f6f8fa;
  --color-prettylights-syntax-carriage-return-bg: #cf222e;
  --color-prettylights-syntax-string-regexp: #0550ae;
  --color-prettylights-syntax-markup-list: #3b2300;
  --color-prettylights-syntax-markup-heading: #0550ae;
  --color-prettylights-syntax-markup-italic: #24292f;
  --color-prettylights-syntax-markup-bold: #24292f;
  --color-prettylights-syntax-markup-deleted-text: #82071e;
  --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
  --color-prettylights-syntax-markup-inserted-text: #0550ae;
  --color-prettylights-syntax-markup-inserted-bg: #ddf4ff;
  --color-prettylights-syntax-markup-changed-text: #a40e26;
  --color-prettylights-syntax-markup-changed-bg: #ffcecb;
  --color-prettylights-syntax-markup-ignored-text: #eaeef2;
  --color-prettylights-syntax-markup-ignored-bg: #0550ae;
  --color-prettylights-syntax-meta-diff-range: #8250df;
  --color-prettylights-syntax-brackethighlighter-angle: #57606a;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
  --color-prettylights-syntax-constant-other-reference-link: #0a3069;
  --color-fg-default: #24292f;
  --color-fg-muted: #57606a;
  --color-fg-subtle: #6e7781;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #f6f8fa;
  --color-border-default: #d0d7de;
  --color-border-muted: hsla(210,18%,87%,1);
  --color-neutral-muted: rgba(175,184,193,0.2);
  --color-accent-fg: #0969da;
  --color-accent-emphasis: #0969da;
  --color-attention-subtle: #fff8c5;
  --color-danger-fg: #cf222e;
}
}

[data-color-mode=light][data-light-theme=light_high_contrast],
[data-color-mode=dark][data-dark-theme=light_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=light_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=light_high_contrast] {
  /*light_high_contrast*/
  color-scheme: light;
  --color-prettylights-syntax-comment: #66707b;
  --color-prettylights-syntax-constant: #023b95;
  --color-prettylights-syntax-entity: #512598;
  --color-prettylights-syntax-storage-modifier-import: #0e1116;
  --color-prettylights-syntax-entity-tag: #024c1a;
  --color-prettylights-syntax-keyword: #a0111f;
  --color-prettylights-syntax-string: #032563;
  --color-prettylights-syntax-variable: #702c00;
  --color-prettylights-syntax-brackethighlighter-unmatched: #6e011a;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #6e011a;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #a0111f;
  --color-prettylights-syntax-string-regexp: #024c1a;
  --color-prettylights-syntax-markup-list: #2e1800;
  --color-prettylights-syntax-markup-heading: #023b95;
  --color-prettylights-syntax-markup-italic: #0e1116;
  --color-prettylights-syntax-markup-bold: #0e1116;
  --color-prettylights-syntax-markup-deleted-text: #6e011a;
  --color-prettylights-syntax-markup-deleted-bg: #fff0ee;
  --color-prettylights-syntax-markup-inserted-text: #024c1a;
  --color-prettylights-syntax-markup-inserted-bg: #d2fedb;
  --color-prettylights-syntax-markup-changed-text: #702c00;
  --color-prettylights-syntax-markup-changed-bg: #ffc67b;
  --color-prettylights-syntax-markup-ignored-text: #e7ecf0;
  --color-prettylights-syntax-markup-ignored-bg: #023b95;
  --color-prettylights-syntax-meta-diff-range: #622cbc;
  --color-prettylights-syntax-brackethighlighter-angle: #4b535d;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #88929d;
  --color-prettylights-syntax-constant-other-reference-link: #032563;
  --color-fg-default: #0e1116;
  --color-fg-muted: #0e1116;
  --color-fg-subtle: #66707b;
  --color-canvas-default: #ffffff;
  --color-canvas-subtle: #e7ecf0;
  --color-border-default: #20252c;
  --color-border-muted: #88929d;
  --color-neutral-muted: rgba(172,182,192,0.2);
  --color-accent-fg: #0349b4;
  --color-accent-emphasis: #0349b4;
  --color-attention-subtle: #fcf7be;
  --color-danger-fg: #d1242f;
}
}

[data-color-mode=light][data-light-theme=dark],
[data-color-mode=dark][data-dark-theme=dark],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark] {
  /*dark*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #7ee787;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa657;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #7ee787;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #aff5b4;
  --color-prettylights-syntax-markup-inserted-bg: #033a16;
  --color-prettylights-syntax-markup-changed-text: #ffdfb6;
  --color-prettylights-syntax-markup-changed-bg: #5a1e02;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #e6edf3;
  --color-fg-muted: #7d8590;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #2f81f7;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_dimmed],
[data-color-mode=dark][data-dark-theme=dark_dimmed],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_dimmed],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_dimmed] {
  /*dark_dimmed*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #768390;
  --color-prettylights-syntax-constant: #6cb6ff;
  --color-prettylights-syntax-entity: #dcbdfb;
  --color-prettylights-syntax-storage-modifier-import: #adbac7;
  --color-prettylights-syntax-entity-tag: #8ddb8c;
  --color-prettylights-syntax-keyword: #f47067;
  --color-prettylights-syntax-string: #96d0ff;
  --color-prettylights-syntax-variable: #f69d50;
  --color-prettylights-syntax-brackethighlighter-unmatched: #e5534b;
  --color-prettylights-syntax-invalid-illegal-text: #cdd9e5;
  --color-prettylights-syntax-invalid-illegal-bg: #922323;
  --color-prettylights-syntax-carriage-return-text: #cdd9e5;
  --color-prettylights-syntax-carriage-return-bg: #ad2e2c;
  --color-prettylights-syntax-string-regexp: #8ddb8c;
  --color-prettylights-syntax-markup-list: #eac55f;
  --color-prettylights-syntax-markup-heading: #316dca;
  --color-prettylights-syntax-markup-italic: #adbac7;
  --color-prettylights-syntax-markup-bold: #adbac7;
  --color-prettylights-syntax-markup-deleted-text: #ffd8d3;
  --color-prettylights-syntax-markup-deleted-bg: #78191b;
  --color-prettylights-syntax-markup-inserted-text: #b4f1b4;
  --color-prettylights-syntax-markup-inserted-bg: #1b4721;
  --color-prettylights-syntax-markup-changed-text: #ffddb0;
  --color-prettylights-syntax-markup-changed-bg: #682d0f;
  --color-prettylights-syntax-markup-ignored-text: #adbac7;
  --color-prettylights-syntax-markup-ignored-bg: #255ab2;
  --color-prettylights-syntax-meta-diff-range: #dcbdfb;
  --color-prettylights-syntax-brackethighlighter-angle: #768390;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #545d68;
  --color-prettylights-syntax-constant-other-reference-link: #96d0ff;
  --color-fg-default: #adbac7;
  --color-fg-muted: #768390;
  --color-fg-subtle: #636e7b;
  --color-canvas-default: #22272e;
  --color-canvas-subtle: #2d333b;
  --color-border-default: #444c56;
  --color-border-muted: #373e47;
  --color-neutral-muted: rgba(99,110,123,0.4);
  --color-accent-fg: #539bf5;
  --color-accent-emphasis: #316dca;
  --color-attention-subtle: rgba(174,124,20,0.15);
  --color-danger-fg: #e5534b;
}
}

[data-color-mode=light][data-light-theme=dark_colorblind],
[data-color-mode=dark][data-dark-theme=dark_colorblind],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_colorblind],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_colorblind] {
  /*dark_colorblind*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ec8e2c;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #fdac54;
  --color-prettylights-syntax-brackethighlighter-unmatched: #d47616;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #6c3906;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #914d04;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffe2bb;
  --color-prettylights-syntax-markup-deleted-bg: #4e2906;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffe2bb;
  --color-prettylights-syntax-markup-changed-bg: #4e2906;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #d47616;
}
}

[data-color-mode=light][data-light-theme=dark_tritanopia],
[data-color-mode=dark][data-dark-theme=dark_tritanopia],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_tritanopia],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_tritanopia] {
  /*dark_tritanopia*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #8b949e;
  --color-prettylights-syntax-constant: #79c0ff;
  --color-prettylights-syntax-entity: #d2a8ff;
  --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
  --color-prettylights-syntax-entity-tag: #a5d6ff;
  --color-prettylights-syntax-keyword: #ff7b72;
  --color-prettylights-syntax-string: #a5d6ff;
  --color-prettylights-syntax-variable: #ffa198;
  --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
  --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
  --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
  --color-prettylights-syntax-carriage-return-text: #f0f6fc;
  --color-prettylights-syntax-carriage-return-bg: #b62324;
  --color-prettylights-syntax-string-regexp: #a5d6ff;
  --color-prettylights-syntax-markup-list: #f2cc60;
  --color-prettylights-syntax-markup-heading: #1f6feb;
  --color-prettylights-syntax-markup-italic: #c9d1d9;
  --color-prettylights-syntax-markup-bold: #c9d1d9;
  --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
  --color-prettylights-syntax-markup-deleted-bg: #67060c;
  --color-prettylights-syntax-markup-inserted-text: #cae8ff;
  --color-prettylights-syntax-markup-inserted-bg: #0c2d6b;
  --color-prettylights-syntax-markup-changed-text: #ffdcd7;
  --color-prettylights-syntax-markup-changed-bg: #67060c;
  --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
  --color-prettylights-syntax-markup-ignored-bg: #1158c7;
  --color-prettylights-syntax-meta-diff-range: #d2a8ff;
  --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
  --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
  --color-fg-default: #c9d1d9;
  --color-fg-muted: #8b949e;
  --color-fg-subtle: #6e7681;
  --color-canvas-default: #0d1117;
  --color-canvas-subtle: #161b22;
  --color-border-default: #30363d;
  --color-border-muted: #21262d;
  --color-neutral-muted: rgba(110,118,129,0.4);
  --color-accent-fg: #58a6ff;
  --color-accent-emphasis: #1f6feb;
  --color-attention-subtle: rgba(187,128,9,0.15);
  --color-danger-fg: #f85149;
}
}

[data-color-mode=light][data-light-theme=dark_high_contrast],
[data-color-mode=dark][data-dark-theme=dark_high_contrast],
.vscode-body.vscode-light [data-color-mode=auto][data-light-theme=dark_high_contrast],
.vscode-body.vscode-dark [data-color-mode=auto][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
@media (prefers-color-scheme: light) {
  [data-color-mode='system'][data-light-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

@media (prefers-color-scheme: dark) {
  [data-color-mode='system'][data-dark-theme=dark_high_contrast] {
  /*dark_high_contrast*/
  color-scheme: dark;
  --color-prettylights-syntax-comment: #bdc4cc;
  --color-prettylights-syntax-constant: #91cbff;
  --color-prettylights-syntax-entity: #dbb7ff;
  --color-prettylights-syntax-storage-modifier-import: #f0f3f6;
  --color-prettylights-syntax-entity-tag: #72f088;
  --color-prettylights-syntax-keyword: #ff9492;
  --color-prettylights-syntax-string: #addcff;
  --color-prettylights-syntax-variable: #ffb757;
  --color-prettylights-syntax-brackethighlighter-unmatched: #ff6a69;
  --color-prettylights-syntax-invalid-illegal-text: #ffffff;
  --color-prettylights-syntax-invalid-illegal-bg: #e82a2f;
  --color-prettylights-syntax-carriage-return-text: #ffffff;
  --color-prettylights-syntax-carriage-return-bg: #ff4445;
  --color-prettylights-syntax-string-regexp: #72f088;
  --color-prettylights-syntax-markup-list: #fbd669;
  --color-prettylights-syntax-markup-heading: #409eff;
  --color-prettylights-syntax-markup-italic: #f0f3f6;
  --color-prettylights-syntax-markup-bold: #f0f3f6;
  --color-prettylights-syntax-markup-deleted-text: #ffdedb;
  --color-prettylights-syntax-markup-deleted-bg: #cc1421;
  --color-prettylights-syntax-markup-inserted-text: #acf7b6;
  --color-prettylights-syntax-markup-inserted-bg: #007728;
  --color-prettylights-syntax-markup-changed-text: #ffe1b4;
  --color-prettylights-syntax-markup-changed-bg: #a74c00;
  --color-prettylights-syntax-markup-ignored-text: #f0f3f6;
  --color-prettylights-syntax-markup-ignored-bg: #318bf8;
  --color-prettylights-syntax-meta-diff-range: #dbb7ff;
  --color-prettylights-syntax-brackethighlighter-angle: #bdc4cc;
  --color-prettylights-syntax-sublimelinter-gutter-mark: #7a828e;
  --color-prettylights-syntax-constant-other-reference-link: #addcff;
  --color-fg-default: #f0f3f6;
  --color-fg-muted: #f0f3f6;
  --color-fg-subtle: #9ea7b3;
  --color-canvas-default: #0a0c10;
  --color-canvas-subtle: #272b33;
  --color-border-default: #7a828e;
  --color-border-muted: #7a828e;
  --color-neutral-muted: rgba(158,167,179,0.4);
  --color-accent-fg: #71b7ff;
  --color-accent-emphasis: #409eff;
  --color-attention-subtle: rgba(224,155,19,0.15);
  --color-danger-fg: #ff6a69;
}
}

/*!
  Theme: GitHub
  Description: Highlight-js port of github.com theme
  Author: github.com
  Maintainer: @SNDST00M, @mjbvz
  Updated: 2021-12-08
*/
.markdown-body pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 16px;
}

.markdown-body code.hljs {
  padding: 3px 5px;
}

/*!
  Theme: GitHub
  Description: Theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.markdown-body .hljs {
  color: var(--color-fg-default);
  background: var(--color-canvas-subtle);
}

.markdown-body .hljs-doctag,
.markdown-body .hljs-keyword,
.markdown-body .hljs-meta .hljs-keyword,
.markdown-body .hljs-template-tag,
.markdown-body .hljs-template-variable,
.markdown-body .hljs-type,
.markdown-body .hljs-variable.language_ {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .hljs-title,
.markdown-body .hljs-title.class_,
.markdown-body .hljs-title.class_.inherited__,
.markdown-body .hljs-title.function_ {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .hljs-attr,
.markdown-body .hljs-attribute,
.markdown-body .hljs-literal,
.markdown-body .hljs-meta,
.markdown-body .hljs-number,
.markdown-body .hljs-operator,
.markdown-body .hljs-selector-attr,
.markdown-body .hljs-selector-class,
.markdown-body .hljs-selector-id,
.markdown-body .hljs-variable {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-meta .hljs-string,
.markdown-body .hljs-regexp,
.markdown-body .hljs-string {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .hljs-built_in,
.markdown-body .hljs-symbol {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .hljs-code,
.markdown-body .hljs-comment,
.markdown-body .hljs-formula {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .hljs-name,
.markdown-body .hljs-quote,
.markdown-body .hljs-selector-pseudo,
.markdown-body .hljs-selector-tag {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .hljs-subst {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .hljs-section {
  color: var(--color-prettylights-syntax-markup-heading);
  font-weight: bold;
}

.markdown-body .hljs-bullet {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .hljs-emphasis {
  color: var(--color-prettylights-syntax-constant);
  font-style: italic;
}

.markdown-body .hljs-strong {
  color: var(--color-prettylights-syntax-constant);
  font-weight: bold;
}

.markdown-body .hljs-addition {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .hljs-deletion {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <div
            class="github-markdown-body"
            data-color-mode="auto"
            data-light-theme="light"
            data-dark-theme="dark"
        >
            <div class="github-markdown-content"><h1 id="6hafta">6.Hafta</h1>
<blockquote>
<p>10_29_07_2023</p>
</blockquote>
<h2 id="i̇çindekiler">İçindekiler</h2>
<ul>
<li><a href="#6hafta">6.Hafta</a>
<ul>
<li><a href="#i%CC%87%C3%A7indekiler">İçindekiler</a></li>
<li><a href="#ctad-class-template-argument-deduction">CTAD: Class Template Argument Deduction</a>
<ul>
<li><a href="#deduction-guide">Deduction Guide</a></li>
</ul>
</li>
<li><a href="#structure-binding">Structure Binding</a>
<ul>
<li><a href="#diziler-i%C3%A7in">Diziler için</a></li>
<li><a href="#s%C4%B1n%C4%B1flar-i%C3%A7in">Sınıflar için</a></li>
<li><a href="#tuple-interfacei-ile">Tuple Interface'i ile</a></li>
<li><a href="#kendi-s%C4%B1n%C4%B1flar%C4%B1m%C4%B1z-i%CC%87le">Kendi Sınıflarımız İle</a></li>
</ul>
</li>
<li><a href="#spaceship-operator">Spaceship Operator</a></li>
</ul>
</li>
</ul>
<h2 id="ctad-class-template-argument-deduction">CTAD: Class Template Argument Deduction</h2>
<ul>
<li>Aslında C++17 dile eklenen sınıf şablonları için bir tür çıkarımının yapılması. Artık C++17 ile sınıf şablonları içinde bir tür çıkarımı sağlanıyor.</li>
<li>
<ul>
<li>Çıkarımın yapılmasını sağlamak veya derleyici yönlendirmek için <code>deduction guide</code> dile eklendi. User-type sınıflar içinde bu çıkarımı yapabiliyoruz.</li>
</ul>
</li>
<li>Kodların yazımını ve okunmasını kolaylaştırıyor.</li>
<li>Kod kalabalığını azaltmak için daha önceden fabrika fonksiyonu kullanılıyordu.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// pair&lt;int, int&gt; çıkarımı fonksiyon için yapılabiliyor.</span>
}
</code></pre>
<ul>
<li>Artık make_pair'i kullanmak yerine CTAD'dan faydalanılabilir.</li>
<li>Derleyici consturctorlara bakarak tür çıkarımı yapabiliyor. Hom type hem de non-type parametreleri için bu çıkarım yapılabiliri.</li>
<li>Aggregat sınıflar için de bu çıkarım yapılabilir. Burada C++20 ile bazı farklılıklar oluştu.</li>
<li>CTAD'ın constructor'ın explicit olup olmaması çıkarımı ekliyor</li>
<li>Argümanların sınıf türünden olmasında da bir sakınca yok.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> T&amp; x) : mx{x}{
        std::cout &lt;&lt;  <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    T mx;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">Myclass&lt;T&gt; <span class="hljs-title">make_myclass</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span>
</span>{
    <span class="hljs-keyword">return</span> Myclass&lt;T&gt;{x};
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass&lt;<span class="hljs-type">int</span>&gt; x{<span class="hljs-number">12</span>}; <span class="hljs-comment">// C++17&#x27;den önce bu şekilde yazılıyordu.</span>
    <span class="hljs-keyword">auto</span> mx = make_myclass{<span class="hljs-number">20</span>}; <span class="hljs-comment">/// CTAD olmadığından dolayı bu şekilde yazılıyor.</span>
   <span class="hljs-function">Myclass <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">12</span>)</span></span>;  
}
</code></pre>
<ul>
<li>Çıkarımlar daha complex senaryolarla da yapılabilir.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> U&amp; y) : mx{x}, my{y}{
        std::cout &lt;&lt;  <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt;  <span class="hljs-built_in">typeid</span>(U).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    T mx;
    U my;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass x{<span class="hljs-number">12</span>, <span class="hljs-number">5.24</span>}; <span class="hljs-comment">// C++17&#x27;den önce bu şekilde yazılıyordu.</span>
    <span class="hljs-keyword">auto</span> mx = Myclass{<span class="hljs-number">20</span>, <span class="hljs-number">5</span>};
    <span class="hljs-function">Myclass <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;denem&quot;</span>)</span></span>;
}
</code></pre>
<ul>
<li>Örneğin array sınıfını sarmalayan bir template sınıf çıkarımı.</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-built_in">T</span>(&amp;)[N])
    {
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt; <span class="hljs-string">&quot;constant N is&quot;</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]();
    <span class="hljs-comment">//Myclass&lt;int,10&gt; myclass(a);</span>
    <span class="hljs-function">Myclass <span class="hljs-title">myclass2</span><span class="hljs-params">(a)</span></span>;
    <span class="hljs-type">double</span> a[]{<span class="hljs-number">1.</span>,<span class="hljs-number">3.</span>,<span class="hljs-number">5.</span>,<span class="hljs-number">7.</span>,<span class="hljs-number">9.</span>};
    Myclass 
}
</code></pre>
<ul>
<li>Function pointer ile de kullanılabilir. Geri dönüş değeri T türü olan ve parametresi dizeye referans olan bir function pointer</li>
</ul>
<pre><code class="language-cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, std::<span class="hljs-type">size_t</span> N&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-built_in">T</span>(*)(<span class="hljs-built_in">U</span>(&amp;)[N]))
    {
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(U).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt; <span class="hljs-string">&quot;constant N is&quot;</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>(&amp;)[<span class="hljs-number">20</span>])</span></span>{<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{    
    <span class="hljs-function">Myclass <span class="hljs-title">my</span><span class="hljs-params">(foo)</span></span>;
}
</code></pre>
<ul>
<li>Default argümandan da yararlanabiliyoruz. Birden fazla default argüman içinde bundan yararlanabiliyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">double</span>&gt;
<span class="hljs-keyword">struct</span> Myclass
{
    <span class="hljs-built_in">Myclass</span>() :<span class="hljs-built_in">val</span>(){}
    <span class="hljs-built_in">Myclass</span>(T x = <span class="hljs-number">0</span>) : mx{x} {}
    T mx;
};

Myclass m1{<span class="hljs-number">19</span>};
Myclass m2;  <span class="hljs-comment">// Myclass&lt;double&gt; m2;</span>
</code></pre>
<blockquote>
<p><code>T{}</code> eğer sınıf türleri ise default ctor çağırılır, eğer aritmetik türlerden bir tür ise 0 ile başlatılır.</p>
</blockquote>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">double</span>, <span class="hljs-keyword">typename</span> U = <span class="hljs-type">int</span>, <span class="hljs-keyword">typename</span> W = <span class="hljs-type">long</span>&gt;
<span class="hljs-keyword">class</span> Myclass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(T x = T{}, U y = U{}, W z = W{}) : mx{x}, my{y}, mz{z} {}
    T mx;
    U my;
    W mz;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m1{<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>}; <span class="hljs-comment">// Myclass&lt;int, int, int&gt; m1{12, 5, 7};</span>
    Myclass m2; <span class="hljs-comment">// Myclass&lt;double, int, long&gt; m2;</span>
}
</code></pre>
<ul>
<li>Çıkarım yapılırken ilk parametre için çıkarım yapılsın fakat ikinci parametreyi kullanayım gibi bir sentaks yok.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> N &gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Array</span>
{};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    std::array a{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>};
    <span class="hljs-comment">//std::array&lt;&gt; a{1,3,4,5,6,6};</span>
}
</code></pre>
<ul>
<li>standart kütüphanenin örnekleri</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>}; <span class="hljs-comment">// vector&lt;int&gt; v{1,2,3,4,5,6,7,8,9,10};</span>
    list l{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>}; <span class="hljs-comment">// list&lt;int&gt; l{1,2,3,4,5,6,7,8,9,10};</span>
    set s{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>}; <span class="hljs-comment">// set&lt;int&gt; s{1,2,3,4,5,6,7,8,9,10};</span>
    set s2{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>}, [](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b){<span class="hljs-keyword">return</span> b&lt;a;}; <span class="hljs-comment">//</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(F f) : mf{f} {
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(F).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
    F mf;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m{std::less&lt;<span class="hljs-type">int</span>&gt;{}}; 
    <span class="hljs-comment">// Myclass&lt;lambda&gt; m{[](int x, int y){return x + y;}};</span>
}
</code></pre>
<ul>
<li>Joustis örneği</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountCalls</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">CountCalls</span>(T f) : mf{f} {}
    T mf;
    <span class="hljs-type">int</span> count{};
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Args&amp;&amp;... args)</span>
    </span>{
        ++count;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mf</span>(std::forward&lt;Args&gt;(args)...);
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> count; }
<span class="hljs-keyword">private</span>:
    T mf;
    <span class="hljs-type">int</span> count{};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt;msvec;
    <span class="hljs-built_in">rfill</span>(mvec,<span class="hljs-number">10000</span>,rname);
    <span class="hljs-keyword">auto</span> f = CountCalls{[](<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">const</span> string y){<span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &lt; y.<span class="hljs-built_in">size</span>();}};    
    <span class="hljs-built_in">sort</span>(mvec.<span class="hljs-built_in">begin</span>(),mvec.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">ref</span>(f));
    <span class="hljs-comment">//ref fonksiyonu </span>
    cout&lt;&lt; <span class="hljs-string">&quot;f.count() = &quot;</span> &lt;&lt; f.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-comment">// Myclass&lt;lambda&gt; m{[](int x, int y){return x + y;}};</span>
}
</code></pre>
<ul>
<li>
<p>Buradaki ref neden kullanıldı? Algoritmalara bunu gönderirken kopyalama oluşmamasını istiyoruz. Ve bizim gönderdiğimiz nesnenin coun'tu arttırmazdı.</p>
</li>
<li>
<p>Bazı templeatelerde fonksiyonun parrmetresi referans değil ve bu fonksiyonlara storage küçük bir nesne gönderdiğimizde kopyalanabiliyor fakat burada büyük nesneler için kopylama yapmak istemiyoruz.</p>
</li>
<li>
<ul>
<li>Fonksiyon şablonundan oluşturulmuş fonksiyonun referans olmasını istiyoruz ve bunu reference wrapper ile sağlayabiliriz.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pred</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-type">const</span>
    </span>{}
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> ma[<span class="hljs-number">1024</span>]; <span class="hljs-comment">//her kopyalama da bu dizi de kopyalama olucaks</span>
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">find_if</span>(); <span class="hljs-comment">//3.parametresi referans değil.</span>
    Pred mypred;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">100&#x27;000</span>)</span></span>;
    <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">find_if</span>(ivec.<span class="hljs-built_in">begin</span>(),ivec.<span class="hljs-built_in">end</span>(),mypred); <span class="hljs-comment">// kopyalama olucak</span>
}
</code></pre>
<ul>
<li>Pred nesnesi fonksiyonun parametre değişkenine kopyalanacak.</li>
<li><code>for_each</code> algoritmasının geri dönüş değeri callable. 3.parametresi callable ve range'teki üyeleri callable'a gönderiyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span>
{
pulbic:
    <span class="hljs-built_in">Functor</span>(<span class="hljs-type">int</span> val) : mval{val} {}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-type">const</span>
    </span>{
        <span class="hljs-keyword">if</span>(x &gt; mval)
            ++m_count;
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_count; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> mval;
    <span class="hljs-type">int</span> m_count{};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">100&#x27;000</span>)</span></span>;
    <span class="hljs-built_in">rfill</span>(ivec,<span class="hljs-number">20&#x27;000</span>, <span class="hljs-built_in">Irand</span>(<span class="hljs-number">0</span>,<span class="hljs-number">100&#x27;000</span>));    
    <span class="hljs-keyword">auto</span> f = for_each(ivec.<span class="hljs-built_in">begin</span>(),ivec.<span class="hljs-built_in">end</span>(),Functor{<span class="hljs-number">90&#x27;000</span>});
    cout &lt;&lt; <span class="hljs-string">&quot;f.count() = &quot;</span> &lt;&lt; f.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>
<ul>
<li>Genel olarak yazma algoritmaları genellikle yazdığı konumdan sonraki konumu döndürüyor.</li>
</ul>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">100&#x27;000</span>)</span></span>;
    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ilist</span><span class="hljs-params">(<span class="hljs-number">100&#x27;000</span>)</span></span>;
    <span class="hljs-keyword">auto</span> end_iter = for_each(ivec.<span class="hljs-built_in">begin</span>(),ivec.<span class="hljs-built_in">end</span>(),Functor{<span class="hljs-number">90&#x27;000</span>});
    <span class="hljs-comment">// ivec.begin() + 100000</span>
    <span class="hljs-comment">//liste yazılmış son konumu döndürüyor</span>
}
</code></pre>
<ul>
<li>Bazı durumlarda küme parantezi ile normal parantez kullanmak arasında fark var</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">100&#x27;000</span>)</span></span>;
    vector v2{v1};<span class="hljs-comment">//vector&lt;int&gt;</span>
    <span class="hljs-function">vector <span class="hljs-title">v3</span><span class="hljs-params">(v1,v1)</span></span>;<span class="hljs-comment">//vector&lt;vector&lt;int&gt;&gt;</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    list&lt;pair&lt;string,<span class="hljs-type">double</span>&gt;&gt; mylist = {{<span class="hljs-string">&quot;ali&quot;</span>,<span class="hljs-number">12.5</span>},{<span class="hljs-string">&quot;veli&quot;</span>,<span class="hljs-number">15.5</span>},{<span class="hljs-string">&quot;selami&quot;</span>,<span class="hljs-number">20.5</span>}};
    <span class="hljs-comment">//vector v1(mylist.rbegin(),mylist.rend());</span>
    vector v1{mylist.<span class="hljs-built_in">rbegin</span>(),mylist.<span class="hljs-built_in">rend</span>()}; <span class="hljs-comment">// vector&lt;iterator&gt; açılımı oluyor</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[name, wage] : v1)
        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; wage &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>Std'de bazı kütüphanelerde CTAD kritik durum taşıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Complex</span><span class="hljs-params">(T&amp; re = T(), <span class="hljs-type">const</span> T&amp; im = T{})</span></span>;
<span class="hljs-keyword">private</span>:    
    T real;
    T imag;
};


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    complex c1{<span class="hljs-number">12.5</span>, <span class="hljs-number">5.5</span>}; <span class="hljs-comment">// complex&lt;double&gt; c1{12.5, 5.5}; Sınıf şablonunn</span>
    complex c1{<span class="hljs-number">12.5</span>};
    complex&lt;<span class="hljs-type">double</span>&gt; c3{<span class="hljs-number">4.5</span>};    
}
</code></pre>
<ul>
<li>Std::function bir callable'ı sarmalıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">double</span>)</span></span>;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Functor</span>
{
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;    
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    function f1{foo}; <span class="hljs-comment">// function&lt;int(int)&gt; f1{foo};</span>
    <span class="hljs-comment">//function&lt;int,int&gt; şeklinde yazılması lazımdı.</span>
    function f2{bar}; <span class="hljs-comment">// function&lt;double(double,double)&gt; f2{bar};</span>
    function f3{Functor{}}; <span class="hljs-comment">// function&lt;int(int)&gt; f3{Functor{}};</span>
    function f4{[](<span class="hljs-type">int</span> x){<span class="hljs-keyword">return</span> x;}}; <span class="hljs-comment">// function&lt;int(int)&gt; f4{[](int x){return x;}};</span>
}
</code></pre>
<ul>
<li>Bazı durumlarda çıkarım mekanizması yok.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-comment">//vector&lt;pair&gt;v1{{1,2},{3,4},{5,6}};   //burada bir çıkarım yapılmıyor.</span>
vector v2{{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},{<span class="hljs-number">3</span>,<span class="hljs-number">4</span>},{<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}}; <span class="hljs-comment">// burada bir çıkarım yapılıyor.</span>
</code></pre>
<ul>
<li>Specialization kullanılması CTAD kullanımını etkilemiyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    <span class="hljs-built_in">Myclass</span>(T x) : mx{x} {}
    T mx;
};

<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>&lt;<span class="hljs-type">int</span>&gt;
{
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span> x) : mx{x} {}
    <span class="hljs-type">int</span> mx;
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass x{<span class="hljs-number">123</span>};
}
</code></pre>
<h3 id="deduction-guide">Deduction Guide</h3>
<ul>
<li>Örneğin myclass için dizi çıkarımları int bir dizi için çıkarım <code>int[5]</code> şeklinde yapılıyor ve biz burada bu dizinin array decay ile pointer'a dönüşmesini istiyoruz.</li>
<li>Bu çıkarımı sadece T'türünün çıkarımının yapılması için kullanıyoruz. Constructor'ın referanslık durumu değişmiyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeTeller</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> T&amp; x) : mx{x} 
    {
        <span class="hljs-comment">//TypeTeller&lt;T&gt; t; bu sentaks hatası veriyor ve türü görmek için kullanabiliriz.</span>

    } <span class="hljs-comment">// Diziye dizi ile ilk değer vermek sentaks hatası oluyor bunun için </span>
    <span class="hljs-comment">//arrray decay uygulanmasını istiyoruz.</span>
<span class="hljs-keyword">private</span>:
    T mx;
};
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-comment">//&lt;Sınıfınismi&gt;(T) -&gt; &lt;Çıkarımın nasıl yapılmasını istiyorsak&gt;</span>
<span class="hljs-built_in">Myclass</span>(T) -&gt; Myclass&lt;T&gt;; <span class="hljs-comment">// </span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m{<span class="hljs-string">&quot;den&quot;</span>}; <span class="hljs-comment">//char [4] türünden bir nesne</span>
}
</code></pre>
<ul>
<li>Basit örnekler</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">typename</span> &lt;T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeTeller</span>;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> T&amp; x) : mx{x} 
    {
        TypeTeller&lt;T&gt; t; <span class="hljs-comment">// bu sentaks hatası veriyor ve türü görmek için kullanabiliriz.</span>
    }
};
<span class="hljs-keyword">template</span> &lt;typenmae T&gt;
<span class="hljs-built_in">Myclass</span>(T) -&gt; Myclass&lt;T&amp;&gt;;
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">char</span>)-&gt;Myclass&lt;<span class="hljs-type">long</span>&gt;;
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">short</span>)-&gt;Myclass&lt;<span class="hljs-type">long</span>&gt;;
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span>)-&gt;Myclass&lt;<span class="hljs-type">long</span>&gt;;
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)-&gt;Myclass&lt;<span class="hljs-type">long</span>&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m{<span class="hljs-string">&#x27;a&#x27;</span>}; <span class="hljs-comment">//long</span>
    Myclass m2{<span class="hljs-number">12</span>}; <span class="hljs-comment">//long</span>
    Myclass m3{<span class="hljs-number">12u</span>}; <span class="hljs-comment">//long</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> T&amp; x) : mx{x} 
    {
    }
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-built_in">Myclass</span>(T) -&gt; Myclass&lt;T*&gt;;
<span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) -&gt; Myclass&lt;std::string&gt;; <span class="hljs-comment">// const char* türünün çıkarımını string olarak yapıyoruz.</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;
    Myclass m{x}; <span class="hljs-comment">// Myclass&lt;int*&gt;</span>
}
</code></pre>
<ul>
<li>Pair ve tuple içiin</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Pair</span>(<span class="hljs-type">const</span> T&amp; x, <span class="hljs-type">const</span> U&amp; y) : mx{x}, my{y} {}
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-title">Pair</span><span class="hljs-params">(T,U)</span> -&gt; Pair&lt;T,U&gt;</span>; <span class="hljs-comment">// bu sayede fonksiyon parametresi referans gödnerildiğinde dizi de çıkarım pointer olarak yapılıyor.</span>
</code></pre>
<ul>
<li>Tuple için</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuple</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Tuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Ts&amp;... args)</span> : mt{</span>args...} {}
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Us&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-title">Tuple</span><span class="hljs-params">(Us&amp;&amp;... args)</span> : mt{</span>std::forward&lt;Us&gt;(args)...} {}
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;
<span class="hljs-title">Tuple</span><span class="hljs-params">(Ts...)</span> -&gt; Tuple&lt;Ts...&gt;</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Tuple tx{<span class="hljs-number">42</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">nullptr</span>};
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sum</span>
{
    T value;
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-title">Sum</span><span class="hljs-params">(Args&amp;&amp;... args)</span> : value{</span>(args + ...)} {} <span class="hljs-comment">//argümanların tooplam değeri ile değerleri init ediyoruz.</span>
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ...Types&gt;
<span class="hljs-title">Sum</span><span class="hljs-params">(Types&amp;&amp; ...ts)</span> -&gt; Sum&lt;std::<span class="hljs-type">common_type_t</span>&lt;Types...&gt;&gt;</span>; <span class="hljs-comment">// argümanların türlerinin ortak türünü buluyoruz.</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Sum s{<span class="hljs-number">1u</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4.0f</span>};
    Sum strsum{std::string{<span class="hljs-string">&quot;ali&quot;</span>}, <span class="hljs-string">&quot;veli&quot;</span>};
    std::cout &lt;&lt; s.value &lt;&lt; strsum.value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>Vector'de range constructor'ı için aşağıdaki gibi bir çıkarım yapılıyor. vector'için <code>int*, int*</code> türünden bir parametre geçilirse çıkarımı <code>int</code> olarak yapılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">namespace</span> std
{
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator&gt;
    <span class="hljs-title">vector</span><span class="hljs-params">(InputIterator,InputIterator)</span> -&gt; vector&lt;<span class="hljs-keyword">typename</span> iterator_traits&lt;InputIterator&gt;::value_type&gt;</span>;
}
</code></pre>
<ul>
<li>Aggregate türlerin çıkarımı için aşağıdaki gibi bir initialization yok.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    T mx;
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-title">Myclass</span><span class="hljs-params">(T)</span> -&gt; Myclass&lt;T&gt;</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment">//Myclass&lt;int&gt; x1 = 10; C++ 17 ile aşağıdaki de sentaks hatası bunun için deduction guide vermemiz gerekiyor</span>
    <span class="hljs-comment">// Myclass mynec(20);</span>
    Myclass myclass = {<span class="hljs-number">20</span>};
}
</code></pre>
<ul>
<li>Aşağıdaki gibi bir çıkarım yapılamıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
clas Myclass
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">const</span> T&amp; x) : mx{x} {}
<span class="hljs-keyword">private</span>:
    T mx;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">Myclass <span class="hljs-title">myc</span><span class="hljs-params">(<span class="hljs-number">29</span>)</span></span>;
    <span class="hljs-comment">//Myclass *p = &amp;myc; sentaks hatası</span>
}
</code></pre>
<ul>
<li><code>explicit</code> olarak deduction guide verilebiliyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    T mx;
};
<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Myclass</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> -&gt; Myclass&lt;std::string&gt;</span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">Myclass <span class="hljs-title">myc</span><span class="hljs-params">(<span class="hljs-string">&quot;ali&quot;</span>)</span></span>;
    Myclass m = Myclass {<span class="hljs-string">&quot;ali&quot;</span>};
}
</code></pre>
<ul>
<li>Aşağıdaki örnekte explicit olarak veriilmiş, m için açılım Myclass'ın int* açılımı, sınıfın 2 constructorı var ve burada çağıralacak constructor U template parametresi olarak çıkarım yapılıyor.</li>
<li>Fakat buarada U'nun tür çıkarımı int olarak yapılıyor.</li>
<li></li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    <span class="hljs-built_in">Myclass</span>(T){std::cout &lt;&lt; <span class="hljs-string">&quot;ctor\n&quot;</span>;}
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Myclass</span><span class="hljs-params">(U)</span>
    </span>{
        std::cout &lt;&lt; <span class="hljs-string">&quot;uctor\n&quot;</span>;
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(U).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
        std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    }
};
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">explicit</span> <span class="hljs-title">Myclass</span><span class="hljs-params">(T)</span> -&gt; Myclass&lt;T*&gt;</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m{<span class="hljs-number">12</span>}; <span class="hljs-comment">// Myclass&lt;int*&gt; deduction guide</span>
    Myclass p2 = <span class="hljs-number">52</span>; <span class="hljs-comment">// Myclass&#x27;ın int açılımı</span>
    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>; 
    Myclass p3{&amp;i}; <span class="hljs-comment">// Deduction guide devreye girecek ve Myclass&lt;int**&gt; olacak</span>
    Myclass p4 = &amp;i; <span class="hljs-comment">// Myclass&lt;int*&gt; olacak</span>
}
</code></pre>
<h2 id="structure-binding">Structure Binding</h2>
<p>Bir dizi için, öğeleri tamemen public olan bir sınıf için ve tuple için kullanılabilir.</p>
<ul>
<li>Bu türden nesnelerin öğelerine daha yüksek verimle ayrıştırılmasını sağlamak.</li>
<li>Aşağıdaki fonksiyonun first ve second'ını kullanmak istiyoruz.r</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> {<span class="hljs-number">12</span>, <span class="hljs-number">5</span>};
}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{

    <span class="hljs-type">int</span> ival{};
    <span class="hljs-type">double</span> dval{};
    std::string sval{<span class="hljs-string">&quot;deneme&quot;</span>};
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> [x,y] = <span class="hljs-built_in">foo</span>();
    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-type">int</span> ar[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">auto</span> [a1,a2,a3] = ar;
    Myclass m;
    <span class="hljs-keyword">auto</span> [i,d,s] = m;
}
</code></pre>
<p><strong>Sentaksı</strong>:</p>
<ul>
<li><code>auto</code> keyword'ü mecburu, referans deklaratörü olabilir ya da olmayabilir.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">auto</span> [x,y] = var;
<span class="hljs-keyword">auto</span> &amp;[x,y]( var);
<span class="hljs-keyword">auto</span> &amp;&amp;[x,y]{var};
</code></pre>
<ul>
<li>Aşağıdaki çıkarım her zaman eşittirin sağ tarafındaki nesne için yapılıyor. Bunun için istenmeyen öğeleri kullanılmayan öğeler için</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>
{
    <span class="hljs-type">int</span> x,y,z;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Point p1;
    <span class="hljs-keyword">auto</span> [x,y,_] = p1;
    <span class="hljs-comment">//auto [x,_,y] = p2; sentaks hatası aynı scopeta aynı isim bulunuyor.</span>
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    <span class="hljs-type">double</span> dval{};
    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>]{};
}
<span class="hljs-keyword">auto</span> [d,x] = mynec;
<span class="hljs-comment">//üretilen kod</span>
<span class="hljs-comment">/*
    Myclass __abc = mynec; kullanılan alias&#x27;lar
    d ==&gt; __abc.dval eşisim gibi oluyor.
    yine aynı şekilde derleyicinin oluşturduğu nesnenin a dizisini kullanıyoruz
    x ==&gt; __abc.a 
*/</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    is_same_v&lt;<span class="hljs-keyword">decltype</span>(x),<span class="hljs-type">int</span> *&gt; ;<span class="hljs-comment">//false    </span>
    is_same_v&lt;<span class="hljs-keyword">decltype</span>(x),<span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&gt; ;<span class="hljs-comment">//true</span>
}
</code></pre>
<ul>
<li>Her zaman öğe sayısı kullanılan yerdeki öğe sayısı ile aynı olmalıdır.</li>
</ul>
<h3 id="diziler-için">Diziler için</h3>
<ul>
<li>Eğer referans ile bağlıyorsak bu değerleri değiştirdiğimizde dizinin elemanın değerini değişitirmiş oluyoruz.:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">int</span> a[] = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>};
    <span class="hljs-keyword">auto</span> &amp;[e1,e2,e3] {a};
    ++e1;
    ++e2;
    ++e3;
    cout &lt;&lt;<span class="hljs-string">&quot; e1: &quot;</span>&lt;&lt; e1 &lt;&lt; <span class="hljs-string">&quot; e2: &quot;</span> &lt;&lt; e2 &lt;&lt; <span class="hljs-string">&quot; e3: &quot;</span> &lt;&lt; e3 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p><img src="file:////home/thecoder/workspace/NecatiErginCppStudy/Ders_Notlari_CO/IleriCPP/res/array-structure-binding.png" alt="alt text"></p>
<ul>
<li>Eğer <code>&amp;&amp;</code> deklaratörü kullanılsaydı:</li>
</ul>
<p><img src="file:////home/thecoder/workspace/NecatiErginCppStudy/Ders_Notlari_CO/IleriCPP/res/array-structure-binding-2.png" alt="alt text"></p>
<ul>
<li>Dizi döndüren fonksiyon</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get_array</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title">int</span><span class="hljs-params">(&amp;)</span>[3]
</span>{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">return</span> a;
}

<span class="hljs-built_in">int</span>(&amp;<span class="hljs-built_in">get_array_c</span>())[<span class="hljs-number">3</span>]
{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">return</span> a;
}

<span class="hljs-keyword">using</span> <span class="hljs-type">ar3_t</span> = <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];

<span class="hljs-function"><span class="hljs-type">ar3_t</span>&amp; <span class="hljs-title">get_array_ref</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};
    <span class="hljs-keyword">return</span> a;
}


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">auto</span> [a,b,c] = <span class="hljs-built_in">get_array</span>();
    <span class="hljs-keyword">auto</span> [a1,b1,c1] = <span class="hljs-built_in">get_array_c</span>();
    <span class="hljs-keyword">auto</span> [a2,b2,c2] = <span class="hljs-built_in">get_array_ref</span>();
}
</code></pre>
<h3 id="sınıflar-için">Sınıflar için</h3>
<ul>
<li>
<p>Öğeleri public olan sınıflar için de kullanılabilir.</p>
</li>
<li>
<p>Aşağıdaki kod için sentaks hatası üyelerin private olması.</p>
</li>
</ul>
<pre><code class="language-c++">clsas Myclass
{
    <span class="hljs-type">int</span> a{<span class="hljs-number">10</span>};
    <span class="hljs-type">int</span> b{<span class="hljs-number">20</span>};
    <span class="hljs-type">int</span> c{<span class="hljs-number">30</span>};
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//ile sentaks hatasını çözebiliriz.</span>
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> [x,y,z] = Myclass{};
}
</code></pre>
<ul>
<li>Taşıma semantiğinden de faydalanabiliyioruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>:
    std::string mname{<span class="hljs-string">&quot;deneme&quot;</span>};
    std::string msurname{<span class="hljs-string">&quot;deneme surname&quot;</span>};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person p;
    <span class="hljs-keyword">auto</span> [name,surname] = p;
    cout &lt;&lt; p.name.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.msurname.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;

    <span class="hljs-keyword">auto</span> [nname,nsurname] = std::<span class="hljs-built_in">move</span>(ğ);
    cout &lt;&lt; p.name.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; p.msurname.<span class="hljs-built_in">length</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 0  0 taşıma semantiği </span>
}
</code></pre>
<h3 id="tuple-interfacei-ile">Tuple Interface'i ile</h3>
<pre><code class="language-c++"><span class="hljs-function">std::pair&lt;std::string, std::string&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    string s1;
    string s2;
    <span class="hljs-keyword">auto</span> ps = <span class="hljs-built_in">foo</span>();
    s1 = ps.first;
    s2 = ps.second;
}
</code></pre>
<ul>
<li>Burada s1,s2 default init edildi. Ve daha sonra copy-assignment fonksiyonu çağırııyordu. Burada bunu efektif yapmak için tie fonksiyonu kullanılıyor.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; tx{<span class="hljs-number">12</span>,<span class="hljs-number">5.5</span>,<span class="hljs-string">&quot;ali&quot;</span>};
    <span class="hljs-comment">//tuple da atamalar yapıldığında </span>
    tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,string&gt; ty;
    ty = tx; <span class="hljs-comment">//ty&#x27;nin öğeleri değerlerini tx&#x27;ten alıyorlar.</span>
    <span class="hljs-type">int</span> i;
    <span class="hljs-type">double</span> d;
    string s;
    <span class="hljs-function">tuple&lt;<span class="hljs-type">int</span> &amp; ,<span class="hljs-type">double</span> &amp; ,string&amp;&gt; <span class="hljs-title">tz</span><span class="hljs-params">(i,d,s)</span></span>;
    <span class="hljs-comment">//tz&#x27;nin öğeleri constructor&#x27;da gönderilen öğelere referans. Bu durumda bu tuple-nesnesine atama yapabiliyoruz.</span>
    tz = tx;     
    <span class="hljs-comment">//bunu isimlendirmeden aşağıdaki gibi de yazabiliriz.</span>
    tuple&lt;<span class="hljs-type">int</span> &amp; ,<span class="hljs-type">double</span> &amp; ,string&amp;&gt; = tx;

    <span class="hljs-comment">//bunun yerine bize bunu veren bir fabrika fonksiyonu var.</span>
    <span class="hljs-built_in">tie</span>(i,d,name) = tx;
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    vector&lt;string&gt; svec;
    <span class="hljs-built_in">rfill</span>(svec,<span class="hljs-number">20</span>,rname);
    <span class="hljs-built_in">print</span>(svec);
    <span class="hljs-keyword">auto</span> [min,max] = <span class="hljs-built_in">minmax_element</span>(svec.<span class="hljs-built_in">begin</span>(),svec.<span class="hljs-built_in">end</span>());
}
</code></pre>
<hr>
<blockquote>
<p>11_30_07_2023</p>
</blockquote>
<hr>
<ul>
<li>Container'da tuple tutmak</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">using</span> Person = std::tuple&lt;<span class="hljs-type">int</span>, std::string, s td::string&gt;

<span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()
{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    std::ofstream ofs{<span class="hljs-string">&quot;out.txt&quot;</span>};
    <span class="hljs-keyword">if</span>(!ofs)
    {
        std::cerr &lt;&lt; <span class="hljs-string">&quot;out.txt dosyasi olusturulamadi\n&quot;</span>;
        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
    }
    ofs.<span class="hljs-built_in">setf</span>(ios::left, ios::adjustfield);
    <span class="hljs-comment">//ofs &lt;&lt; left; //bu şekilde de yapılabilir. Fakat bu sadece ilk yazma işlemi için</span>
    vector&lt;Person&gt; pvec; <span class="hljs-comment">//pvec(10&#x27;000); vectorün fill constructor&#x27;ı 10&#x27;000 tane öğe ile başlatılıyor value initialize ediliyor.</span>
    pvec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10&#x27;000</span>); 
    cout &lt;&lt; pvec.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//kapasite 10&#x27;000 olmak zorunda değil minimal 10&#x27;000 olabilir.</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10&#x27;000</span>; ++i)
    {
        pvec.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Irand</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1000</span>)(),<span class="hljs-built_in">rname</span>() + <span class="hljs-string">&#x27; &#x27;</span>++ <span class="hljs-built_in">rfname</span>(),<span class="hljs-built_in">rtown</span>()); <span class="hljs-comment">//Irand, rname, rfname, rtown fonksiyonları yardımcı kütüphaneden geliyor</span>
    }
    cout &lt;&lt; pvec.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    
    <span class="hljs-built_in">sort</span>(pvec.<span class="hljs-built_in">begin</span>(),pvec.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//std::less kullanıldı.</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; per:pvec)
    {
        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(per) &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(per) &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(per) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [id,name,town]:pvec)
    {
        ofs &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">12</span>) &lt;&lt; id &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">12</span>) &lt;&lt; name &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; town &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    }
}
</code></pre>
<blockquote>
<p>tuple ve pair karşılaştırılması, pair için first'ler önce karşılaştırılıyor, eğer eşitse second'lar karşılaştırılıyor.
tuple içinse bunun çoklusu.</p>
</blockquote>
<ul>
<li>Structure binding sentaksa bağlı bir eklenti, range-based for loop gibi.</li>
<li>Type deduction öğenin kendisi için yapılıyor</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myclass</span>
{
    <span class="hljs-type">int</span> x;
    <span class="hljs-type">char</span> str[]{<span class="hljs-string">&quot;deneme&quot;</span>};
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Myclass m;
    <span class="hljs-keyword">auto</span> [i,s] = m;
    <span class="hljs-comment">//s pointer olsaydı </span>
    <span class="hljs-comment">//for (auto c : s)  sentaks hatası olmalıydo</span>
    <span class="hljs-comment">//for(auto c : m.str)</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)
        std::cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
}
</code></pre>
<ul>
<li>Aşağıdakki tuple kodunu örnek alarak inceleyelim:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">std::tuple <span class="hljs-title">mytuple</span><span class="hljs-params">(<span class="hljs-number">456</span>,std::string(<span class="hljs-string">&quot;deneme&quot;</span>))</span></span>;
    <span class="hljs-keyword">auto</span> &amp;[id,name] = mytuple;
    name = <span class="hljs-string">&quot;ali&quot;</span>;
    std::cout &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p>Derleyici, önce bizim doğrudan görmediğimiz bir değişken tanımlıyor. <code>auto &amp;a_hidden_variable= mytuplle;</code> burada ne int, ne de string nesnesi tanımlandı, direkt tuple nesnesi türünden bir referans oluşturuluyor. <code>std::tuple_size</code> meta-fonskyionu ile bu tuple türünün öğe sayısını derleme zamanında kontrol ediyor;</p>
<ul>
<li>Tuple için aşağıdaki gibi bir interface verildiğini biliyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-comment">//tuple interface için</span>
<span class="hljs-keyword">using</span> tptype = std::tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,<span class="hljs-type">long</span>&gt;;
tuple_size&lt;tptype&gt;::value; <span class="hljs-comment">//3u</span>
<span class="hljs-comment">// bunu yazmak ile tuple_size_v&lt;tptype&gt; aynı.</span>
<span class="hljs-comment">//tuple element ile 1.parametre öğenin yeri 2.parametre türü ise tuple&#x27;un kendisi.</span>
tuple_element&lt;<span class="hljs-number">0</span>,tptype&gt;::type; <span class="hljs-comment">//int burada bir tür elde etmiş oluyoruz. Bir int türü.</span>
<span class="hljs-comment">//bunu yazmak ile tıple_element_t&lt;0,tptype&gt; aynı.</span>

<span class="hljs-comment">//Run time&#x27;a yönelik bir de get interface&#x27;i var.</span>

<span class="hljs-comment">// Bu interface&#x27;i sadece tuple için değil, array&#x27;de veriyor, pair&#x27;de veriyor.</span>
</code></pre>
<ul>
<li>User-defined interface için de eğer bu tuple interface'ini implemente edilirse bu erişimi sağlayabiliriz.</li>
</ul>
<p><code>std::tuple_size_v&lt;std::remove_reference_t&lt;decltype(a_hidden_variable)&gt;&gt;</code>, Eğerr bu sayı 2 değil ise sentaks hatası verecek, bir sonraki aşamaya geçilmeyecek.
Burada şimdi derleyicinin <code>get&lt;&gt;</code> fonksiyonlarına çağrı yaparak <code>a_hidden_variable</code> öğelerine erişmesi gerekecek. Bunun için <code>std::get</code> fonksyionuna ya da sınıfın üye fonksiyonluna get'e çağrı yapması gerekecek.</p>
<p>Ama bu elemanlar birden fazla kez kullanılıyor ise aynı işlemler tekrar yapılmasın diye yine gizli değişkenler oluşturuluyor. Burada oluşturacağı değişkenlerin türü <code>tuple_element_t</code></p>
<p><code>std::tuple mytuple(456,std::string(&quot;deneme))</code>
<code>auto &amp;a_hidden_varialbe = mytuple;</code>
<code>std::tuple_element_t&lt;0,std::remove_reference_t&lt;decltype(a_hidden_variable)&gt;&gt;&amp; hidden_id = std::get&lt;0&gt;(mytuple);</code>
The type of the member with index 0, hidden_id is anonymous and Gets the value of element.
<code>std::tuple_element_t&lt;1,std::remove_reference_t&lt;decltype(a_hidden_variable)&gt;&gt;&amp; hidden_id = std::get&lt;1&gt;(mytuple);</code></p>
<ul>
<li>Böylece bu kod şu hale gelecek:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function">std::tuple <span class="hljs-title">mytuple</span><span class="hljs-params">(<span class="hljs-number">456</span>,std::string(<span class="hljs-string">&quot;deneme&quot;</span>))</span></span>;
<span class="hljs-keyword">auto</span> &amp;a_hidden_variable = mytuple;
<span class="hljs-type">int</span> &amp;hidden_id = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(mytuple);
std::string &amp;hidden_name = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(mytuple);
</code></pre>
<p>Buradaki değişkenler l-value reference: Böylece gereksiz kopyalamadan kaçınılıyor. get fonksiyonu L value reference döndürmeseydi ne olurdu?</p>
<ul>
<li>Derleyici bu durumda R value reference oluşturup geçici nesnelerin hayatlarını uzatırdı. Bundan sonra derleyici refeerans değişkenlere &quot;special identifiers&quot; olan id ve name isimlerini veriyor. Bu &quot;special identifiers&quot; hidden_id ve hidden_name isimlerine bağlanıyorlar ama gerçekte değişken değiller.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function">std::tuple <span class="hljs-title">mytuple</span><span class="hljs-params">(<span class="hljs-number">456</span>,std::string(<span class="hljs-string">&quot;deneme&quot;</span>))</span></span>;
<span class="hljs-keyword">auto</span> &amp;a_hidden_variable = mytuple;
</code></pre>
<ul>
<li>Structure binding ile <code>constexpr</code> kullanamıyoruz.</li>
</ul>
<h3 id="kendi-sınıflarımız-i̇le">Kendi Sınıflarımız İle</h3>
<p>Bu kullanım her zaman uygun olmayabilir. Bunu yapmak için</p>
<ul>
<li>tuple_size</li>
<li>tuple_element</li>
<li>Her bir öğe için get lazım</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>: 
     <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> id, <span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">double</span> wage) : m_id{id}, m_name{name}, m_wage{town} {}
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_id; }
    <span class="hljs-function">std::string <span class="hljs-title">get_name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_name; }
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_wage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_wage; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> m_id;
    std::string m_name;
    <span class="hljs-type">double</span> m_wage;
};

<span class="hljs-keyword">namespace</span> std
{
    <span class="hljs-keyword">template</span>&lt;&gt;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_size</span>&lt;Person&gt; : std::integral_constant&lt;std::<span class="hljs-type">size_t</span>,<span class="hljs-number">3</span>&gt; {};

    <span class="hljs-keyword">template</span>&lt;&gt;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_element</span>&lt;<span class="hljs-number">0</span>,Person&gt; {<span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>;};
    <span class="hljs-keyword">template</span>&lt;&gt;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_element</span>&lt;<span class="hljs-number">1</span>,Person&gt; {<span class="hljs-keyword">using</span> type = string;};
    <span class="hljs-keyword">template</span>&lt;&gt;  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_element</span>&lt;<span class="hljs-number">2</span>,Person&gt; {<span class="hljs-keyword">using</span> type = <span class="hljs-type">double</span>;};
}

<span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span> N&gt;
<span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(N == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">return</span> p.<span class="hljs-title">get_id</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>(N == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> p.<span class="hljs-built_in">get_name</span>();
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p.<span class="hljs-built_in">get_wage</span>();
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person per{<span class="hljs-number">12</span>,<span class="hljs-string">&quot;ali&quot;</span>, <span class="hljs-number">5000.0</span>};
    <span class="hljs-keyword">auto</span> [id,name,wage] = per;
    cout &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; wage &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>
{
<span class="hljs-keyword">private</span>:
    std::string m_name;
    std::string m_surname;
    <span class="hljs-type">long</span> value;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;surname, <span class="hljs-type">long</span> val) : m_name{name}, m_surname{surname}, value{val} {}
    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">firstname</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_name; }
    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">lastname</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> m_surname; }
    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> value; } 
};
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_size&lt;Customer&gt; 
{ <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> value = <span class="hljs-number">3</span>; };
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;<span class="hljs-number">2</span>, Customer&gt;
{ <span class="hljs-keyword">using</span> type = <span class="hljs-type">long</span>; };
<span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> Idx&gt;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::tuple_element&lt;Idx, Customer&gt;
{ <span class="hljs-keyword">using</span> type = std::string; };

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer &amp;c)</span>
</span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-number">0</span>==I)</span>
        <span class="hljs-keyword">return</span> c.<span class="hljs-title">firstname</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>( <span class="hljs-number">1</span> == I )
        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">lastame</span>();
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">value</span>();
        }
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;std::<span class="hljs-type">size_t</span> I&gt; <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">get</span><span class="hljs-params">(Customer &amp;&amp;c)</span>
</span>{
    <span class="hljs-built_in">static_assert</span>(I &lt; <span class="hljs-number">3</span>);
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-number">0</span>==I)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title">std::move</span><span class="hljs-params">(c.firstname())</span></span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span>( <span class="hljs-number">1</span> == I )
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(c.<span class="hljs-built_in">lastame</span>());
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(c.<span class="hljs-built_in">value</span>());
        }
}
</code></pre>
<h2 id="spaceship-operator">Spaceship Operator</h2>
<p>C++20 ile dile eklendi. Dilin core sentaksına yapılan bir ekleme</p>
<p><code>&lt;=&gt;</code> operatörü. Three-way comparision operatorü.</p>
<p>C++20 öncesinde karşılaştırma operatörleri şu şekildeydi:</p>
<ul>
<li><code>==</code>, <code>!=</code> equality operatörleri</li>
<li><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> relational operatörler</li>
</ul>
<p>Bu operatörlerinin hepsi aynı statüde ve biz bunların ikisine özel bir statü kazandırıyoruz. Buradaki problemlerin en önemlisi, <em>custom</em> türler söz konusu olduğu zaman tipik olarak overload edilirken &gt; ve !='i tanımla ve diğer operatörler bunları çağırsın.</p>
<p><img src="file:////home/thecoder/workspace/NecatiErginCppStudy/Ders_Notlari_CO/IleriCPP/res/karsilastirma.png" alt="alt text"></p>
<p>Bu durumda çağrı <code>a&lt;5</code> şeklinde yazılabilirken <code>5&gt;a</code> yazamıyorduk ve burada bu problem'i çözebilmek için hidden friend veriliyor, bazı durumlarda çok fazla kod yazılması gerekiyor ve örneğin gerçek sayı türlerinde bu semantik yapıya aykırı değer ya da değerler var.</p>
<pre><code class="language-c++">T x;
x == x; <span class="hljs-comment">//bu ifadenin yanlış olma değeri normalde yok gibi gözükse bile</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">double</span> dval{NAN};
    <span class="hljs-type">double</span> d2{<span class="hljs-number">4.56</span>};
    <span class="hljs-built_in">boolalpha</span>(cout);
    cout &lt;&lt; (dval == dval)&lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//falses</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &lt; d2 : &quot;</span> &lt;&lt; (dval &lt; d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//false</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &gt; d2 : &quot;</span> &lt;&lt; (dval &gt; d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//false</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &lt;= d2 : &quot;</span> &lt;&lt; (dval &lt;= d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//false</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &gt;= d2 : &quot;</span> &lt;&lt; (dval &gt;= d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//false</span>
    cout &lt;&lt; <span class="hljs-string">&quot;d1 == d2 : &quot;</span> &lt;&lt; (dval == d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//false</span>
    
    cout &lt;&lt; <span class="hljs-string">&quot;d1 != d2 : &quot;</span> &lt;&lt; (dval != d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//true </span>
}
</code></pre>
<ul>
<li>Artık yeni yapıyla çok daha az kod yazabiliyoruz. Tek bir fonksiyon ile bunu yapabiliyoruz.</li>
<li>Eğer boiler plate kod yapısı belli ise bu fonksiyonları derleyiciye yazdırabiliyoruz. Default edilebiliyor.</li>
<li>[[nodiscard]] attribute ile nitelendirilip nitelendirilmemiş olduğunu belirtmemiz gerekiyor. Bir fonksiyonun geri dönüş değerinin kullanılmaması durumunda uyarı vermesi için kullanıyor.</li>
</ul>
<p>Three-way-comparison ne deme: daha önce c kodunda olan <code>strcmp</code> fonksiyonu gibi bir fonksiyon. Aynı string fonksiyonlarının compare gibi fonksiyonları.</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string s1 = <span class="hljs-string">&quot;ali&quot;</span>;
    string s2 = <span class="hljs-string">&quot;veli&quot;</span>;
    cout &lt;&lt; s1.<span class="hljs-built_in">compare</span>(s2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">//s1 &gt; s2 ise 1, s1 &lt; s2 ise -1, eşitse 0 döndürüyor.</span>
}
</code></pre>
<ul>
<li>Bu fonksiyonlar karşılaşmanın kesin sonucunu elde ediliyor. Bu geri dönüş değeri eğer ret' 0 dan büyükse s1 büyük, 0'a eşitse bu değerler eşit, -1'den küçükse s2 büyük.</li>
</ul>
<p>Bu operatör de aynı sorgulamayı yapıyor ve bize karşılaştırmanın kesin sonucunu veriyor.</p>
<ul>
<li>Önceliği karşılaştırma operatörlerinden daha büyük</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    string s1 = <span class="hljs-string">&quot;ali&quot;</span>;
    string s2 = <span class="hljs-string">&quot;veli&quot;</span>;
    <span class="hljs-keyword">if</span>(s1&lt;=&gt;s2 &lt; <span class="hljs-number">0</span>)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;s1 &lt; s2\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1&lt;=&gt;s2 &gt; <span class="hljs-number">0</span>)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;s1 &gt; s2\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        cout &lt;&lt; <span class="hljs-string">&quot;s1 == s2\n&quot;</span>;
    }
}
</code></pre>
<ul>
<li>Farklı türlerde dile eklendi</li>
</ul>
<pre><code class="language-c++">
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T x, T y)</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(x&lt;=&gt;y).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-type">void</span> <span class="hljs-title">tprint</span><span class="hljs-params">()</span>
</span>{
    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T{} &lt;=&gt; T{}).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">tprint</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//strong ordering</span>
    <span class="hljs-built_in">tprint</span>&lt;<span class="hljs-type">double</span>&gt;(); <span class="hljs-comment">//partial ordering</span>
    <span class="hljs-built_in">tprint</span>&lt;std::string&gt;(); 
}
</code></pre>
<ul>
<li>Üretim kodu içerisinden ziyade sınıflar içerisinde kullanılıyor.</li>
</ul>
<p><img src="file:////home/thecoder/workspace/NecatiErginCppStudy/Ders_Notlari_CO/IleriCPP/res/space_ship.png" alt="alt text"></p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">int</span>)<span class="hljs-type">const</span>
    {
        std::cout &lt;&lt;<span class="hljs-string">&quot;A&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-type">bool</span> b1 = (m == <span class="hljs-number">5</span>);
    <span class="hljs-type">bool</span> b2 = (m != <span class="hljs-number">5</span>);
    <span class="hljs-type">bool</span> b3 = (<span class="hljs-number">5</span> == m);
    <span class="hljs-type">bool</span> b4 = (<span class="hljs-number">5</span> != m);
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Myclass</span>(<span class="hljs-type">int</span> x) : mx{x} {}
    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Myclass &amp;)<span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> mx;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    Myclass m1{<span class="hljs-number">10</span>}, m2 {<span class="hljs-number">20</span>};
    <span class="hljs-built_in">boolalpha</span>(cout);
    cout &lt;&lt; <span class="hljs-string">&quot;m1 &lt; m2 : &quot;</span> &lt;&lt; (m1 &lt; m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;m1 &lt;= m2 : &quot;</span> &lt;&lt; (m1 &lt;= m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;m1 &gt; m2 : &quot;</span> &lt;&lt; (m1 &gt; m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;m1 &gt;= m2 : &quot;</span> &lt;&lt; (m1 &gt;= m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;m1 == m2 : &quot;</span> &lt;&lt; (m1 == m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;m1 != m2 : &quot;</span> &lt;&lt; (m1 != m2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p>Eğer derleyici tarafından üretilen kodu bizim işimize yarıyorsa bunu default edebiliyoruz.</p>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> y) : md{d}, mm{m}, my{y} {}
    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Date &amp;)<span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> my,mm,md;
};
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    Date d1{<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2023</span>}, d2{<span class="hljs-number">15</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2023</span>};
    <span class="hljs-built_in">boolalpha</span>(cout);
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &lt; d2 : &quot;</span> &lt;&lt; (d1 &lt; d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &lt;= d2 : &quot;</span> &lt;&lt; (d1 &lt;= d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &gt; d2 : &quot;</span> &lt;&lt; (d1 &gt; d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;d1 &gt;= d2 : &quot;</span> &lt;&lt; (d1 &gt;= d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;d1 == d2 : &quot;</span> &lt;&lt; (d1 == d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;d1 != d2 : &quot;</span> &lt;&lt; (d1 != d2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<p>Burada tıpkı tuple'da olduğu gibi ilk öğeden başlıyarak karşılaştırılıyor.</p>
<ul>
<li>Bazı varlıklar için eşitlik ve eşdeğerlik açısından farklılık oluşturulabiliyor. Bir fonksiyona <code>x==y</code> durumunda x veya y'nin gönderilmesi aynı şey.</li>
<li>Bunun ortaya ters olduğu bir durum case insensitive. Örneğin <code>DENEME</code> ve <code>deneme</code> eşit olabilir.</li>
</ul>
<p>strong_ordering, weak_ordering, partial_ordering var.</p>
<p><code>a &lt;=&gt; b</code> ifadesinin türü yukarıdaki türlerden biri olmalı. Bunlar sınıf türleri ve <code>constexpr</code> türleri implementasyona bağlı fakat isimleri aynı:</p>
<p>Spaceship operatörü ile bir kaşılaştırma yapılıyorsa o tür strong_ordering, weak_ordering, partial_ordering türlerinden biri olmalı. Değerleri ise aşağıda verildiği gibi olmalı:</p>
<ul>
<li>
<p><code>strong_ordering::equal</code></p>
</li>
<li>
<p><code>strong_ordering::less</code></p>
</li>
<li>
<p><code>strong_ordering::greater</code></p>
</li>
<li>
<p><code>strong_ordering::equivalent</code></p>
</li>
<li>
<p><code>weak_ordering::equivalent</code></p>
</li>
<li>
<p><code>weak_ordering::less</code></p>
</li>
<li>
<p><code>weak_ordering::greater</code></p>
</li>
<li>
<p><code>partial_ordering::equivalent</code></p>
</li>
<li>
<p><code>partial_ordering::less</code></p>
</li>
<li>
<p><code>partial_ordering::greater</code></p>
</li>
<li>
<p><code>partial_ordering::unordered</code></p>
</li>
</ul>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-type">void</span> <span class="hljs-title">print_compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> U &amp;u)</span>
</span>{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-keyword">using</span> result_type = <span class="hljs-type">copare_three_way_result_t</span>&lt;T,U&gt;;
    string stype = <span class="hljs-built_in">typeid</span>(result_type).<span class="hljs-built_in">name</span>();
    cout &lt;&lt; <span class="hljs-string">&quot;compare result_type&quot;</span> &lt;&lt; stype &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-keyword">auto</span> result = t&lt;=&gt;u;

    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == result)
    {
        <span class="hljs-keyword">if</span>(is_same_v&lt;result_type, strong_ordering&gt;)
            cout &lt;&lt; <span class="hljs-string">&quot;equal\n&quot;</span>;
        <span class="hljs-keyword">else</span>
            cout &lt;&lt; <span class="hljs-string">&quot;equivalent\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result &lt; <span class="hljs-number">0</span>)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;less\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result &gt; <span class="hljs-number">0</span>)
    {
        cout &lt;&lt; <span class="hljs-string">&quot;greater\n&quot;</span>;
    }
    <span class="hljs-keyword">else</span> 
        cout &lt;&lt; <span class="hljs-string">&quot;unordered\n&quot;</span>;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">print_compare</span>(<span class="hljs-number">6.3</span>,<span class="hljs-number">6.39</span>);
    <span class="hljs-built_in">print_compare</span>(<span class="hljs-number">6.3</span>,NAN);
}
</code></pre>
<ul>
<li>String ordering'ten =&gt; weak_ordering'e ve partial_ordering'e dönüşebiliyor. Eğer bir kendi sınıfımız için bir <em>custom</em> fonksiyon yazarsak:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> a) : name{p}, age{a} {}
    <span class="hljs-comment">//auto operator&lt;=&gt;(const Person &amp;)const</span>
    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Person &amp;)<span class="hljs-type">const</span>
    <span class="hljs-comment">//std::weak_ordering operator&lt;=&gt;(const Person &amp;)const</span>
    <span class="hljs-comment">//std::partial_ordering operator&lt;=&gt;(const Person &amp;)const</span>
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = name&lt;=&gt;other.name; cmp != <span class="hljs-number">0</span>) <span class="hljs-comment">//cmp != 0 ise isimler eşit değil böylece string&#x27;in karşılaştırmasına bağlı oldu</span>
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">return</span> age&lt;=&gt;other.age;
    }
<span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-type">int</span> age;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person p1 {<span class="hljs-string">&quot;deneme&quot;</span>,    <span class="hljs-number">20</span>};
    Person p2 {<span class="hljs-string">&quot;mahmtu&quot;</span>,    <span class="hljs-number">25</span>};

    cout &lt;&lt; boolalpha &lt;&lt; (p1&lt;p2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>Aşağıdaki kodda sentaks hatası oluşuyor, çünkü <em>all return expression must deduce to the same type</em></li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> a,<span class="hljs-type">double</span> s) : name{p}, age{a},salary{s} {}
    <span class="hljs-comment">//auto operator&lt;=&gt;(const Person &amp;)const</span>
    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Person &amp;)<span class="hljs-type">const</span>
    <span class="hljs-comment">//std::weak_ordering operator&lt;=&gt;(const Person &amp;)const</span>
    <span class="hljs-comment">//std::partial_ordering operator&lt;=&gt;(const Person &amp;)const</span>
    { 
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = name&lt;=&gt;other.name; cmp != <span class="hljs-number">0</span>) <span class="hljs-comment">//cmp != 0 ise isimler eşit değil böylece string&#x27;in karşılaştırmasına bağlı oldu</span>
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = age&lt;=&gt;other.age; cmp != <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">return</span> salary&lt;=&gt;other.salary;
    }
<span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-type">int</span> age;
    <span class="hljs-type">double</span> salary;
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Person p1 {<span class="hljs-string">&quot;ayse&quot;</span>,    <span class="hljs-number">40</span>, <span class="hljs-number">60&#x27;000</span>};
    Person p2 {<span class="hljs-string">&quot;ayse&quot;</span>,    <span class="hljs-number">40</span>, <span class="hljs-number">10&#x27;000</span>};

    cout &lt;&lt; boolalpha &lt;&lt; (p1&lt;p2) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
}
</code></pre>
<ul>
<li>Burada bunu çözmek için birden fazla yöntem var. Biri return type'ı en düşük olanı seçmek. Trailing return ttype kullanmak.</li>
<li>Bunu veren type_trait kullanmak. Bunu compile time'da hesaplatabiliyoruz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>
{
<span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-type">double</span> salary;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Employee &amp;other)<span class="hljs-type">const</span>
    -&gt; std::<span class="hljs-type">common_comprasion_category_t</span>&lt;<span class="hljs-keyword">decltype</span>(mname &lt;=&gt;other.mname), <span class="hljs-keyword">decltype</span>(msalary &lt;=&gt;other.salary)&gt;
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = name&lt;=&gt;other.name; cmp != <span class="hljs-number">0</span>) <span class="hljs-comment">//cmp != 0 ise isimler eşit değil böylece string&#x27;in karşılaştırmasına bağlı oldu</span>
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">return</span> salary&lt;=&gt;other.salary;
    }
};
</code></pre>
<ul>
<li>Aşağıdaki gibi bir şekilde bunu kurtarabiliriz.</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>
{
<span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-type">double</span> salary;
<span class="hljs-keyword">public</span>:
    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Employee &amp;other)<span class="hljs-type">const</span>
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = name&lt;=&gt;other.name; cmp != <span class="hljs-number">0</span>) <span class="hljs-comment">//cmp != 0 ise isimler eşit değil böylece string&#x27;in karşılaştırmasına bağlı oldu</span>
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">auto</span> cmp = mwage &lt;=&gt; other.mwage;
        <span class="hljs-built_in">assert</span>(cmp != partial_ordering::unordered);
        <span class="hljs-keyword">return</span> comp == <span class="hljs-number">0</span> ? strong_ordering::equal : 
               cmp &gt; <span class="hljs-number">0</span> ? std::order::greater : std::order::less;
    }
};
</code></pre>
<ul>
<li>Fakat bunu yapan bir fonksiyon var:</li>
</ul>
<pre><code class="language-c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>
{
<span class="hljs-keyword">private</span>:
    std::string name;
    <span class="hljs-type">double</span> mwage;
<span class="hljs-keyword">public</span>:
    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Employee &amp;other)<span class="hljs-type">const</span>
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">auto</span> cmp = name&lt;=&gt;other.name; cmp != <span class="hljs-number">0</span>) <span class="hljs-comment">//cmp != 0 ise isimler eşit değil böylece string&#x27;in karşılaştırmasına bağlı oldu</span>
        {
            <span class="hljs-keyword">return</span> cmp;
        }
        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">strong_order</span>(mwage,other.mwage);
    }
};
</code></pre>
</div>
        </div>
            
            
        </body>
        </html>