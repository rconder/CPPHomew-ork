# 4.Hafta

## İçindekiler

- [4.Hafta](#4hafta)
  - [İçindekiler](#i̇çindekiler)
  - [Literal Operator Functions](#literal-operator-functions)
    - [Strong Types](#strong-types)
    - [Raw String Literal](#raw-string-literal)
    - [I/O Manip](#io-manip)
  - [string\_view Sınıf Şablonu](#string_view-sınıf-şablonu)
    - [Nasıl Construct Edilebilir?](#nasıl-construct-edilebilir)

## Literal Operator Functions

6.Derste anlatılan kısım [Literal Operator Functions](3.hafta.md#literal-operator-functions)

- Uncooked ve cooked ayrıştımrak için

```c++
#include "Date.h"

Date operator""_dt(const char* p);

Date operator""_dts(const char* p, std::size_t n) 
{
    std::puts(p);
    cout << "n = " << n << "\n";
    return {};
}

int main()
{
    //23051987_dt fonksiyonunu bir yazı olarak alsın
    Date dx = 23'05'1987_dt;  //Date dx = 23051987_dt;
    cout<<  "23-05-1987"_dts; 
}
```

Çoğunlukla `size_t` değerini kullanmıyoruz.

- Parametre `char` olabilir.

```c++
int operator""_i(char c)
{
    return static_cast<int>(c);
}

void operator""_pr(const char *p)
{
    std::cout << p << std::endl;
}

int main()
{
    'A'_i;
    34.56_pr;
    123498_pr;
}
```

```c++
constexpr std::string operator""_ds(const char *p, std::size_t)
{
    return std::string{p} +" " + p;
}

int main()
{
    using namespace std;
    auto str = "murat yilmaz"_ds;
    cout <<"|"<< str << "|\n";
}
```

Geri dönüş değeri için bir kısıtlama yok

```c++

std::vectır<char> operator""_vec(const char *p, std::size_t n)
{
    std::vector<char> ret(n);
    int i{};
    while(*p)
        ret[i++] = (*p++);
    return ret;
}

int main()
{
    auto vec = "ahahahahahah"_vec;
    std::cout << vec.size() << "\n";
    for (auto c :vec)
    {
        std::cout << c << " ";
    }
    std::cout << "\n";
}
```

### Strong Types

Bir çok programda gerçek sayı ve tam sayı türlerini daraltılmış bir konseptte kullanıyoruz. Bu kullanımların bazı sakıncaları var.

- Tür dönüşümleri kullanılan primitive türlere göre yapılacak ve kullanım amacımızı anlaması zorlaşıcak örneğin:

```c++
class Meter
{
public: 
    struct PreventUsage{};
    //explicit Meter(double dval) : value{dval} {} // copy init sentaks hatası oluyor.
    Meter(PeventUsage, double dval) : value{dval} {}
private:
    double value;
};

double operator""_m(long double dval)
{
    return Meter{Meter::PreventUsage{},static_cast<double> dval};
}

int main()
{
    Meter m1;
    double dval = 56.08;

}
```

### Raw String Literal

- Bir string literali oluşturulduğuna çift tırnak karakteri escape edilmek zorundaydı

```c++
namespace STD
{
    inline namespace Literal{
        inline namespace StrinLiterals
        {
            std::string operator""_s(const char *p, std::size_t);
        }
    }
}

int main()
{
    using namespace std;
    const char *p = "\"\"\"\\C++\\C++\\ali";
    using namespace std::literals;
    
    auto name = "mustafa"s;
}
```

Normal string yazım notasyonunda bazı karakterleri *escape* etmemiz gerekiyor. Örneğin regex kullanırken 4 tane `\` karakteri kodun okunmasını/yazılmasını zorlaştırıyor ve dile `raw string literal` özelliği eklenmiş.

- Bu ayrı bir tür değil sadece yazma kolaylaştırılması için oluşturulmuş.

```c++
int main()
{
    using namespace std;
    
    cout << sizeof(R"(ali)") << "\n";
    cout << sizeof("ali") << "\n";
    cout << boolalpha<< is_same_v<const char[4], decltype(R"(ali)")>;
    auto p = R"("ahmet \mehmet \hasan 
    uygar
    pinar
    omer

    )";
    puts(p);
}
```

- Yazının içerisinde `("murat")`yazıldığında sentaks hatası oluyor. Bunun için dile `<delimitir>(string)<delimiter>` şeklinde nasıl kullanıp kullanılamatyacağını programcı belirleyebiliyor.

### I/O Manip

#### queted Fonksiyonu

- `quoted` fonksiyonun geri dönüş türü tamamen derleyiciye bağlı.

```c++
#include <iomanip>
#include <iostream>
int main()
{
    using namespace std;
    auto str = quoted("ali");
    constexpr auto b = is_same_v<const char[5], decltype(quoted("ali"))>; //false

    cout << typeid(string).name() << "\n";
}
```

- Bu fonksiyon 2 tane daha parametre alıyor ve bu parametreler default edilmiş. Bu nasıl kullanılıyor.

```c++
int main()
{
    using namespace std;
    auto str = quoted("ali");
    cout << quoted(R"("ali" "can" "nur")")<< "\n";
    cout << str << "\n"; // akıma çift tırnaklı olarak veriyor

    ostringstream oss;
    oss << "\"Murat\"";
    cout << "|" << oss.str() << "|" << "\n";
    oss <<  quoted("\"Murat\"");
    cout << "|" << oss.str() << "|" << "\n";
}
```

- BU sadece ters bölü ve çift tırnak olması gerekmiyor. İlk parametrede hangi karakter için alınacağını belirliyoruz. İkinci parametrede hangi karakterin escape karakter olarak kullanılacağını belirliyoruz.

```c++
int main()
{
    using namespace std;
    ostringstream oss;
    oss << quoted("Murat",'*');
    cout << "|" << oss.str() << "|" << "\n";

    oss << quoted("*Murat* *hakan*", '*');
    cout << "|" << oss.str() << "|" << "\n";

    oss << quoted("*Murat* *hakan*", '*','+');
    cout << "|" << oss.str() << "|" << "\n";
}
```

- istringstream ile okuma işlemi yapılabilir.

```c++

int main()
{
    using namespace std;
    istringstream iss("\"Murat\" \"Hakan\"");
    string name;
    iss >> quoted(name);
    cout << name << "\n";
}
```

## string_view Sınıf Şablonu

- basic_string_view sınıfının char specializationu.

- Bir yazınının gözlemleme pencerisini gösteriyor. Burada string aslında yazı anlamında. Yani ortada eğer bir bytelarda ardışık karakter olarak tutulan yazılar.

`std::sting`, `char str[120]`,`vector<char> cvec`, `std::array<char,10>` gibi yazının ardışık olarak byte stream tutması yeterli. Eğer yazı ilave bir bellek alanına kopyalama yapılıyorsa, bundan kaçabilmek için 2 pointer kullanılarak **yazıyı gözlemlemek** amaçlı kullanabiliriz.

```c++
class StringView
{
public:
    //string sınıfı içerisinde bulunan const tüm member functionlar burada bulunursa ve bu fonksyionları const olarak implemente edersek. 
private:
    const char *ps; //başlangıç adresi
    //std::size_t len; //uzunluk da tutulabilir.
    const char *pe;
};
```

Bu şekilde artık sadece yaznının gözlemcisi olarak kullanabiliyoruz. Eğer yazıyı sadece okuma amaçlı kullanıyorsak burada sadece bu sınıfı kullanabiliriz.

```c++
#include <string_view>
//void func(const std::string &s) //burada bir kopyalama olup olmaması kullanıma bağlı.
void func(std::string_view s)
{
    std::cout << s << "\n";
}

int main()
{
    func("bugün yine hava cok sicak ve ne yazik ki orman yanginlari var");
}
```

- Burada kopyalanan string_view sınıf nesnesin ve bu sınıf sadece 2 pointerı var.

```c++
void func(std::string_view s)
{
    
}

int main()
{
    std::string str(100'000,'a');
    size_t idx{4000};
    size_t n{50'000};
    auto s = str.substr(idx,n); //burada yeni bir string oluşturuluyor.
    //50'000 karakterlik bir bellek alanında allocate ediliyor ve substring kısmı kopyalanıyor
    //Burada substr içerisinde sadece bir arama işlemi yapmak istiyorsak

    string_view sv = str;
}
```

- Dikkatli olunması gereken yerler var çünkü, yazının kaynağının sahibi biz değiliz. Örneğin string_view sınıfının gözlemlendiği yerlerde `dangling pointer` oluşabilir. Generic programlarda kullanım alanına göre kritik hata senaryoları oluşuturabilir.
- String_view sınıfının *null terminated byte stream* olması gereken değil. Eğer null terminated bekleyen bir API'ye bunu gönderirsek run-time hatası oluşucak.
- Substr'si substr döndürüyor. Gözlemcisi olduğu yazıyı salt okuma erişimli olarak okuyorlar.

- remove-prefix, remove-suffix, ile gözlemlendiği aralığı değiştirmemize yarıyor.

### Nasıl Construct Edilebilir?

1. Yolu default construct edebiliriz ve bu string_view sınıf nesnesinin boş olduğunu gösteriyor.
2. c-string constructor (null-terminated) bir yazıyı gözlemleyebiliriz.
3. Data constructor 1 pointer ve 1 tam sayı istiyor.

```c++
int main()
{
    std::string_view sv{};
    cout << boolalpha << sv.empty() << "\n"; //true
    std::cout << sv.size() << "\n"; //0
    std::cout << sv.data() << "\n"; //nullptr

    char str[] = "necati ergin";
    std::string_view sv2{str};
    sd::string_view sv1{"ali ata bak"};
    std::cout << sv1 << "\n";
    std::cout << sv2 << "\n";
}
```

3.Konu hakkında:

- İkinci parametrede verdiğimiz uzunluk kadar gözlemleyebiliyoruz. Ve eğer data fonksiyonunu çağırırsak bu fonksiyon bize başlangıç adresini döndürücek bu durumda eğer sv2 değişkenini null-terminated byte stream isteyen bir yerde kullanırsak run-time hatası oluşucak.

```c++
int main()
{
    using namespace std;
    char str[] = "ali ata bak";
    string_view sv1 = str;
    string_view sv2(str,7);
    cout << sv1.length() << "\n";
    cout << sv2.length() << "\n";

    std::array<char,6> ar{'t','a','y','l','a','n'};
    string_view sv3{ar.data(),ar.size()};//burada tanımsız davranış yok ve taylan yazısınıın gözlemcisi
    cout << sv3.length() << "\n";
    //cout << sv3.data() << "\n"; tanımsız davranış
    //puts(sv3.data()); tanımsız davranış
    //printf("%s\n",sv3.data()); //tanımsız davranış
}
```

String türünden bir constructor'ı yok:

string sınfının `std::basic_string_view<char, std::char_traits<char>>()` ile string_view sınıfına dönüştürülüyor.

```c++
int main()
{
    using namespace std;
    string s = "ali ata bak";
    string_view sv = s; //burada string sınıfının bir constructor'ı yok. burada std::strin string_view sınıfına dönüştürülüyor
}
```

İki char * ile de hayata başlatabiliriz

```c++
int main()
{
    using namespace std;
    char name[] = "ali ata bak";
    string_view sv1{name +2, name +6};
    cout << sv1.length() << "\n";
    cout << sv1 << "\n";
}
```

**C++20** ile range parametreli constructor'da dile eklendi. 02:02:50