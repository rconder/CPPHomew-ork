# 3.Hafta

## İçindekiler

- [3.Hafta](#3hafta)
  - [İçindekiler](#i̇çindekiler)
  - [Move Semantics](#move-semantics)
    - [Perfect Forwarding](#perfect-forwarding)
    - [auto \&\&](#auto-)
      - [Return value perfect passing](#return-value-perfect-passing)

## Move Semantics

### Perfect Forwarding

`std::forward<>` kullanımını incelemiştik.

Lambda ifadelerinde türün elimizde olmadığından bahsetmiştik.

```c++
int main()
{
    auto fn = [](auto&& t){
        std::forward<decltype(t)>(t);
    };
    // C++20 ile
    auto fn1 = []<typename T>(T && t){   
        std::forward<T>(t);
    };
}
```

Kısaltımlış template sentaksı da eklendi

```c++
template <typename T>
void func(T x);
//C++20 ile aşağıdaki gibi yazılabilir.
void foo(auto &&x);
```

- Universasl reference'ı sadece perfect forwarding için kullanmak zorudnda değiliz ve terimde de bir uyuşmazlık oluşuyor.

```c++
void navigate(std::string iterator beg, std::string::iterator end)
{
    std::cout<< "non const semantics on the passed range \n";
}
void navigate(std::string::const_iterator beg, std::string::const_iterator end)
{
    std::cout<< "const semantics on the passed range \n";
}
template <typename T>
void process_contianer(T &&t)
{
    navigate(std::begin(t), std::end(t));
}
int main()
{
    std::string name{"mutable test"}
    std::string const cname{"imutable test"};    
    process_contianer(name); // non const semantics on the passed range
    process_contianer(cname); // non const semantics on the passed range
    process_contianer(std::string{"temporary"}); // non const semantics on the passed range
    process_contianer(std::move(name)); // non const semantics on the passed range
    process_contianer(std::move(cname)); // non const semantics on the passed range
}
```

navigate fonksiyonun 2tane overloadi var birinin parametreleri const diğerininki const olmayan iterator. `process_container` için de const'uluk korunuyor ve çağrı buna göre yapılıyor.

Kendimiz de constluğa bağlı generic bir fonksiyonda oluşturabiliriz.

```c++
#include <type_traits>
#include <iostream>
#include <string>
using namespace std;

template <typename T>
void func(T&& )
{
    if constexpr(std::is_const_v<std::remove_reference_t<T>>)
    {
        std::cout<< "const ";
    }
    else
    {
        std::cout<< "non const ";
    }

    if constexpr(std::is_lvalue_reference_v<T>)
    {
        std::cout<< "lvalue\n";
    }
    else
    {
        std::cout<< "rvalue\n";
    }
}

class Myclass {};

int main()
{
    std::string name{"non const test"}
    func(name); // non const
    std::string cname{"const test"}
    func(cname); // const

    func(Myclass{}); // non const
    Myclass c;
    func(c); // non const
    func(std::move(c)); // non const
}
```

> Buradaki if constexpre run time'a değil compile time ile alakalı bir fonksiyon.

Universal reference parametre birden fazla yerde kullanılabiliyor ve burada value-category dependent code yazabiliyoruz. type_Traits kütüphanesi ile T türünün hakkındaki bilgileri sorgulayabiliyoruz

```c++
template <typename T>
void func(T,T);

int main()
{
    func(1,2); // burada sentaks hatası yok
    func(1,2.); // Sentaks hatası
    func("ali","ayse"); //sentaks hatası değil 
}
```

Derleyici açısından ilk argümana bakılırsa T int, ikinci argümana bakılırsa T double. Burada sentaks hatası oluşuyor. 

```c++
template <typename T>
void func(T&,T&);

int main()
{
    func("ali","ayse"); //SENTAKS HATASI
}
```

Burada aynı sentaks hatası oluşuyor çünkü çıkarım `const char [4]`, `const char[5]` olarak yapılıyor.

```c++
template <typename T>
void insert(std::vector<T> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name); // SENTAKS HATASI
}
```

Bu sentaks hatasının nedeni 1.parametrenin çıkarımı T'nin string olması üzerine, 2.parametre içinse T'nin çıkarımı T& olarak ve string & olarak yapılıyor. Bu yüzden hata oluşuyor.

- remove_reference kullanarak bu sorunu çözebiliriz.

```c++
template <typename T>
void insert(std::vector<std::remove_referednce_t<T>> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

- 2 tane template parametre kullanarak

```c++
template <typename ElemType, typename T>
void insert(std::vector<ElemType> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

- Ya da container türünü template parametresi olarak alabiliriz.

```c++
template <typename Container, typename T>
void insert(Container &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}
int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

### auto &&

- auto && ile universal reference'ı kullanabiliriz.

```c++
class Myclass {}; 

int main()
{
    Myclass m;
    const Myclass cm;
    auto &&r1 = Myclass{}; // Myclass = 
    auto &&r2 = m; // auto = Myclass & reference collapsing ile Myclass & oluyor
    auto &&r3 = cm;
    auto &&r4 = std::move(m);
    auto &&r5 = std::move(cm);
}
```

> fonksiyonun parametresi T'türü için yapılan çıkarım nasıl yapılıyorsa, auto için ayapılan çıkarım da aynı şekilde yapılıyor. Buradaki çıkarım `auto` için yapılıyor. Template çıkarımı da T'türü için çıkarım yapııyor.

Kullanılmasının gerekli olduğu senaryolar:

- Forwarding reference olarak kullanabiliriz.

```c++
class Myclass {};
void foo(const Myclass &)
{
    std::cout<< "foo(const Myclass &)\n";
}
void foo(Myclass &&)
{
    std::cout<< "foo(Myclass &&)\n";
}
void foo(Myclass &)
{
    std::cout<< "foo(Myclass &)\n";
}
void foo(const Myclass &&)
{
    std::cout<< "foo(const Myclass &&)\n";
}

int main()
{
    Myclass m;
    const Myclass cm;

    auto &&r1 = Myclass{}; 
    foo(std::forward<decltype(r1)>(r1)); // foo(Myclass{}) arasında bir fark yok
    auto &&r2 = m;
    foo(std::forward<decltype(r2)>(r2)); // foo(Myclass &)
    auto &&r3 = cm;
    foo(std::forward<decltype(r3)>(r3)); // foo(const Myclass &)
    auto &&r4 = std::move(m);
    foo(std::forward<decltype(r4)>(r4)); // foo(Myclass &&)
    auto &&r5 = std::move(cm);
    foo(std::forward<decltype(r5)>(r5)); // foo(const Myclass &&)    
}
```

Doğrudan argüman olarak göndermek ile argüman olarak göndereceiğimiz ifadeye universal referans bağladık ve bunu fonksiyona argüman olarak forward ederek kullandık.

#### Return value perfect passing

```c++
class Myclass {};
void foo(const Myclass &)
{
    std::cout<< "foo(const Myclass &)\n";
}
void foo(Myclass &&)
{
    std::cout<< "foo(Myclass &&)\n";
}
void foo(Myclass &)
{
    std::cout<< "foo(Myclass &)\n";
}
void foo(const Myclass &&)
{
    std::cout<< "foo(const Myclass &&)\n";
}

const Myclass & func_const_lref(const Myclass & str){ return str;}
Myclass & func_non_const_lref(Myclass & str){ return str;}
Myclass && func_ref(Myclass && str){ return std::move(str);}
Myclass func_value(Myclass str){ return str;}

int main()
{
    Myclass m;
    const Myclass cm;
    foo(func_rref(Myclass{})); // foo(Myclass &&) yukarıdaki fonksiyonlardan parametresi  Myclass && olan'ın çağırılması lazım.
    foo(func_non_const_lref(m)); // foo(const Myclass &)
    foo(func_const_lref(cm)); // foo(const Myclass &)
    foo(func_value(m)); // foo(Myclass &&)
}
```

Func_rref fonksiyonuna geçici nesne yolladık ve geçilen argümanı move etti. Geri dönüş değerini perfect forward aetmek için özel bir şey yapmamıza gerek yok.

Fakat biz bu geri dönüş değerini bir fonksiyonda tutmak ve daha sonra bu değişkeni kullanarak fonksiyon çağırısını yapmak istiyorsak bu durumda `auto &&` kullanmak zorudnayız.

```c++
template <typename T>
void func(T &&t)
{
    foo(bar(std::forward<T>(t)));
}

int main()
{
    Myclass m;
    const Myclass cm;
    //Type  ret = bar(std::forward<T>(t));
    //foo(ret); //buradaki ret'in türü ne olucak. Bu l'artık l value oluyor
    auto && ret = bar(std::forward<T>(t));
    foo(std::forward<decltype(ret)>(ret));
}
```

---- 1:00:00