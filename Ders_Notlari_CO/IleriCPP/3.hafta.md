# 3.Hafta

## İçindekiler

- [3.Hafta](#3hafta)
  - [İçindekiler](#i̇çindekiler)
  - [Perfect Forwarding](#perfect-forwarding)
    - [`auto &&`](#auto-)
      - [Return value perfect passing](#return-value-perfect-passing)
      - [Perfect Returning](#perfect-returning)
        - [decltype(auto)](#decltypeauto)

## Perfect Forwarding

`std::forward<>` kullanımını incelemiştik.

Lambda ifadelerinde türün elimizde olmadığından bahsetmiştik.

```c++
int main()
{
    auto fn = [](auto&& t){
        std::forward<decltype(t)>(t);
    };
    // C++20 ile
    auto fn1 = []<typename T>(T && t){   
        std::forward<T>(t);
    };
}
```

Kısaltımlış template sentaksı da eklendi

```c++
template <typename T>
void func(T x);
//C++20 ile aşağıdaki gibi yazılabilir.
void foo(auto &&x);
```

- Universasl reference'ı sadece perfect forwarding için kullanmak zorudnda değiliz ve terimde de bir uyuşmazlık oluşuyor.

```c++
void navigate(std::string iterator beg, std::string::iterator end)
{
    std::cout<< "non const semantics on the passed range \n";
}
void navigate(std::string::const_iterator beg, std::string::const_iterator end)
{
    std::cout<< "const semantics on the passed range \n";
}
template <typename T>
void process_contianer(T &&t)
{
    navigate(std::begin(t), std::end(t));
}
int main()
{
    std::string name{"mutable test"}
    std::string const cname{"imutable test"};    
    process_contianer(name); // non const semantics on the passed range
    process_contianer(cname); // non const semantics on the passed range
    process_contianer(std::string{"temporary"}); // non const semantics on the passed range
    process_contianer(std::move(name)); // non const semantics on the passed range
    process_contianer(std::move(cname)); // non const semantics on the passed range
}
```

navigate fonksiyonun 2tane overloadi var birinin parametreleri const diğerininki const olmayan iterator. `process_container` için de const'uluk korunuyor ve çağrı buna göre yapılıyor.

Kendimiz de constluğa bağlı generic bir fonksiyonda oluşturabiliriz.

```c++
#include <type_traits>
#include <iostream>
#include <string>
using namespace std;

template <typename T>
void func(T&& )
{
    if constexpr(std::is_const_v<std::remove_reference_t<T>>)
    {
        std::cout<< "const ";
    }
    else
    {
        std::cout<< "non const ";
    }

    if constexpr(std::is_lvalue_reference_v<T>)
    {
        std::cout<< "lvalue\n";
    }
    else
    {
        std::cout<< "rvalue\n";
    }
}

class Myclass {};

int main()
{
    std::string name{"non const test"}
    func(name); // non const
    std::string cname{"const test"}
    func(cname); // const

    func(Myclass{}); // non const
    Myclass c;
    func(c); // non const
    func(std::move(c)); // non const
}
```

> Buradaki if constexpre run time'a değil compile time ile alakalı bir fonksiyon.

Universal reference parametre birden fazla yerde kullanılabiliyor ve burada value-category dependent code yazabiliyoruz. type_Traits kütüphanesi ile T türünün hakkındaki bilgileri sorgulayabiliyoruz

```c++
template <typename T>
void func(T,T);

int main()
{
    func(1,2); // burada sentaks hatası yok
    func(1,2.); // Sentaks hatası
    func("ali","ayse"); //sentaks hatası değil 
}
```

Derleyici açısından ilk argümana bakılırsa T int, ikinci argümana bakılırsa T double. Burada sentaks hatası oluşuyor.

```c++
template <typename T>
void func(T&,T&);

int main()
{
    func("ali","ayse"); //SENTAKS HATASI
}
```

Burada aynı sentaks hatası oluşuyor çünkü çıkarım `const char [4]`, `const char[5]` olarak yapılıyor.

```c++
template <typename T>
void insert(std::vector<T> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name); // SENTAKS HATASI
}
```

Bu sentaks hatasının nedeni 1.parametrenin çıkarımı T'nin string olması üzerine, 2.parametre içinse T'nin çıkarımı T& olarak ve string & olarak yapılıyor. Bu yüzden hata oluşuyor.

- remove_reference kullanarak bu sorunu çözebiliriz.

```c++
template <typename T>
void insert(std::vector<std::remove_referednce_t<T>> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

- 2 tane template parametre kullanarak

```c++
template <typename ElemType, typename T>
void insert(std::vector<ElemType> &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}

int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

- Ya da container türünü template parametresi olarak alabiliriz.

```c++
template <typename Container, typename T>
void insert(Container &vec, T &&val)
{
    vec.push_back(std::forward<T>(val));
}
int main()
{
    std::vector<std::string> vec;
    std:string name;
    insert(vec, name);
}
```

### `auto &&`

- auto && ile universal reference'ı kullanabiliriz.

```c++
class Myclass {}; 

int main()
{
    Myclass m;
    const Myclass cm;
    auto &&r1 = Myclass{}; // Myclass = 
    auto &&r2 = m; // auto = Myclass & reference collapsing ile Myclass & oluyor
    auto &&r3 = cm;
    auto &&r4 = std::move(m);
    auto &&r5 = std::move(cm);
}
```

> fonksiyonun parametresi T'türü için yapılan çıkarım nasıl yapılıyorsa, auto için ayapılan çıkarım da aynı şekilde yapılıyor. Buradaki çıkarım `auto` için yapılıyor. Template çıkarımı da T'türü için çıkarım yapııyor.

Kullanılmasının gerekli olduğu senaryolar:

- Forwarding reference olarak kullanabiliriz.

```c++
class Myclass {};
void foo(const Myclass &)
{
    std::cout<< "foo(const Myclass &)\n";
}
void foo(Myclass &&)
{
    std::cout<< "foo(Myclass &&)\n";
}
void foo(Myclass &)
{
    std::cout<< "foo(Myclass &)\n";
}
void foo(const Myclass &&)
{
    std::cout<< "foo(const Myclass &&)\n";
}

int main()
{
    Myclass m;
    const Myclass cm;

    auto &&r1 = Myclass{}; 
    foo(std::forward<decltype(r1)>(r1)); // foo(Myclass{}) arasında bir fark yok
    auto &&r2 = m;
    foo(std::forward<decltype(r2)>(r2)); // foo(Myclass &)
    auto &&r3 = cm;
    foo(std::forward<decltype(r3)>(r3)); // foo(const Myclass &)
    auto &&r4 = std::move(m);
    foo(std::forward<decltype(r4)>(r4)); // foo(Myclass &&)
    auto &&r5 = std::move(cm);
    foo(std::forward<decltype(r5)>(r5)); // foo(const Myclass &&)    
}
```

Doğrudan argüman olarak göndermek ile argüman olarak göndereceiğimiz ifadeye universal referans bağladık ve bunu fonksiyona argüman olarak forward ederek kullandık.

#### Return value perfect passing

```c++
class Myclass {};
void foo(const Myclass &)
{
    std::cout<< "foo(const Myclass &)\n";
}
void foo(Myclass &&)
{
    std::cout<< "foo(Myclass &&)\n";
}
void foo(Myclass &)
{
    std::cout<< "foo(Myclass &)\n";
}
void foo(const Myclass &&)
{
    std::cout<< "foo(const Myclass &&)\n";
}

const Myclass & func_const_lref(const Myclass & str){ return str;}
Myclass & func_non_const_lref(Myclass & str){ return str;}
Myclass && func_ref(Myclass && str){ return std::move(str);}
Myclass func_value(Myclass str){ return str;}

int main()
{
    Myclass m;
    const Myclass cm;
    foo(func_rref(Myclass{})); // foo(Myclass &&) yukarıdaki fonksiyonlardan parametresi  Myclass && olan'ın çağırılması lazım.
    foo(func_non_const_lref(m)); // foo(const Myclass &)
    foo(func_const_lref(cm)); // foo(const Myclass &)
    foo(func_value(m)); // foo(Myclass &&)
}
```

Func_rref fonksiyonuna geçici nesne yolladık ve geçilen argümanı move etti. Geri dönüş değerini perfect forward aetmek için özel bir şey yapmamıza gerek yok.

Fakat biz bu geri dönüş değerini bir fonksiyonda tutmak ve daha sonra bu değişkeni kullanarak fonksiyon çağırısını yapmak istiyorsak bu durumda `auto &&` kullanmak zorudnayız.

```c++
template <typename T>
void func(T &&t)
{
    foo(bar(std::forward<T>(t)));
}

int main()
{
    Myclass m;
    const Myclass cm;
    //Type  ret = bar(std::forward<T>(t));
    //foo(ret); //buradaki ret'in türü ne olucak. Bu l'artık l value oluyor
    auto && ret = bar(std::forward<T>(t));
    foo(std::forward<decltype(ret)>(ret));
}
```

```c++
using namespace std;

int main()
{
    vector<int> ivec(10);

    for(auto val : ivec)
    {
        cout<< val;
    }
    for(auto i : ivec)
    {
        i = 10;
    }
    cout <<"\n";
    for(auto val : ivec)
    {
        cout<< val;
    }
}
```

Fakat eğer vector'ün bool specializasyonu varsa bu durumda partial specializasyonu var.

```c++
int main()
{
    vector<bool> ivec(10);


    auto x = ivec[2]; //burada proxy object döndürüyor.
    //x bir vector'un bool açılımının referansı türü nested type
    auto x = ivec.operator[](2); 
    ivec[3] = true; // yazıldığında
    ivec.operator[](3).operator=(true); // yazılmış oluyor.

    for(auto val : ivec){ cout<< val; }
    /*derleyicinin ürettiği psuedo kod
    auto &&rng = ivec; 
    auto pos = rng.begin();
    auto end = rng.end();
    for(;pos != end; ++pos)
    {
        auto temp = *pos; eğer  val referans türü olsaydı auto &temp olurdu, sağ taraf referans türü olsaydı auto &&temp olurdu.
    }
    */

    for(auto i : ivec){ i = true;  }
    cout <<"\n";
    for(auto val : ivec){ cout<< val; }

    auto iter = ivec.begin();
    iter.operator*(0) = true; //bu bize referans dödnüremeyeceğine göre, proxy nesnesi dönüyor
    //reference nested type'ından nesneye yapılmış oluyor.
}
```

> Vector'un bool açılımının 2 sorunu var 1.container değil, 2.bool tutmuyor. :D

```c++
template<>
class Vector
{
    class reference
    {
        operator=(bool);
        operator bool()const;
    }
    reference operator[](size_t idx);
};
```

Eğer `auto val` yerine `auto &&val` olsaydı bu durumun bir etkisi olmayacaktı.

Aşağıdaki kodda amaç öyle bir fill fonksiyonu oluşturmakki 1.argümandaki container'a 2.parametredeki val değerini yerleştirmek.

- `auto &&` kullanarak sentaks hatasının önüne geçilebiliyor.

```c++
template <typename C, typename T>
void Fill(C & con, const T& val)
{
    for(auto & elem : con)
    //Sentaks hatasını engellemek için universal refeerans kullanmak gerekiyor. 
    {
        elem = val;
    }
}

template <typename C, typename T>
void Fill_2(C & con, const T& val)
{
    auto &&rng = con;
    auto pos = rng.begin();
    auto end = rng.end();
    for(;pos != end; ++pos)
    {
        auto &elem = *pos; //pos.operator*() bu fonksiyonun geri dönüş değeri referans ve r-value expression
        //sentaks hatasının nedeni l-value referansa  r-value expression atanması
        *pos = val;
    }
}

inr main()
{
    vector<int> ivec(10);
    for(auto val : ivec)
    {
        cout<< val;
    }
    Fill(ivec, 10);
    cout <<"\n";
    for(auto val : ivec)
    {
        cout<< val;
    }

    vector<string> svec{"ali", "veli", "selami"};
    for(auto val : svec)
    {
        cout<< val;
    }
    Fill(svec, "necati");
    cout <<"\n";
    for(auto val : svec)
    {
        cout<< val;
    }
    vector<bool> bvec{false, false, false};
    for(auto val : bvec)
    {
        cout<< val;
    }
    //Fill(bvec, true); //SENTAKS HATASI
    cout <<"\n";
}
```

#### Perfect Returning

Amacımız foo'nun geri döndürdüğü gibi olduğu gibi func fonksiyonun aynı geri dönüş değerini döndürmek istiyoruz.

```c++
template <typename T>
??? func(T &&t)
{
    foo(std::forward<T>(t));
}
```

Geri dönüş değeri yerine `decltype(auto)` yazmamız gerekiyor. Peki bu ne demek?

##### decltype(auto)

**decltype** için 2 farklı decltype var.

1. Operandı olan ifadenin bir isim formunda olması, declaration türünü elde ediyor
2. Eğer bir expression olursa, bu durumda ifadenin değer kategorisi oluyor:

- PRvalue ==> T
- Lvalue ==> T&
- Xvalue ==> T&&

decltype(auto)' da ise, tıpkı auto da olduğu bir değişkene ilk değer verdiğimizde, `auto`nun kurallarına göre değil de `decltype`a göre belirleniyor.

```c++
int & foo();
int && bar();
decltype(auto) f1()
{
    return expr; // int & f1() return type
}
int main()
{
    int x = 4;
    decltype(auto) y = x; // int y = x;
    decltype(auto) z = 4; // int z = 4;
    decltype(auto) t = foo(); // int & t = foo();
    decltype(auto) u = bar(); // int && u = bar();
    decltype(auto) y = (x); // x ile yukarıdaki farklı anlamlara geliyor
    
    int m{}, * ptr{&m};
    decltype(auto) r = m;
    //decltpye(auto) ilave bir deklaratör alamıyor.
}
```

```c++
struct Myclass
{

};

decltype(auto) foo(Myclass m)
{
    //return m; // Myclass
    //return (m); // Myclass & olurdu ve otomatik ömürlü bir nesneye referans döndürmüş olur ve hata olurdu.
}
```

```c++
decltype(auto) fn_A(int i){  return i; }
//decltype(auto) fn_B(int i){ return (i); } 
//Sentaks hatası fonksiyonun geri dönüş değeri int & otomatik ömürlü nesneyi döndürüyor
decltype(auto) fn_C(int i){  return (i+1); }
decltype(auto) fn_D(int i){  return i++; }
// Yok çünkü son ek ++ operatörü oluşturduğu ifade PR-value expression ve geri dönüş değeri int
decltype(auto) fn_E(int i){  return ++i;}
// Ön ek ++ operatörü oluşturduğu ifade L-value expression ve geri dönüş değeri int & otamtik ömürlü nesneye referans dönüyor.
decltype(auto) fn_F(int i){  return (i >= 0 ? i : 0); }
// Bir problem yok, çünkü ternary operatorünün operandları PR-value expression ve geri dönüş değeri int
d//ecltype(auto) fn_G(int i, int j) {  return i >= j ? i : j; }
// ternary operatör'Ün return ifadesinin kategörüsü gene int & döndürüyor
struct S {  int i = 0; };
decltype(auto) fn_H(){   return (S{});}
// İfade PR-value expression ve geri dönüş değeri S
//decltype(auto)fn_I(){  return (S{}.i);}
// R-value nesnelerin non-static veri elemanlarına erişim ifadesi X-value expression ve dönüş değeri int && oluyor ve geçici nesneye referans dönüyor.
```

