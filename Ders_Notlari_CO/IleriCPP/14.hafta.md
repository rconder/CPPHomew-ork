# 14.Hafta

- [14.Hafta](#14hafta)
- [25\_24\_09\_2023](#25_24_09_2023)
  - [C++ Idioms](#c-idioms)
    - [Hidden Friend Bildirimi](#hidden-friend-bildirimi)


# 24_23_09_2023

# 25_24_09_2023

## C++ Idioms

### ADL Fallback

- Burada öncelikle 

```cpp
#include <iostream>

void func()
{
    using std::cout; //using declaration
    //artık bu coma separated list ile kullanılabiliyor
    //using std::cout, std::endl;

    std::cout << "func cagrildi\n";
}
```

- template fonksiyon söz konusu olduğunda burada nitelenmemiş bir isim kullanıldığında önce blok scope ve daha sonra namespace scope aranır. Biz buna bir argüman gönderirsek ADL devreye girer ve bu durumda nitelenmemiş ismi ADL gereği o scope ta da aranıyor

ADL:

```cpp
namespace A
{
    struct MyStruct
    {
    };
    void swap(Foo &, Foo &);
}

namespace B
{
    class Myclass{};
    void foo(std::vector<Myclass> &); // vector'ün myclass açılımı türünden
}


int main()
{
    A::MyStruct ms;
    swap(ms, ms); // ADL devreye girer
    std::vector<B::Myclass> vec;
    foo(vec); // ADL devreye girer
}
```

- ADL normal isim arama ile birlikte çalışır ve bu durumda ambiguity oluşabilir.

```cpp
#include <iostream>
#include <vector>

namespace A
{
    struct MyStruct
    {
    };
    struct Bar
    {

    };
    void swap(MyStruct &, MyStruct &)
    {
        std::cout << "A::swap\n";
    }
}

template <typename T>
void func(T)
{
    T x, T y;
    using std::swap; // std'den swap fonksiyonunu kullanılabilir hale geliyor
    swap(x, x); // ADL devreye girer, bu durumda
}

int main()
{
    A::MyStruct ms;
    A::Bar bar;
    func(bar); // std olan çağırılır.
    func(ms); // ADL devreye girer.
}
```

Yukarıdaki kod içereisinde using bildirimi kullanıldığı için eğer T'nin bulunduğu namespace içinde swap fonksiyonu varsa ADL devreye girer ve bu durumda bu fonksiyon çağrılır. Eğer bu fonksiyon bulunmazsa std namespace içindeki swap fonksiyonu çağrılır.

### Hidden Friend Bildirimi 

- Bu fonksiyonlar ADL'e tabi 

```cpp
class Myclass
{
    int x;
    public:
    friend void foo(Myclass &); // hidden friend declaration sınıfın member'ı değil o namespace içinde ve görülür değil.
    //Ancak bu isim ADL ile aranır.
};

int main()
{
    Myclass m;
    foo(m);
}
```

- Avantajları, Bizim birden fazla sınıfımız olduğunu düşünelim ve 

```cpp
struct A{A operator+(const A &, const A &);};
struct B{B operator+(const B &, const B &);};
struct C{C operator+(const C &, const C &);};
struct D{D operator+(const D &, const D &);};
struct E{E operator+(const E &, const E &);};
struct F{F operator+(const F &, const F &);};

A operator+(const A &, const A &);
B operator+(const B &, const B &);
C operator+(const C &, const C &);
D operator+(const D &, const D &);
E operator+(const E &, const E &);
F operator+(const F &, const F &);

class Nec{

    
};
int main()
{
    Nec n1,n2;
    //auto n3 = n1+n2; // burada hangi operator+ aranacak fakat bulunamayacak ve burada hem hata mesajı karışık olucak hem de compile tam yok. 
}
