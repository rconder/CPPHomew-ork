# 7.Hafta

---

> 05_08_2023

---

## Space Ship Operatörü

Bu operatörü çoğunlukla doğrudan kullanmıyoruz. Kullandığımız yer kendi türlerimiz için bu operatörü overload ettiğimiz yerler. Artık operatörler arasında bir ayrım yapılıyor ve bu ayrım:

1. `==` ve `<=>` operatörü
2. `!=`, `>`, `<=`, `>=`, `>` operatörleri

- Primary operatörler ***reversable*** (*derleyici uygun fonksiyon bulunmaması durumunda operandları yer değiştirebiliyor*).
- Secondary operatörler ise **rewritable** ( eğer x!=y  yok ise bunu !(x==y) olarak değiştirebilir.)

Bu da kendi sınıflarımız için `!=` değili yazmamıza gerek yok `==` yazmamız yeterli olacak. Aynısı diğer operatörleri yazmak yerine `<=>` operatörünü yazmamız yeterli olacak.

- Öğeler bildirim sırasına göre karşılaştırılır.

- `==` fonksiyonu için aşağıdaki örtülü dönüşümler yapılıyor.

```c++
class Myclass {
public:
    Myclass(int x = 0) : mx{x} {}
    bool operator==(const Myclass &other) const
    {
        return mx == other.mx;
    }
private:
    int mx;
};

int main()
{
    Myclass x{10}, y{20};
    auto b1 = x == y; // x.operator==(y)
    auto b2 = x != y; // !(x.operator==(y))
    auto b3 = x == 5;
    auto b4 = 5 == x; //C++20 öncesi bu legal değildi, derleyici 5 == x'için x.operator==(5) çağrısına dönüştürüyor.
}
```

- Sadece `<=>` default edilirse diğer 6 karşılaştırma işlemini de yapabiliyoruz

```c++
class Myclass {
public:
    Myclass(int x = 0) : mx{x} {}
    auto operator<=>(const Myclass &other) const = default;
    //auto operator==(const Myclass &other) const = default; bunu da default ediliyor
private:
    int mx;
};

int main()
{
    Myclass x{10}, y{20};
    bool b{};
    b = x == y; // x.operator==(y)
    b = x != y; // !(x.operator==(y))
    b = x != 5;
    b = 5 != x; 
    b = x == 5;
    b = x < y; // x<=> < 0 şeklinde de yazabilirdik fakat bu şekilde daha okunaklı
}
```

- Default edilmiş durumda derleyici yazdığı fonksiyonu, eğer öğelerin karşılaştırılması `noexcept` garantisi veriyorsa fonksiyonda `noexcept` garantisi veriyor.

```c++
template <typename T>
class Type{
public:
    [[nodiscard]] virtual std::strong_ordering
     operator<=>(const Type &)const requires(!std::same_as<T,bool>)= default;
};
```

- Geri dönüş değerinin `auto` olması generic kod kısmında işimize yarıyor. Burada geri dönüş değerini trail return type ile belirleyebiliriz.

```c++
template <typename T, typename U>
class Myclass {
private:
        T mx;
        U my;
public:
    auto operator<=>(const Myclass& other) const -> std::common_comparison_category_t<decltype(mx<=>mx),decltype(my<=>my)>
    {
        if(auto res = mx<=>other.mx; res != 0)
            return res;
        return my<=>other.my;
    }
};
```

- Vectorler için Lexicographical comparison yapılıyor.

```c++
int main()
{
    using namespace std;
    vector v1(100'000, 5);
    vector v2(5, 6);
    bool b = v1 < v2; // false

    //lexicographical comparison için 2 farklı container kullanabiliyoruz.
    list mylist{3,6,7,9,1};
    vector myvec{3,6,8,1};
    cout <<boolalpha <<lexicographical_compare(mylist.begin(), mylist.end(), myvec.begin(), myvec.end());//true
}
```

- C++20 ile öyle durumlar varki range'leri spaceship operatörü ile karşılaştırmamız gerekebilir, bunun için lexicoğraphical_compare_three_way algoritması eklendi ve bu fonksiyonun geri dönüş değeri `<=>` operatörünün geri dönüş değeri.

```c++
std::ostream& operator<<(std::ostream& os, const std::strong_ordering& so)
{
    return so == 0 ? os << "equal" : so < 0 ? os << "less" : os << "greater";
}

int main()
{
    list mylist{3,6,7,9,1};
    vector myvec{3,6,8,1};
    auto result = lexicographical_compare_three_way(mylist.begin(), mylist.end(), myvec.begin(), myvec.end());//true
    cout << result << "\n";
}
```

## Lambda İfadeleri, C++20 ile Gelen Yenilikler ve Tipik Idiomlar

- C++11 standartı ile dile eklendi.

Lambda ifadesi karşılığında bir local sınıf oluşturuyor ve ifade kategorisi PR-Value. Derleycinin oluşturduğu sınıf türüne `closure-type` deniyor. Nesneye ise `closure object` deniyor. Nested function'ın C++ karşılığı. Fonkisyon ihtiyacı olan nokta ile fonksiyonun arasındaki mesafeyi kapatıyor. Fonksiyona nerede ihtiyaç var ise orada tanımlıyoruz. Derleyicinin optimizasyon olasılıkları da optimize edilmiş oluyor.

### Örnek sorular

```c++
int g = 99;
auto fx = [=]{return g+1;}
auto fy = [g=g]{return g+1;}

int main()
{
    g = 500;
    cout << fx() << "\n"; //100
    cout << fy() << "\n"; //100
}
```

```c++
int main()
{
    auto x = {static int x{}; return ++x;}
    decltype(x) y;
    decltype(x) z;
    cout << y() << y() << z() << "\n";
    cout << y() << z() << z() << "\n";    
}
```

```c++
int main()
{
    const int x = 10;
    //auto f = [x]()mutable{++x;}; Sentaks hatası.  Capture close'da x ismi kullanılmış 
    //copy-capture ve burada sınıfın veri elemanı const, sınıfın üye fonksiyonu non-const olmasına rağmen
    //sınıfın üye elemanı const olduğu için sentaks hatası oluşuyor.

    //auto g = [x = x](){++x;};  Sentaks hatası.
    // Bunun legal olması için mutable olması gerekiyor, sınıfa bir veri elemanı koyacak ve buradaki x'ile initialize edilecek.
    //sınıfın üye fonksyionu const olduğu için burada sentaks hatası oluşuyor.
    auto h = [x = x]()mutable{++x;};
}
```

```c++
int main()
{
    int x = 4;
    auto y = [x = x + 1, &r = x]()
    {
        r+=2 ;
        return x*x;
    }();
    cout << x << " " << y << "\n"; // 6 25
}
```

```c++
int g = 5;
int main()
{
    auto f = [](int x = ++g){return x*x;};
    auto x = f();
    auto y = f();
    cout << x << " " << y << " " << g <<"\n"; // 36 49 7
}
```

```c++
double i{};
int main()
{

    auto f = [i =0 ]()-> decltype(i) {return 1;}();
    cout << is_same_v<decltype(f), int>;
}
```

### Hızlı Temel Tekrar

![lambda sentaks](res/lambda_sentaks.png)

- Optional bir kısmı C++20 ile geldi.

```c++
int main()
{
    [](){}; //en basit lambda ifadesi
    [](){}(); //fonksiyon çağrı operatörünü böylede yazabiliyoruz.
    []{}(); //yukarıdaki ile aynı 

    [](int x){return x*6;}; //burada fonksiyon çağrısını yapmıyoruz. ; ile geçici nesnenin ömrü burada bitiyor.
    [](int x){return x*6;}(10);//bulunduğu yerde doğrudan çağırmak. Immidiately invoked function expression
    // bu fonksiyonu birden fazla kez çağırmak istersek closure-type'ı bir değişkene atamamız gerekiyor.
    auto f = [](int x){return x*6;}; //isimlendirilmiş bir function-object yapabiilriz.
    f(10);
    f(20);
    // İsim vererek kodu okuyana yardımcı olunuyor ve genelde const semantiğine uyulması gerekiyor.
}
```

- İsimlendirilmiş lambda ifadeleri const olarak tanımlandığında optimizasyon ihtimali artıyor.
- En sık kullanılan senaryo da lambda ifadesini bir fonksiyonu argüman olarak gönderiyoruruz.

```c++
template <typename F>
void func(F f);

int main()
{
    func([](int x){return x*6;});
}
```

- Bazı durumlarda lambda ifadesi'nin türünü bilmemiz gerekmiyor fakat bazı durumlarda bu bilgiye erişmemiz gerekebilir.

```c++
int main()
{
    auto f = [](int x){return x*6;};
    decltype(f) g = f; //f'nin türünü decltype ile elde edebiliyoruz. 
    cout << typeid(f).name(); //lambda ifadesinin türünü öğrenmek için typeid kullanabiliriz.
    g(10);
}
```

- Closure objectlerin türlerinin aynı olup olmaması bazı durumlarda kritik olabiliyor.

```c++
int main()
{
    auto f1 = [](int x){return x*6;};
    auto f2 = [](int x){return x*6;};
    is_same_v<decltype(f1), decltype(f2)>; //false
    auto f3 = f1; //f1'in türüne göre f3'ün türü belirleniyor.
    is_same_v<decltype(f1), decltype(f3)>; //true
}
```

- auto type-deduction'da dikkat edilmesi gereken closure-type çıkarımı ile bu türden çağırılan fonksiyonun geri dönüş değeri olabilir.

```c++
int main()
{
    auto f = [](int x){return x*6;};
    auto f = [](int x){return x*6;}();
   
}
```

#### Sentaks Öğeleri

`[](){}`

- lambda fonksiyonu *default* olarak `const`.
- Eğer return ifadesi yok ise geri dönüş değeri default olarak `void`. Geri dönüş değerini ise çıkarım yoluyla elde ediyoruz.
- `mutable` ile *non-const* üye fonksiyon olarak tanımlayabiliyoruz.

> semantik tarafında `mutable` kullanımı programcıya semantik olarak o üye veri elemanının problemin domaini ile alakası yok, sınıf nesnesini değiştirmeyen fonksiyonlar olarak işliyor.

- Fonksiyon içerisinde birden fazla return statement olması ve bu return statement'lerin geri dönüş değerlerinin türleri farklı olması sentaks hatası

```c++
int main()
{
    auto f = [](int x)
    {
        if(x < 10)
            return x*6;
        else
            return 7.0;
    };
}
```

- Bu durumda geri dönüş değerinin ya hepsinin aynı olması gerekiyor, ya da *trailing return* type kullanmak.
- Ara bloğun içine artık bir kısıtlama yok.

```c++
int main()
{
    auto f  =[](){
        static int x = 10;
        ++x;
        cout << x << "\n";
    }
    f();
    f();
    f();
}
```

- Aynı ifadeyi tekrar edip birden fazla lambda ifadesini tanımlarsak ve bu fonksiyonlar içerisindeki static yerel değişkenler birbirinden farklı.

**Parametre değişkenleri**:

- C++14 ile default argüman alabiliyor. `[](int x = 10 ){}`
- Yeniliklerden biri generalized lambdalar. C++14 sonrası için bu parametrenin member template şeklinde yazdırabiliyoruz.

```c++
/*
fonksiyon: 

class xyasdf
{
public:
    template<typename T>
    T operator()(T x) const
    {
        return x*6;
    }
};
*/


int main()
{
    auto f = [](auto x){return x*6;};
}
```

- Gönderilen birden fazla argümanın türü aynı olmak zorunda değil. C++20 ile gelen *familiar template syntax* dile eklendi.

#### Capture Close

- Derleyiciye lambda ifadesi ile bir sınıf kodu yazdırdığımızı biliyoruz. Parametre parantezi içinde `auto` kullandığımızda bunun template member fonskiyonu yaptığımızı biliyoruz. İlave bir sentaks kullanmak durumunda sınıfın bir veri elemanı olmuyor ve bu durumda bizim derleyiciye veri elemanı ekleyip bunu veri elemanı için constructor yazılmasını istiyoruz.
- Sınıfa eklenecek veri eleman referans olmayan herhangi bir türden olabilir. Burada bazı avantajları elde etmek için referans semantiğini kullanmak isteyebiliriz.
- Fonksiyon içerisinde statik ömürlü değişkenleri doğrudan kullanabiliriz. Bunları capture etmeye çalışırsak sentaks hatası oluşuyor.
- nesne'nin const olması ve sabit bir değer ile ilk değerini alması durumunda capture etmemize gerek yok.

```c++
int main()
{
    int val{35};
    auto f = [val](int a){return val*a;}; //copy capture
}
```

- `val` derleyicinin oluşturduğu sınıfın non-static veri elemanı.
- Birden fazla değeri virgüller ile ayrılmış liste ile capture edebiliriz.
- `=` tokenini kullanarak tüm görünen yerel değişkenleri capture edebiliyoruz.
- capture edildiğinde direkt array-decay oluşmuyor, diziyi direkt alıyoruz gibi düşünebiliriz.
- Init capture ifadesi kullandığımızda ise array-decay oluşuyor.

```c++
int main()
{
    int a[4]{};
    auto f = [a]{
        std::is_same_v<decltype(a), int*>; //false
        std::is_same_v<decltype(a), int[4]>; //false
    }
    auto f1 = [a = a](){
         std::is_same_v<decltype(a), int*>; //true
    }; 
}
```

- capture edilen nesnenin değerini değiştirebilmemiz için `mutable` olması gerekiyor.

```c++
int main()
{
    int x = 10;
    auto f = [x]()mutable{return ++x;};
    f();
    f();
    f();
}
```

- Nesnenin kendisini kullanmak istiyorsak ve o nesneyi değiştirmek isteyebiliriz, bu durumda yakalamayı referans semantiği ile yazmamız gerekyiyor.

```c++
int main()
{
    int x = 10;
    auto f = [&x](){return ++x;};
    f();
    f();
    f();
    cout << x << "\n";
}
```

- Bir kısmını referans bir kısmını copy capture edebiliiz

```c++
int main()
{
    int x{}, y{}, z{};
    auto f =[=, &z]{}; //x ve y capture, z referans semantiğii ile
    auto f = [&]{}; //hepsi referans semantiği ile
    auto f = [=]{}; //hepsi copy capture ile
}
```

- Özellikle gerekmiyorsa referans ile capture etmemeye çalış. Bazı durumlarda farkında olmadan *dangling reference* oluşturabiliriz.

```c++
auto foo()
{
    int x;
    return &x; //geri dönüş değeri int * olurdu ve otomatik ömürlü bir nesnenin adresini dönmüş olucaktı.
}

auto fo()
{
    std::vector vec{1,2,3,4,5};
    return vec;
}

auto foo(int i)
{
    auto f = [&](int x){ x*i};
}
int main()
{
    using namespace std;
    auto fn = foo(10);
    auto val = fn(290);
    cout << val << "\n";
    //bu kod undefined behavior oluşturuyor.
}
```

- Bir sonraki derse soru, aşağıdaki closure type için const sol taraf referans değeri kullanılabiliyor mu?

```c++
int main()
{
    using namespace std;
    vector<int> ivec(10000, i);
    auto f = [ivec]{    }; //burada kopyalama yapıyoruz ve maliyeti çok yüksek 

}
```

***Lambda init capture***:

- C++14'ten önce unique_ptr'ı taşımak istediğimizde taşınamıyruz bunun için artık lambda init capture kullanıyoruz.

```c++
int main()
{
    auto uptr = make_unique<string>(10'000,'a');
    //auto f = [uotr](){} Sentaks hatası çünkü unique_ptr kopyalanamaz
    auto f = [&uptr](){}; //bu durumda unique_ptr'ı yakalıyoruz
    f();
    cout << (uptr ? "dolu" : "bos");
    auto f1 = [uptr = move(uptr)]{}; //bu durumda unique_ptr'ı taşıyoruz
    cout << (uptr ? "dolu" : "bos");
}
```

#### Sınıfın üye fonksiyonları içinde capture

- Bunu yapmak için üye fonksiyon hangi nesne için çağırıldıysa onu capture etmemiz gerekiyor. Bunun için biri `this` pointer'ını capture etmek.
- Copy-all ile capture edilebilirdir fakat C++20 ile DEPRECATED hale geldi.
- Referans yoluyla capture edilmesi hale mümkün.

```c++
struct Myclass{
    int mx;
    void func()
    {
        auto f = [this]{return mx;};
        auto f1 = [this]{return this->mx;};
    }
};
```

- Dangling referans oluşmaması için ve fonksiyon içinde *this'in bir kopyasını kullanmak için

```c++
struct Myclass{
    int mx;
    void func()
    {
       auto f = [copy_this = *this]{auto val = copy_this->mx;};
    }
};
```

![alt text](res/capture_init.png)

- C++17 ile `*this` kullanabiliyoruz.

```c++
struct Myclass{
    int mx;
    void func()
    {
       auto f = [*this](){auto val = mx;};
    }
};
```

03:12:45