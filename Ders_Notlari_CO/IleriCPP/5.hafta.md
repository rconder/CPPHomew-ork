# 5.Hafta

---

> 08_22_07_2023

---

## std::optional

- It is recommended to use `optional<T>` sin situations where theere is exactly one, clear ( to all parties) reason for having no value of type T, and where the lack of a value is as natural as having any regular value of type T.

### Nesnesini nasıl oluştururuz?

- Default initialize edilmiş bir `optional` nesnesi, `std::nullopt` durumunda. Default construct edilmiş nesnesi default contsrukt edilmiş bir `T` türünden nesnesine sahip değil.

```c++
int main()
{
    using namespace std;
    std::optional<int> opt; // default initialize edilmiş bir nesne
    boolalpha(cout);
    cout << boolalpha;
    cout << op.has_value() << "\n"; // false
    
    if(op) { cout << "bir deger var\n"; }
    else { cout << "deger yok\n"; }
    cout << ( op == nullopt)<< "\n"; 
}
```

### Erişmenin yolları

- Tipik bir sarmalıyıcı olduğu için doğrudan değiştirilecek bir nesne de kullanabiliriz.
- - Eğer boş bir optional nesnesine erişmeye çalışırsak, undefined behavior oluşur.

```c++
int main()
{
    using namespace std;
    std::optional<string> op{"deneme"};
    cout << *op<< "\n"; // deneme
    cout << op->size();
    //cout << *op; //Eğer boş olsaydı ub olurdu
}
```

- `op.value()` fonksiyonu ile de değere erişebiliriz ve bu fonksiyon çağırıldığında exception throw ediyor.

```c++
int main()
{
    using namespace std;
    std::optional<string> op;
    try {
        cout << op.value() << "\n"; // deneme
        cout << op.value().size();
    }
    catch(const std::bad_optional_access& e) {
        std::cout << e.what() << '\n';
    }
}
```

- `op.value_or()` fonksiyonu eğer optional nesnesi bir değer tutuyorsa bu değeri döndürür, eğer boş ise, parametre olarak verilen değeri döndürür.

```c++
int main()
{
    using namespace std;
    std::optional<string> op;
    cout << op.value_or("bos") << "\n"; // bos
    std::optional<string> op2{"deger"};
    cout << op2.value_or("bos") << "\n"; // deger
}
```

- `value_or` fonksyionu `value` dan farklı olarak sol taraf referans döndürmüyor.
  
- std::optional nesnesi bir referans tutamıyor fakat reference wrapper ile bunu yapabiliriz. Fabrika fonksiyonlarını kullanabiliyoruz

```c++
int main()
{
    using namespace std;
    string name {"deneme"};
    std::optional<reference_wrapper<string>> op(ref(name));
    op->get() +=  "test";
    //CTAD
    optional x = 12;
}
```

### In_place ve make_optional

Yardımcı bir `in_place_t` nesnesi var ve bu türden bir değişkenimiz var `in_place`.

- Default construct edilmiş bir optional nesnesini oluşturmamız mümkün değil default olarak nesneyi construct etmiyor.
- Eğer inplace objesi ile optional nesnesini oluşturursak, bu durumda nesne doğrudan oluşturuluyor.
- in_place ile aldığı argümanları constructor'a parametre olarak geçiyor ve bu rargümanlar perfectforward ediliyor.

```c++
class Myclass {
public:
    Myclass() {cout << "default ctor\n";}
    ~Myclass() {cout << "dtor\n";}
    Myclass( const Myclass&) {cout << "copy ctor\n";}
    Myclass( Myclass&&) {cout << "move ctor\n";}
};

int main()
{
    using namespace std;
    optional<Myclass> op; // burada nesneyi construct etmiyor
    optional<Myclass> op1{Myclass{}}; // eğer move ctor varsaa o yoksa copy ctor çağırılıyro.
    optional<Myclass> op(in_place);  // doğrudan oluşturuldu
    // optional<Date> x {3,5,1987};
    optional<Date> x {in_place, 3,5,1987};
    auto x2 = make_optional<Date>(3,5,1987);
    cout << *x2 ;
    auto op = make_optional<Myclass>();
    auto op = std::optional<Myclass>(in_place);
}
```

###  Kullanıldığı Temalar

Değerinin olmasının kadar olmamasının da doğal olduğu durumlar:

- Aramada aranan değerin olması kadar değerin olmaması gibi. Aranan değer bulunursa dolu bir optional nesnesi döndürülür, bulunmazsa boş bir optional nesnesi döndürülür.
- Bir kişinin uygulamada nick'i olabilir/olmayabilir.
- Fonksiyonun parametre değişkeni optional olabilir.
- Sınıfın veri elemanı optional olabilir.
- Karşılaştırma operatörleri ile kullanılabilir. Değerinin nullopt olup olmadığını kontrol edebiliriz.

### Üye Fonksiyonları

- `reset` : optional nesnesini boşaltır. Tuttuğu nesnenin destructorını çağırıyor.

```c++
int main()
{
    using namespace std;
    optional<string> op;
    cout << op.has_value() << "\n"; // false
    op = "neco";
    cout << op.has_value() << "\n"; // true
    op.reset();
    cout << op.has_value() << "\n"; // false
    op ="deneme";
    cout << op.has_value() << "\n"; // true
    op = nullopt;
    cout << op.has_value() << "\n"; // false
    op ="deneme";
    //idiomatik
    op = {};
    cout << op.has_value() << "\n"; // false
}
```

- `swap` : iki optional nesnesinin değerlerini değiştirir.
- `emplace` : optional nesnesini doğrudan oluşturur. Eğer nesne dolu ise, mevcut nesneyi destroy eder ve yeni nesneyi oluşturur.

```c++
int main()
{
    usgin namespace std;
    optional<Myclass>op;
    op.emplace();
    cout << "Main devam ediyor";
    op.emplace();
    cout << "Main devam ediyor";
}
```

- `has_value` : optional nesnesinin değerinin olup olmadığını kontrol eder.
- `operator bool` : optional nesnesinin değerinin olup olmadığını kontrol eder.
- `operator*` : optional nesnesinin değerine erişir.
- `operator->` : optional nesnesinin değerine erişir.
- `value` : optional nesnesinin değerine erişir. Eğer değer yoksa exception throw eder.
- `value_or` : optional nesnesinin değerine erişir. Eğer değer yoksa parametre olarak verilen değeri döndürür.

- Boş optional nesnesi karşılaştırıldığı zaman
- nullopt nesnesi en küçük.

```c++
int main()
{
    using namespace std;
    optional x = "deneme"s;
    optional<string> y;

    cout << (x == y) << "\n"; // false
    cout << (y < x) << "\n"; // true
    x.reset();
    cout << (x == y) << "\n"; // true
}
```

- bool açılımı.

```c++
int main()
{
    using namespace std;
    optional<bool> x;
    optional<bool> y{true};
    optional<bool> z{false};

    cout << boolalpha<< (x == y) << "\n"; // false
    cout << (y < z) << "\n"; // false
    cout <<  (x == z) << "\n"; // false
}
```

- std::optional nesnesi return eden fonksiyonlar için

```c++

std::optional<string> get_name(int id)
{
    std::optional<string> name;
    if( has_nic(id))
        name = "deneme";
    else
        //return {};
        //return std::optional<string>{};
    //return name;
}

int main()
{
    using namespace std;

    if(optinal<string> name = get_name(12))
        cout << *name << "\n";
    else
        cout << "isim yok\n";

    if(auto op = get_name(12); op)
        cout << *op << "\n";
    else
        cout << "isim yok\n";

    if(auto op = get_name(12))
        cout << *op << "\n";
    else
        cout << "isim yok\n";

//alternatif olarak böyle de yazılabilir.
    if(auto op = get_name(13); op->size() > 10)
        cout << *op << "\n";
    else
        cout << "isim yok\n";
}
```

- Aşağıdaki kod içerisinde, verilen container'da bulunan ilk öğenin konumunu döndüren bir fonksiyon.
- Burada stl'den farklı olarak range almak yerine container ve predict yapıyor.

```c++
template <typename Con, typename Pred>
auto find_if(Con&& con, Pred&& pred)
{
    using std::begin, std::end;
    auto beg_iter = begin(c), end_iter = end(c);
    auto result = std::find_if(beg_iter, end_iter, pred);
    using iterator = decltype(result);
    if(result == end_iter)
        return std::optional<iterator>();
    return std::optional<iterator>(result);
}

template<typename Con, typename T>
auto find(Con&& c, const T& value)
{
    return find_if(std::forward<Con>(c), [&ival](auto&& x) { return x == value; });
}
```

- aldıpi string'i int değere dönüştürecek ve inte dönüştürülemez ise değer döndürülmeyecek.

```c++

std::optional<int> to_int(const std::string& s)
{
    try{
        return std::stoi(s);
    }
    catch(...) {
        return std::nullopt;
    }
}

std::optional<int> to_int(const std::string& s)
{
    std::optional<int> ret;
    try{
        ret = std::atoi(s);
    }
    catch(...){}

    return ret;
}

int main()
{
    for (auto s : {"42","077","necati","0x33"}) // initializer list sınıfı
    {
        std::optional<int> op = to_int(s);
        if(op)
            std::cout << *op << "\n";
        else
            std::cout << "gecersiz\n";
    }
}
```

### Taşınma semantiği

```c++
int main()
{
    std::optional<std::string> op1{"deneme"};
    auto op2 = op1; //copy-semantics
    cout << op1->length() << "\n"; // 6
    auto op3 = std::move(op1); //move-semantics
    cout << op1->length() << "\n"; // op1 moved from state'de
}
```

- Allignment ile alakalı problem oluşturabiliyor. Allign storage kullanıldığı için 

```c++
int main()
{
    cout <<  sizeof(double) << "\n"; // 8
    cout << sizeof(std::optional<double>) << "\n"; // 16
}
```

## std::variant

Optional ya bir değer tutuyor ya da tutmuyor. Variant ise önceden saptanmış türlerden birini tutuyor. C'deki `union` türüne benzer olarak düşünülebilir. Value semantics'e de uygun oluyor.

- Template argümanları olan türlerden birinden değer tutuyor. Bu türlere alternatif deniyor.
- Başlık dosyası `<variant>`
- `std::monostate` ile nullable type (boş ) bir tür oluşturulabilir.

```c++
temaplate<typename... Args>
class Variant
{};

itn main()
{
    Variant<int,double,std::string>
}
```

> union'ları low-level kodlar dışında çok fazla kullanmamaya çalış. Birlik nesnesi hangi alternatifi tuttuğunu bilemez.

- Burada union yerine variatn türünü kullanırsak hangi türü tuttuğunu bilecek.
- Kaynak sızıntısına bir neden yaratmıyor.

> Bu tür sınıflara **tagged/discriminated union** da deniyor.

- Variant türü kendi içerisinde tutuyor dynamic memory allocation tutmuyor ve bu da en az en büyük boyuta sahip türe sahip olan türün boyutu kadar bir yer tutması anlamına geliyor. 

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v;    
}
```

### Constructor

- Default edilmiş bir variant nesnesi ilk alternatifi tutuyor. O de value initialize edildiği için bu variant default initialize edilebilir değilse bir sentaks hatası oluşmasına sebep olabilir.

- Alternatiflerden birine dönüştürülecek türden bir argümanla construct edilebilir.
- - Burada bir ambiguity oluşabilir. Eğer birden fazla alternatiften biri seçilebilir olduğunda ambiguity oluşabilir. Function overload resolution kurallarına göre seçim yapılabilir.

```c++

int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    variant<int,double,string> v{3.4f}; // double
}
```

### Hangi alternatifin tutulduğunu öğrenme

- *const* üye fonksiyonu olan indexi çağırarak hangi alternatifin tutulduğunu öğrenebiliriz.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    cout << v.index() << "\n"; // 0
    v = 3.4f;
    cout << v.index() << "\n"; // 1
}
```

- holds_alternative fonksiyon şablonunu çağırmak bu fonksiyon bize bool değer döndürüyor.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    cout << boolalpha <<holds_alternative<int>(v) << "\n"; // true
    cout << holds_alternative<double>(v) << "\n"; // false
    cout << holds_alternative<string>(v) << "\n"; // false
    v = 3.4f;
    cout << holds_alternative<int>(v) << "\n"; // false
    cout << holds_alternative<double>(v) << "\n"; // true
    cout << holds_alternative<string>(v) << "\n"; // false
}
```

- Bazı kontroller compile time içerisinde yapılıyor.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    if(holds_alternative<char>(v)) // compile time hatası
        cout << "char\n";
}
```

### Yardımcı sınıflar

#### in_place_index_t ve in_place_type_t

- bunlar constexpr variable'lar. Bunlarda variant nesnesinin kullanıldığı alternatifi seçmek için kullanılıyor.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{in_place_index<0>, 12}; // int
    variant<int,double,string> v{in_place_index<1>, 3.4f}; // double
    variant<int,double,string> v{in_place_index<2>, 10, 'b'}; // string
    variant<int,double,string> v{in_place_type<double>, 3.4f}; // double
    variant<int,double,string> v{in_place_type<string>, 10,A}; // string
}
```

- Böylece verilen değerler perfect forward ediliyor.
- Eğer default construct etmek istiyorsak kullanılabilir.
- Eğer variantın tuttuğu türlerden birinin constructor'u birden fazla argüman alıyorsa, bunu çağırmak için kullanılabilir.
- Eğer bir ambiguitiy oluşmasını engellmek istiyorsak kullanılabilir.
- Eğer birden fazla tür birbiri ile aynı ise. Bu durumda bunu belirtmek için kullanılabiliriz.

### Sizeof

- Variant türü, alternatiflerden en büyük boyuta sahip olan türün boyutu kadar yer tutar.
- Small buffer optimization yapmıyor.

```c++
int main()
{
    using namespace std;
    cout << " int"<<sizeof(int) << "\n"; // 4
    cout <<" double"<< sizeof(double) << "\n"; // 8
    cout << " string"<<sizeof(string) << "\n"; // 32
    cout << sizeof(variant<int,double,string>) << "\n"; // 24
}
```

### Varianta erişme

#### Get Fonksiyonu

- `get` fonksiyonu ile variant nesnesinin tuttuğu türün değerine erişebiliriz. Eğer tutmadığı bir değere erişmeye çalışırsak, bir exception throw ediyor. Tanımsız bir davranış yok.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12.3}; // int
try {
    cout << get<0>(v) << "\n"; // 12
}
catch(const std::bad_variant_access& e) {
    std::cout << e.what() << '\n';
}
}
```

- Burada verilen index eğer yok ise compile time'da sentaks hatası veriyor.
- Index ile erişmek dışında tür ile erişmek için get fonksiyonu kullanılabilir.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12.3}; // int
    cout << get<int>(v) << "\n"; // 12
    cout << get<double>(v) << "\n"; // 12.3
    cout << get<string>(v) << "\n"; // exception
}
```

#### Get-if fonksiyonu

- Exception throw etmiyor ve pointer semantiği ile kullanılıyor. Eğer doğru olmayan alternatif seçilmişse nullptr döndürüyor.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v{12.3}; // int
    if(auto p = get_if<int>(&v)) // p nin türü int * 
        cout << *p << "\n"; // 12
    else
        cout << "int değil\n";
}
```

- Bu şekilde aşağıdaki gibi bir kolaylık sağlıyor.

```c++
int main()
{
    using namespace std;
    variant<int, double, string> vx("mustafa");
    if (vx.index() == 2) 
    {
        std::cout « "alternative string : " « get<2>(vx) < '\n';
    }
    if (holds_alternative<string>(vx)) 
    {
        std::cout « "alternative string : " « get<2>(vx) « '\n';
    }
    if (auto sptr = get_if<string>)
    {
        std::cout « "alternative string : " « *sptr « '\n';
    }
}
```

- if-else merdiveni kullanarak buradan variantın elde ettiği değer elde edilebilir.

```c++
int main()
{
    using namespace std;
    variant<int, double, string> vx("mustafa");
    if (auto sptr = get_if<string>(&vx))
    {
        std::cout « "alternative string : " « *sptr « '\n';
    }
    else if (auto dptr = get_if<double>(&vx))
    {
        std::cout « "alternative double : " « *dptr « '\n';
    }
    else if (auto iptr = get_if<int>(&vx))
    {
        std::cout « "alternative int : " « *iptr « '\n';
    }

    if(holds_alternative<string>(vx))
    {
        std::cout << "alternative string : " << get<string>(vx) << '\n';
    }
    else if(holds_alternative<double>(vx))
    {
        std::cout << "alternative double : " << get<double>(vx) << '\n';
    }
    else if(holds_alternative<int>(vx))
    {
        std::cout << "alternative int : " << get<int>(vx) << '\n';
    }

    if(vx.index() == 2)
    {
        std::cout << "alternative string : " << get<2>(vx) << '\n';
    }
    else if(vx.index() == 1)
    {
        std::cout << "alternative double : " << get<1>(vx) << '\n';
    }
    else if(vx.index() == 0)
    {
        std::cout << "alternative int : " << get<0>(vx) << '\n';
    }   
}
```

- Bazı durumlarda C++ yeni standartlar ile backward-compatibility kırılabiliyor. Aşağıdaki kodda C++17'de bool seçilirken, c++20'de string seçiliyor.

```c++
int main()
{
    using namespace std;
    variant<bool, string> vx("mustafa");
    cout << vx.index() << "\n"; // 1 fakat eğer bu kod C++17 olsaydı bool 
}
```

- Kodun daha kolay okunabilmesi için aşağıdaki gibi bir kod yazılabilir.

```c++
int main()
{
    using namespace std;
    enum idx : size_t {age,wage,name};
    using Age = int;
    using Wage = double;
    using Name = string;
    variant<Age,Wage,Name> vx("test"); // ayni ya int ya double ya da string
    cout << get<age>(vx);
    cout << get<Age>(vx);
}
```

#### Atama Yapma Yolları

Doğrudan variant türüne ambiguity oluşturmadan dönüştürülecek bir değer ile atama yapabiliyoruz.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v; // int
    v = 12; // int
    v = 3.4f; // double
    v = "neco"; // string
    v = string(19,'a');
}
```

- Emplace fonskiyonu ile variant nesnesinin tuttuğu türden bir atama yapabiliriz. Eski değeri destroy eder ve yeni değer oluşturuyor.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> v; // int
    v.emplace<int>(12); // int
    v.emplace<double>(3.4f); // double
    v.emplace<string>(19,'a'); // string
}
```

#### monostate sınıfı

Variant başlık dosyasında std::monostate isimli bir sınıf var ve bu bir örüntü, buradaki tüm alternatifler tek bir değere sahip. Bize iki avantaj sağlıyor.

- Tek bir state'e sahip olduğu için karşılaştırma işlemlerinde variantın boş olması anlamına geliyor.
- Varaintların kullanıldığı bazı türler için default constructor olmuyor bu durumda monostate kullanılıyor.

Tipik olarak variant ilk alternatif yapılıyor.

```c++
struct A {A(int) {}};
struct B {B(int) {}};
int main()
{
    using namespcae std;
    //variant<B,A> vx; bu durudma sentaks hatası oluyor ve bunun yerine
    variant<monostate, A, B> vx; //
}
```

- Eğer monostate durumuna çekmek istersek:

```c++
int main()
{
    using namespace std;
    variant<monostate,int,double,string> vx(4.5);
    vx ={};
    vx = monostate{};
    vx.emplace<0>();
    vx.emplace<monostate>{};
}
```

#### Visitor paterni

- Variantlar için en sık yapılan işlem alternatife erişmek ve alternatif üzerinde işlem yapmak. Bu fonksiyon variadic bir fonksiyon şablonu ve bu fonksiyon bir veya birden fazla variantlar üzerinde işlem yapabilir.

```c++
template<class Visitor, class Variants>
constexpr visit(Visitor&&vis, Variants)
```

- Visit fonksiyonu variantın seçimini kendisi yapıcak. Burada verilen callable için verilen functor classın tüm variantlar için çağırıalbilir olması gerekiyor.

```c++
struct PrintVisitor
{
    void operator()(int x)const
    {
        std::cout<< "int : " << x << "\n";
    }
    void operator()(double x)const
    {
        std::cout<< "int : " << x << "\n";
    }
    void operator()(const std::string x)const
    {
        std::cout<< "int : " << x << "\n";
    }
};

struct IncrementVisitor
{
    void operator()(int& x)const
    {
        x++;
    }
    void operator()(double& x)const
    {
        x++;
    }
    void operator()(std::string& x)const
    {
        x += "x";
    }
};

int main()
{
    using namespace std;
    variant<int,double,string> vx("deneme");
    PrintVisitor pr;
    IncrementVisitor inc;
    //visit(pr, vx);
    visit(PrintVisitor{}, vx);
    visit(inc, vx);
    visit(pr, vx);
}
```

- Visitor sınıfı aşağıdaki gibi de yapılabilirdi

```c++
struct PrintVisitor
{
    template<typename T>
    void operator()(const T& x)const
    {
        std::cout<< "int : " << x << "\n";
        /*kodu ayrı yapmak için*/
        if constexpr(std::is_same_v<T,int>)
        {
            std::cout<< "int : " << x << "\n";
        }
        else if constexpr(std::is_same_v<T,double>)
        {
            std::cout<< "double : " << x << "\n";
        }
        else if constexpr(std::is_same_v<T,string>)
        {
            std::cout<< "string : " << x << "\n";
        }
    }
    //böyle yazmak yerine
    void operator()(const auto & x)const
    {
        std::cout<< "int : " << x << "\n";
    }
};
```

- Visiter için birden fazla sınıf yazmamız mümkün.
- Burada kullanılan sınıf functor sınıf olduğu için lambda ifadesi de kullanabiliriz.

```c++
int main()
{
    using namespace std;
    variant<int,double,string> vx("deneme");
    visit([](const auto& x) { std::cout << x << "\n"; }, vx);
}
```

> 9.Ders Başlangıcı

