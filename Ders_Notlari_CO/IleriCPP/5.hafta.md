# 5.Hafta

---

> 08_22_07_2023

---

## std::optional

- It is recommended to use `optional<T>` sin situations where theere is exactly one, clear ( to all parties) reason for having no value of type T, and where the lack of a value is as natural as having any regular value of type T.

### Nesnesini nasıl oluştururuz?

- Default initialize edilmiş bir `optional` nesnesi, `std::nullopt` durumunda. Default construct edilmiş nesnesi default contsrukt edilmiş bir `T` türünden nesnesine sahip değil.

```cpp
int main()
{
    using namespace std;
    std::optional<int> opt; // default initialize edilmiş bir nesne
    boolalpha(cout);
    cout << boolalpha;
    cout << op.has_value() << "\n"; // false
    
    if(op) { cout << "bir deger var\n"; }
    else { cout << "deger yok\n"; }
    cout << ( op == nullopt)<< "\n"; 
}
```

### Erişmenin yolları

- Tipik bir sarmalıyıcı olduğu için doğrudan değiştirilecek bir nesne de kullanabiliriz.
- - Eğer boş bir optional nesnesine erişmeye çalışırsak, undefined behavior oluşur.

```cpp
int main()
{
    using namespace std;
    std::optional<string> op{"deneme"};
    cout << *op<< "\n"; // deneme
    cout << op->size();
    //cout << *op; //Eğer boş olsaydı ub olurdu
}
```

- `op.value()` fonksiyonu ile de değere erişebiliriz ve bu fonksiyon çağırıldığında exception throw ediyor.

```cpp
int main()
{
    using namespace std;
    std::optional<string> op;
    try {
        cout << op.value() << "\n"; // deneme
        cout << op.value().size();
    }
    catch(const std::bad_optional_access& e) {
        std::cout << e.what() << '\n';
    }
}
```

- `op.value_or()` fonksiyonu eğer optional nesnesi bir değer tutuyorsa bu değeri döndürür, eğer boş ise, parametre olarak verilen değeri döndürür.

```cpp
int main()
{
    using namespace std;
    std::optional<string> op;
    cout << op.value_or("bos") << "\n"; // bos
    std::optional<string> op2{"deger"};
    cout << op2.value_or("bos") << "\n"; // deger
}
```

- `value_or` fonksyionu `value` dan farklı olarak sol taraf referans döndürmüyor.
  
- std::optional nesnesi bir referans tutamıyor fakat reference wrapper ile bunu yapabiliriz. Fabrika fonksiyonlarını kullanabiliyoruz

```cpp
int main()
{
    using namespace std;
    string name {"deneme"};
    std::optional<reference_wrapper<string>> op(ref(name));
    op->get() +=  "test";
    //CTAD
    optional x = 12;
}
```

### In_place ve make_optional

Yardımcı bir `in_place_t` nesnesi var ve bu türden bir değişkenimiz var `in_place`.

- Default construct edilmiş bir optional nesnesini oluşturmamız mümkün değil default olarak nesneyi construct etmiyor.
- Eğer inplace objesi ile optional nesnesini oluşturursak, bu durumda nesne doğrudan oluşturuluyor.
- in_place ile aldığı argümanları constructor'a parametre olarak geçiyor ve bu rargümanlar perfectforward ediliyor.

```cpp
class Myclass {
public:
    Myclass() {cout << "default ctor\n";}
    ~Myclass() {cout << "dtor\n";}
    Myclass( const Myclass&) {cout << "copy ctor\n";}
    Myclass( Myclass&&) {cout << "move ctor\n";}
};

int main()
{
    using namespace std;
    optional<Myclass> op; // burada nesneyi construct etmiyor
    optional<Myclass> op1{Myclass{}}; // eğer move ctor varsaa o yoksa copy ctor çağırılıyro.
    optional<Myclass> op(in_place);  // doğrudan oluşturuldu
    // optional<Date> x {3,5,1987};
    optional<Date> x {in_place, 3,5,1987};
    auto x2 = make_optional<Date>(3,5,1987);
    cout << *x2 ;
    auto op = make_optional<Myclass>();
    auto op = std::optional<Myclass>(in_place);
}
```

###  Kullanıldığı Temalar

Değerinin olmasının kadar olmamasının da doğal olduğu durumlar:

- Aramada aranan değerin olması kadar değerin olmaması gibi. Aranan değer bulunursa dolu bir optional nesnesi döndürülür, bulunmazsa boş bir optional nesnesi döndürülür.
- Bir kişinin uygulamada nick'i olabilir/olmayabilir.
- Fonksiyonun parametre değişkeni optional olabilir.
- Sınıfın veri elemanı optional olabilir.
- Karşılaştırma operatörleri ile kullanılabilir. Değerinin nullopt olup olmadığını kontrol edebiliriz.

### Üye Fonksiyonları

- `reset` : optional nesnesini boşaltır. Tuttuğu nesnenin destructorını çağırıyor.

```c++
int main()
{
    using namespace std;
    optional<string> op;
    cout << op.has_value() << "\n"; // false
    op = "neco";
    cout << op.has_value() << "\n"; // true
    op.reset();
    cout << op.has_value() << "\n"; // false
    op ="deneme";
    cout << op.has_value() << "\n"; // true
    op = nullopt;
    cout << op.has_value() << "\n"; // false
    op ="deneme";
    //idiomatik
    op = {};
    cout << op.has_value() << "\n"; // false
}
```

- `swap` : iki optional nesnesinin değerlerini değiştirir.
- `emplace` : optional nesnesini doğrudan oluşturur. Eğer nesne dolu ise, mevcut nesneyi destroy eder ve yeni nesneyi oluşturur.

```cpp
int main()
{
    usgin namespace std;
    optional<Myclass>op;
    op.emplace();
    cout << "Main devam ediyor";
    op.emplace();
    cout << "Main devam ediyor";
}
```

- `has_value` : optional nesnesinin değerinin olup olmadığını kontrol eder.
- `operator bool` : optional nesnesinin değerinin olup olmadığını kontrol eder.
- `operator*` : optional nesnesinin değerine erişir.
- `operator->` : optional nesnesinin değerine erişir.
- `value` : optional nesnesinin değerine erişir. Eğer değer yoksa exception throw eder.
- `value_or` : optional nesnesinin değerine erişir. Eğer değer yoksa parametre olarak verilen değeri döndürür.

- Boş optional nesnesi karşılaştırıldığı zaman
- nullopt nesnesi en küçük.

```cpp
int main()
{
    using namespace std;
    optional x = "deneme"s;
    optional<string> y;

    cout << (x == y) << "\n"; // false
    cout << (y < x) << "\n"; // true
    x.reset();
    cout << (x == y) << "\n"; // true
}
```

- bool açılımı.

```cpp
int main()
{
    using namespace std;
    optional<bool> x;
    optional<bool> y{true};
    optional<bool> z{false};

    cout << boolalpha<< (x == y) << "\n"; // false
    cout << (y < z) << "\n"; // false
    cout <<  (x == z) << "\n"; // false
}
```

- std::optional nesnesi return eden fonksiyonlar için

```cpp

std::optional<string> get_name(int id)
{
    std::optional<string> name;
    if( has_nic(id))
        name = "deneme";
    else
        //return {};
        //return std::optional<string>{};
    //return name;
}

int main()
{
    using namespace std;

    if(optinal<string> name = get_name(12))
        cout << *name << "\n";
    else
        cout << "isim yok\n";

    if(auto op = get_name(12); op)
        cout << *op << "\n";
    else
        cout << "isim yok\n";

    if(auto op = get_name(12))
        cout << *op << "\n";
    else
        cout << "isim yok\n";

//alternatif olarak böyle de yazılabilir.
    if(auto op = get_name(13); op->size() > 10)
        cout << *op << "\n";
    else
        cout << "isim yok\n";
}
```

- Aşağıdaki kod içerisinde, verilen container'da bulunan ilk öğenin konumunu döndüren bir fonksiyon.
- Burada stl'den farklı olarak range almak yerine container ve predict yapıyor.

```c++
template <typename Con, typename Pred>
auto find_if(Con&& con, Pred&& pred)
{
    using std::begin, std::end;
    auto beg_iter = begin(c), end_iter = end(c);
    auto result = std::find_if(beg_iter, end_iter, pred);
    using iterator = decltype(result);
    if(result == end_iter)
        return std::optional<iterator>();
    return std::optional<iterator>(result);
}

template<typename Con, typename T>
auto find(Con&& c, const T& value)
{
    return find_if(std::forward<Con>(c), [&ival](auto&& x) { return x == value; });
}
```

- aldıpi string'i int değere dönüştürecek ve inte dönüştürülemez ise değer döndürülmeyecek.

```cpp

std::optional<int> to_int(const std::string& s)
{
    try{
        return std::stoi(s);
    }
    catch(...) {
        return std::nullopt;
    }
}

std::optional<int> to_int(const std::string& s)
{
    std::optional<int> ret;
    try{
        ret = std::atoi(s);
    }
    catch(...){}

    return ret;
}

int main()
{
    for (auto s : {"42","077","necati","0x33"}) // initializer list sınıfı
    {
        std::optional<int> op = to_int(s);
        if(op)
            std::cout << *op << "\n";
        else
            std::cout << "gecersiz\n";
    }
}
```

### Taşınma semantiği

```c++
int main()
{
    std::optional<std::string> op1{"deneme"};
    auto op2 = op1; //copy-semantics
    cout << op1->length() << "\n"; // 6
    auto op3 = std::move(op1); //move-semantics
    cout << op1->length() << "\n"; // op1 moved from state'de
}
```

- Allignment ile alakalı problem oluşturabiliyor. Allign storage kullanıldığı için 

```cpp
int main()
{
    cout <<  sizeof(double) << "\n"; // 8
    cout << sizeof(std::optional<double>) << "\n"; // 16
}
```

## std::variant

Optional ya bir değer tutuyor ya da tutmuyor. Variant ise önceden saptanmış türlerden birini tutuyor. C'deki `union` türüne benzer olarak düşünülebilir. Value semantics'e de uygun oluyor.

- Template argümanları olan türlerden birinden değer tutuyor. Bu türlere alternatif deniyor.
- Başlık dosyası `<variant>`
- `std::monostate` ile nullable type (boş ) bir tür oluşturulabilir.

```cpp
temaplate<typename... Args>
class Variant
{};

itn main()
{
    Variant<int,double,std::string>
}
```

> union'ları low-level kodlar dışında çok fazla kullanmamaya çalış. Birlik nesnesi hangi alternatifi tuttuğunu bilemez.

- Burada union yerine variatn türünü kullanırsak hangi türü tuttuğunu bilecek.
- Kaynak sızıntısına bir neden yaratmıyor.

> Bu tür sınıflara **tagged/discriminated union** da deniyor.

- Variant türü kendi içerisinde tutuyor dynamic memory allocation tutmuyor ve bu da en az en büyük boyuta sahip türe sahip olan türün boyutu kadar bir yer tutması anlamına geliyor. 

```cpp
int main()
{
    using namespace std;
    variant<int,double,string> v;    
}
```

### Constructor

- Default edilmiş bir variant nesnesi ilk alternatifi tutuyor. O de value initialize edildiği için bu variant default initialize edilebilir değilse bir sentaks hatası oluşmasına sebep olabilir.

- Alternatiflerden birine dönüştürülecek türden bir argümanla construct edilebilir.
- - Burada bir ambiguity oluşabilir. Eğer birden fazla alternatiften biri seçilebilir olduğunda ambiguity oluşabilir. Function overload resolution kurallarına göre seçim yapılabilir.

```cpp

int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    variant<int,double,string> v{3.4f}; // double
}
```

### Hangi alternatifin tutulduğunu öğrenme

- *const* üye fonksiyonu olan indexi çağırarak hangi alternatifin tutulduğunu öğrenebiliriz.

```cpp
int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    cout << v.index() << "\n"; // 0
    v = 3.4f;
    cout << v.index() << "\n"; // 1
}
```

- holds_alternative fonksiyon şablonunu çağırmak bu fonksiyon bize bool değer döndürüyor.

```cpp
int main()
{
    using namespace std;
    variant<int,double,string> v{12}; // int
    cout << boolalpha <<holds_alternative<int>(v) << "\n"; // true
    cout << holds_alternative<double>(v) << "\n"; // false
    cout << holds_alternative<string>(v) << "\n"; // false
    v = 3.4f;
    cout << holds_alternative<int>(v) << "\n"; // false
    cout << holds_alternative<double>(v) << "\n"; // true
    cout << holds_alternative<string>(v) << "\n"; // false
}
```

### Yardımcı sınıflar

#### in_place_index_t ve in_place_type_t

- bunlar constexpr variable'lar. Bunlarda variant nesnesinin kullanıldığı alternatifi seçmek için kullanılıyor.

```cpp
int main()
{
    using namespace std;
    variant<int,double,string> v{in_place_index<0>, 12}; // int
    variant<int,double,string> v{in_place_index<1>, 3.4f}; // double
    variant<int,double,string> v{in_place_index<2>, 10, 'b'}; // string
    variant<int,double,string> v{in_place_type<double>, 3.4f}; // double
    variant<int,double,string> v{in_place_type<string>, 10,A}; // string
}
```

- Böylece verilen değerler perfect forward ediliyor.
- Eğer default construct etmek istiyorsak kullanılabilir.
- Eğer variantın tuttuğu türlerden birinin constructor'u birden fazla argüman alıyorsa, bunu çağırmak için kullanılabilir.
- Eğer bir ambiguitiy oluşmasını engellmek istiyorsak kullanılabilir.
- Eğer birden fazla tür birbiri ile aynı ise. Bu durumda bunu belirtmek için kullanılabiliriz.

### Sizeof

- Variant türü, alternatiflerden en büyük boyuta sahip olan türün boyutu kadar yer tutar.
- Small buffer optimization yapmıyor.

```cpp
int main()
{
    using namespace std;
    cout << " int"<<sizeof(int) << "\n"; // 4
    cout <<" double"<< sizeof(double) << "\n"; // 8
    cout << " string"<<sizeof(string) << "\n"; // 32
    cout << sizeof(variant<int,double,string>) << "\n"; // 24
}
```

> 2:25:00.
