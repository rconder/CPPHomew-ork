# 6.Hafta

## CTAD: Class Template Argument Deduction

- Aslında C++17 dile eklenen sınıf şablonları için bir tür çıkarımının yapılması. Artık C++17 ile sınıf şablonları içinde bir tür çıkarımı sağlanıyor.
- - Çıkarımın yapılmasını sağlamak veya derleyici yönlendirmek için `deduction guide` dile eklendi. User-type sınıflar içinde bu çıkarımı yapabiliyoruz.
- Kodların yazımını ve okunmasını kolaylaştırıyor.
- Kod kalabalığını azaltmak için daha önceden fabrika fonksiyonu kullanılıyordu.

```cpp
int main()
{
    using namespace std;
    auto p = make_pair(12, 5); // pair<int, int> çıkarımı fonksiyon için yapılabiliyor.
}
```

- Artık make_pair'i kullanmak yerine CTAD'dan faydalanılabilir.
- Derleyici consturctorlara bakarak tür çıkarımı yapabiliyor. Hom type hem de non-type parametreleri için bu çıkarım yapılabiliri.
- Aggregat sınıflar için de bu çıkarım yapılabilir. Burada C++20 ile bazı farklılıklar oluştu.
- CTAD'ın constructor'ın explicit olup olmaması çıkarımı ekliyor
- Argümanların sınıf türünden olmasında da bir sakınca yok.

```cpp
template <typename T>
class MyClass
{
public:
    MyClass(const T& x) : mx{x}{
        std::cout <<  typeid(T).name() << "\n";
    }
    T mx;
};

template <typename T>
Myclass<T> make_myclass(const T& x)
{
    return Myclass<T>{x};
}
int main()
{
    Myclass<int> x{12}; // C++17'den önce bu şekilde yazılıyordu.
    auto mx = make_myclass{20}; /// CTAD olmadığından dolayı bu şekilde yazılıyor.
   Myclass m(12);  
}
```

- Çıkarımlar daha complex senaryolarla da yapılabilir.

```cpp
template <typename T, typename U>
class Myclass
{
public:
    Myclass(const T& x, const U& y) : mx{x}, my{y}{
        std::cout <<  typeid(T).name() << "\n";
        std::cout <<  typeid(U).name() << "\n";
    }
    T mx;
    U my;
};

int main()
{
    Myclass x{12, 5.24}; // C++17'den önce bu şekilde yazılıyordu.
    auto mx = Myclass{20, 5};
    Myclass m(12, "denem");
}
```

- Örneğin array sınıfını sarmalayan bir template sınıf çıkarımı.

```cpp
template <typename T, std::size_t N>
class Myclass
{
public:
    Myclass(T(&)[N])
    {
        std::cout << typeid(T).name() << "\n";
        std::cout << "constant N is" << N << "\n";
    }
};

int main()
{
    int a[10]();
    //Myclass<int,10> myclass(a);
    Myclass myclass2(a);
    double a[]{1.,3.,5.,7.,9.};
    Myclass 
}
```

- Function pointer ile de kullanılabilir. Geri dönüş değeri T türü olan ve parametresi dizeye referans olan bir function pointer

```cpp
template <typename T, typename U, std::size_t N>
class Myclass
{
public:
    Myclass(T(*)(U(&)[N]))
    {
        std::cout << typeid(T).name() << "\n";
        std::cout << typeid(U).name() << "\n";
        std::cout << "constant N is" << N << "\n";
    }
};

int foo(double(&)[20]){return 1;}

int main()
{    
    Myclass my(foo);
}
```

- Default argümandan da yararlanabiliyoruz. Birden fazla default argüman içinde bundan yararlanabiliyoruz.

```c++
template <typename T = double>
struct Myclass
{
    Myclass() :val(){}
    Myclass(T x = 0) : mx{x} {}
    T mx;
};

Myclass m1{19};
Myclass m2;  // Myclass<double> m2;
```

> `T{}` eğer sınıf türleri ise default ctor çağırılır, eğer aritmetik türlerden bir tür ise 0 ile başlatılır.

```c++
template <typename T = double, typename U = int, typename W = long>
class Myclass
{
public:
    Myclass(T x = T{}, U y = U{}, W z = W{}) : mx{x}, my{y}, mz{z} {}
    T mx;
    U my;
    W mz;
};

int main()
{
    Myclass m1{12, 5, 7}; // Myclass<int, int, int> m1{12, 5, 7};
    Myclass m2; // Myclass<double, int, long> m2;
}
```

- Çıkarım yapılırken ilk parametre için çıkarım yapılsın fakat ikinci parametreyi kullanayım gibi bir sentaks yok.

```c++
template <typename T, std::size_t N >
struct Array
{};

int main()
{
    std::array a{1,3,4,5,6,6};
    //std::array<> a{1,3,4,5,6,6};
}
```

- standart kütüphanenin örnekleri

```c++
int main()
{
    using namespace std;
    vector v{1,2,3,4,5,6,7,8,9,10}; // vector<int> v{1,2,3,4,5,6,7,8,9,10};
    list l{1,2,3,4,5,6,7,8,9,10}; // list<int> l{1,2,3,4,5,6,7,8,9,10};
    set s{1,2,3,4,5,6,7,8,9,10}; // set<int> s{1,2,3,4,5,6,7,8,9,10};
    set s2{1,2,3,4,5,6,7,8,9,10}, [](int a,int b){return b<a;}; //
}
```

```c++
template<typename F>
class Myclass
{
public:
    Myclass(F f) : mf{f} {
        std::cout << typeid(F).name() << "\n";
    }
    F mf;
};

int main()
{
    Myclass m{std::less<int>{}}; 
    // Myclass<lambda> m{[](int x, int y){return x + y;}};
}
```

- Joustis örneği

```c++
template <typename T>
class CountCalls
{
public:
    CountCalls(T f) : mf{f} {}
    T mf;
    int count{};
    template <typename... Args>
    auto operator()(Args&&... args)
    {
        ++count;
        return mf(std::forward<Args>(args)...);
    }
    int count() const { return count; }
private:
    T mf;
    int count{};
};

int main()
{
    using namespace std;
    vector<string>msvec;
    rfill(mvec,10000,rname);
    auto f = CountCalls{[](const string &s, const string y){return s.size() < y.size();}};    
    sort(mvec.begin(),mvec.end(),ref(f));
    //ref fonksiyonu 
    cout<< "f.count() = " << f.count() << "\n";
    // Myclass<lambda> m{[](int x, int y){return x + y;}};
}
```
