# 9.Hafta

- 15.Ders ve 16.Ders notları.

## İçindekiler

- [9.Hafta](#9hafta)
  - [İçindekiler](#i̇çindekiler)
  - [std::format Kütüphanesi](#stdformat-kütüphanesi)
    - [Custom Fomratting](#custom-fomratting)
    - [vFormat Fonksiyonu](#vformat-fonksiyonu)
  - [Aggregate Type](#aggregate-type)
    - [Semantik tarafı](#semantik-tarafı)
    - [Koşulları](#koşulları)
    - [Faydaları](#faydaları)
      - [Aggregate Initialization](#aggregate-initialization)
      - [Structure Binding](#structure-binding)
      - [C++20 İle Gelen Değişiklik](#c20-i̇le-gelen-değişiklik)
      - [Designated Initializer Sentaksı](#designated-initializer-sentaksı)
        - [Faydası Ne](#faydası-ne)
    - [](#)

---

> 19_08_2023

---

## std::format Kütüphanesi

`[[fill]align] [sign][#][0][width][.precision][type]`

### Custom Fomratting

- Parso fonksiyonun normalde `constexpr` fonksiyon olması bekleniyor, fakat bazı derleyiciler bu fonkksiyonun `constexpr` olması durumunda hata veriyor.
- - Parametresi `std::format_parse_context &` türünden olmalı, geri dönüş değeri de bu sınıfın `iterator` türünden olmalı.
- - `"{:12}"` elimizde olsun ve `begin()` fonksiyonu burada `12}`nin başını gösteriyor. `end()` fonksiyonu ise yazının sonunu gösteriyor. `ali{:<2.f}\n` olsaydı `end()` fonksiyonu '\n' karakterini gösterirdi.s
- - Birden fazla küme parantezi olsaydı bu işlem her bir küme parantezi için ayrı ayrı yapılacaktı. Parse fonksiyonu braclet'ın kapandığı konumu döndürmesi gerekiyor. Yanş begin fonksiyonunndan aldığımız konumdan başlayarak kapann küme parantezinin konumunu döndürmesi gerekiyor.
- Bir de format fonksiyonu yazmamaız gerekiyor, 1. parametre basttırılcak sınıf neseis, 2. parametre `format_context`.
- - Bu fonksiyon `format_to` fonksiyonunun geri dönüş değeri veriyor.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
class std::formatter<Mint> {
public:
    constexpr auto parse(format_parse_context& ctx) {
        auto iter = ctx.begin();
        while (iter != ctx.end() && *iter != '}') {
            if (*iter < '0' || *iter > '9') {
                //exception throw edilebilir.
                //throw std::format_error{"invalid width character"};
                throw std::format_error{std::format("invalid width character: {}", *iter)};
            }
            m_width = m_width * 10 + (*iter - '0');
            ++iter;
        }            

        return iter;
    }

   auto format(const Mint& m, format_context& ctx) 
   {
        //return std::format_to(ctx.out, "Mint: {}", m.get());
        return std::format_to(ctx.out(),"{:{}}",m.get(),m_width);
   }
   int m_width{};
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{:15}", m) << endl; //begin fonksiyonu 1'in konumunu döndürecek 15'i bir tam sayı değeri olarak alacagız
}
```

- Tüm parametre özelliklerini tutmak istiyorsak format kütüphanesinin specializasyonları var. Int örneği için standart kütüphanenin bir specializasyonu var.

Bunu 2 farklı şekilde yapabiliriz. Sınıfımızda veri elemanı tutarak formatlamayı bu nesneye yaptırabiliriz ya da kalıtımdan yararlanarak yapabiliriz.

- derleyiciye bağlı olarak mutable keyword'ünü eklememiz gerekebilir.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
class std::formatter<Mint> {
public:
    // mutable  std::formatter<int> mf;
    std::formatter<int> mf;
    //constexpr olması da sentaks hatası oluşturuyor olabilir.
    //constexpr auto parse(format_parse_context& ctx) 
    auto parse(format_parse_context& ctx) 
    {
        return mf.parse(ctx);
    }

   auto format(const Mint& m, format_context& ctx) 
   {
        return mf.format(m.get(), ctx);
   }

   int m_width{};
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{0:$>15} {0:_<15",m); 
}
```

- Kalıtım ile:

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
struct std::formatter<Mint> : std::formatter<int>
{
    auto format(const Mint& m, auto& ctx)
    {
        return std::formatter<int>::format(m.get(), ctx);
    }
};

int main()
{
    using namespace std;
    Mint m(145);
    cout << format("{0:$>15} {0:_<15",m); 
}
```

- Kalıtım ile custom type için:

```cpp
#include <format>
#include <iostream>


enum class Fruit
{
    Apple,
    Orange,
    Banana
};

template<>
struct std::formatter<Fruit> : public std::formatter<std::string>
{
    auto format(Fruit f, std::format_context& ctx)
    {
        std::string name;
        switch (f)
        {
        using enum Fruit;
        case Apple:
            name = "Apple";
            break;
        case Orange:
            name = "Orange";
            break;
        case Banana:
            name = "Banana";
            break;
        default:
            name = "Unknown";
            break;
        }
        return std::formatter<std::string>::format(name, ctx);
    }  
};

int main()
{
    Fruit f = Fruit::Apple;
    std::cout << std::format("Fruit: {:_<16}",f); 
}
```

Oluşturulabilir.

- Constexpr ve mutable olması ile ilgili olan durumlar derleyiciye bağlı olarak değişebilir. Bunun için koşulları aşağıdaki gibi sınayabiliriz.

```cpp
#include <iostream>
#include <format> 
#include <string>

class Mint {
public:
    Mint() = default;
    Mint(int x) : mx(x) {}
    int get() const { return mx; }
private:
    int mx;
};

template<>
struct std::formatter<Mint> : std::formatter<int>
{
#if __cpp_lib_format < 202106
    mutable //in case the standard formatters have a non-const format
#endif
    std::formatter<int>mf;
#if __cpp_lib_format >= 202106 //in case standard formatters don't support constexpr parse() yet
    constexpr
#endif
    auto parse(format_parse_context& ctx)
    {
        return mf.parse(ctx);
    }
  auto format(const Mint& m, format_context& ctx)
  {
    return mf.format(m.get(), ctx);
  }
};

int main()
{
    using namespace std;
    Mint m(145);

}
```

- Şimdiye kadar kullandığımız türler compile-time'da belirtilen string alıyordu.

### vFormat Fonksiyonu

Argümanları doğrudan geçmiyoruz ve make_format fonksiyonun geri dönüş değerini geçiyoruz.

```c++
int main()
{
    using namespace std;
    const char *p = "|{:<12}|";
    char str[20] = "";
    cout << "formatlama bilgisi : ";
    cin >> str;
    int x = 456;
    //auto str = format(str,x); Sentaks hatası
    auto name = std::vformat(str, std::make_format_args(x));
    cout << name << "\n";
}
```

## Aggregate Type

- Bilesşik türler. Sentaksı ayrı ve semantik yapısı ayrı.

### Semantik tarafı

Non static veri elemanlarını doğrudan kullanıma açan sınıflar, bu sınıfların veri elemanları için bir koruma yok.

- Neden? Sınıfları 2'ye ayırmak gerekiyor. Data hiding yapan sınıflar => sınıfın invariantlarının olması ve sınıfın bu invariantlarınıı kendi kontrol ediyor. Invariantlar tutmadığında exception throw edebiliriz.
- Aggregate olup olmamasını belirleyen dilin kurallarınca belirleniyor.
- Bir sınıf olabilir fakat.
- Dizi türleri kesinlikle aggregate type olarak kabul ediliyor. `string x[5]` türü de bir aggregate type.

### Koşulları

1. User-declared constructor'ları olmamalı (**NAN Aggregate**). C++20 öncesinde user-provided constructor'ları olmamalı idi.
2. Non-static veri elemanlarının tamamı public olmalı. C++17 öncesi bunu test etmek için bir meta-function yoktu. `is_aggregate` meta-function'ı eklendi.
3. Aggragate typelar, aggregate olmayan türden veri elemanları alabiliyor.
4. C++17 ile kalıtımla elde edilen sınıflar aggregate olabiliyor.
5. Virtual inheritance olursade aggregate ihlal edilmiş oluyor. **NAN Aggregate**
6. Multiple inharitance olması aggregate olmasına engel değil.
7. Inharited constructor olması durumunda da aggregate olma özelliğini bozuyor. **NAN Aggregate**
8. Referans veri elemanı olması aggregate olmasına engel değil.
9. Member functionları olabilir ve bu fonksiyonların private veya public olması aggregate olmasına engel değil.
10. Sanal fonksiyonlara sahip olamıyorlar. **NAN Aggregate** C++14 ile eklenen default member initializer özelliği eklendi
11. Lambda ifadelerinden elde edilen türler ifadeler aggregate değil. Fakat bu türlerden kalıtım ile edilmiş türler aggregate olabilir (K4). Variant sınıfının overloador idiom'u bundan yararlanıyor.
12. Dizi türleri aggregate.
13. Operator overloading fonksiyonlarınından da yararlanılabiliyor.
14. Statik veri elemanları olabilir.

Koşulların hepsi için örnekler:

```cpp
#include <type_traits>
struct A {  int x;    double d;     char c; };
struct B {  int x;    double d;     char c;
private: //protected olabilir.
    int a; };

struct A1 {    std::string x;    double d;     char c;};
class Myclass{};
struct MDer : Myclass { int a, b; }
struct MDer1 :protected Myclass { int a, b; }
struct SDer : std::string { int a, b;}
struct VDer : virtual Myclass { int a, b; };

class A_{};
class B_{};
class C_{};

struct MABC : A_, B_, C_ {int x,y };

struct RefAgg{int x,y; int &r1İ int &&r2};
class K9
{
public:
    int x,y;
    bar();
private:
    int foo();
protected:
    int baz();
};

struct K10{
    int x = 5;
    int y = 3;
};

struct K13
{
    int mx;
    K13 operator+(const K13&) const;
};

struct K14
{
    static int mx;
    inline stataic std::string str{"deneme"};
};

int main()
{
    static_assert(std::is_aggregate_v<A>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<B>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<std::string>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<sA1>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<Mder>, "not an aggregate"); 
    static_assert(std::is_aggregate_v<Mder1>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<SDer>, "not an aggregate");  
    static_assert(std::is_aggregate_v<VDer>, "not an aggregate"); //not an aggregate
    static_assert(std::is_aggregate_v<MABC>, "not an aggregate");
    static_assert(std::is_aggregate_v<RefAgg>, "not an aggregate");
    static_assert(std::is_aggregate_v<K9>, "not an aggregate");
    static_assert(std::is_aggregate_v<K10>, "not an aggregate");
    static_assert(std::is_aggregate_v<decltype([]{}), "not an aggregate");
}
```

### Faydaları

#### Aggregate Initialization

Aggregate initialization sentaks ile bu türden neseneler oluşturulabiliyor.

- Narrowing conversion hala sentaks hatası. Küme parantezinin eşittirin sağında olması ile direkt kullanılmaması arasında bir fark yok.

```cpp
struct Point{
    int mx, my, mz;
};

struct Dene
{
    int x;
    double d;
    std::string str;
    int ar[4];
    Point
};

int main()
{
    Point p{1,2,3}; 
    Dene mydene {10, 2.3, "mustafa", 3,5,7,8, {1,1,1    }}; //nested küme parantezi kullanmamıza rağment bu ayrıştırma yapılmak zorunda.
}
```

- Aggregateların önemli bir özelliği member sayısından daha az bir sayıda veri elemanı değeri verilmemesi durumunda value initialize ediliyor.

```cpp
struct Myclass
{
    int x;
    int y;
    bool b;
    std::string str;
};
int main()
{
    int a[5] = {1,2,3}; //geriye kalan öğeler 0 olucak.
    std::string ar[4] = {"ali", "veli"}; //geriye kalan öğeler boş string olucak.
    std::cout << ar[2].size()<< "\n"; // 0

    Myclass mycl = {11,22}; // b öğesi false string öğesi boş string olucak.
    std::cout << boolalpha << "mycl.b = " << mycl.b <<  "mycl.str = " << mycl.str.size() << "\n"; //false, ""

}
```

- `Myclass mycl = 5;` şeklinde bir initialization yok. Küme parantezi içerisinde olması gerekiyor.

- Aşağıdaki örnekte `std::array` sınıfı aggregate type olduğu için aggregate initialization yapılabilir. Initailizer list ile alakalı değil.

```c++
int main()
{
    array<int,5> ar{2,4,6,9};
}
```

- Inderminate value oluşabilir. Bunu önlemek için ilk değer verilebilir.

```c++
struct Myclass
{
    int x;
    int y;
};

int main()
{
    using namespace std;
    Myclass mycl;
    cout <<  mycl.x << "\n"; //indeterminate value
}
```

#### Structure Binding

```c++
struct Point{
    int mx, my, mz;
};
int main()
{
    using namespace std;
    Point p{1,2,3};
    auto [x,y,z] = p;
}
```

#### C++20 İle Gelen Değişiklik

C++17'de:

```c++
struct Myclass
{
    int i = 45;
    Myclass() = delete;
}

int main()
{
    Myclass m{}; // bu kod geçerli olucaktı.
    //Myclass m1;  // bu kod geçersiz olucaktı.
}
```

- Aynı durum parametreli constructor delete edilseydi dahi aynı olucaktı. Bu tür durumları ortadan kaldırmak için `user declared` olmaması kararı alındı.

#### Designated Initializer Sentaksı

C'de C99 ile dile eklenen bir özellik. C++20 ile dile eklendi.

- Derleyiciler bunu daha önce extension olarak destekliyor olabilirdi.
- C'deki sentaksı olduğu gibi geçerli değil. C++'da kesiştiği ve kesimediği bir çok yer var.

```c
struct Data
{
    int a,b,c;
    char str{20};
    int ar[5];
};

int main()
{
    int a[10] = {[2] = 4,[7] = 9, 45}; // kalan öğeler 0 olucak. 2 numaralı indis 4, 7 numaralı indis 9 olucak.
    //dizinin boyutu verilmeseydi derleyici dizinin boyutunu en yüksek indeks + 1 olucaktı.
    struct Data mydata = {
        .ar = {2,[3] = 5},
        .str = "dneeme",
    };
}
```

- C++'ta diziler ile böyle bir kural yok.

1. Aggregate type olması gerekiyor.
2. `=` operatörü ile birlikte kullanılıp/kullanılmaması bu duruma etki etmiyor.
3. Designated initializer belirtimi bildirimdeki sıraya göre yapılmak zorunda. İlk değer verilmeyebilir.
4. Normal initializer list ile birlikte kullanılamıyor.
5. Statik veri elemanlarını initialze edemiyoruz

```c++
struct K1{  int x,y,z; };

struct K5{
    int x,y;
    static int z;
};

int main()
{
    K1 k1 = {.x = 10, .y = 20, .z = 30};
    K1 k2{.y = 20, .x = 10, .z = 30}; //geçerli   
    K1 k3{.x = 10, .z = 30}; //geçerli
    K1 k4{.x = 10};
    //K5 k5 {.z = 12} sentaks hatası 
}
```

```c++
struct Time
{
    int min;
    int hour;
};

struct Date
{
    int year;
    int month;
    int day;
    Time time;
    static int hmode;
};

int main()
{
    //Date d1 = {.hmode = 1}; static elemana ilk değer verilmesi hatalı
    //Date d2 = {.month = 3, .year = 2023}; sıranın karışık olması hatalı
    //Date d3 = {3, .year = 2023}; karışık olması hatalı
    //Date d4 = {.time.min = 25}; Nested member için designated initializer kullanılamıyor. 
    const Date d5 = {.time = {32,4}};
    Date mydate = {.time = {.min = 23}};
    Date mdate= { 
        .year{1984},
        .daty{12},
        .time{.hour{18}}
    };
}
```

- const olması durumunda bir hata yok.
- Default member initializer ile birlikte kullanılabilir.

##### Faydası Ne

Kodun okunmasını kolaylaştırıyor ve kodlama hatası riskini anlatıyor.

```c++
struct Student
{
    int id;
    std::string name;
    int grades[5];
};

struct Point
{
    int y,x,z; //bunu yazarken eğer x-y-z şeklinde yazmış olsaydık kullanımda bir hata yapabilirdik.
};

int main()
{
    using namespace std;
    Point p1 = {.y = 10, .x = 20, .z = 30}; // bu şekilde hem hata yapma riski azalıyor hem de kod okunabilirliği artıyor.
    Student s{
        .id = 1233113,
        .name = "Deneme",
        .grades = {100,90,80,70,60}
    };
}
```

Fonksiyonların geri dönüş türü eğer bir aggregate type ise bu sentaks ile geri dönüş değeri verilebilir ve mandatory copy-elision'dan faydalanabiliyoruz.

- Sabit ifadesi olması gerekmiyor.

```c++
struct Person
{
    int id;
    std::string name = "no-name";
    int age;
};

Person get_person()
{
    //codes
   //return Person{.id = 123, .name = "deneme", .age = 45};
   //return {.id = 123, .name = "deneme", .age = 45};
   return {234, "deneme", 45};
}

int main()
{
    auto p = get_person();
    auto [id, name, age] = get_person();
}
```

- Fonksiyonların parametre değişkenin sayısının çok fazla olması bir çok durumda bazı yöntemler kullanılabilir. Ardışık parametreler benzer türlerden veya doğrudan veya dolaylıı olarak aynı değeri alabilecek türdense burada birbirne karışabilir.

```c++
void func(???, double alpha, doble beta, double teta,????)  //??? kısımlarında başka parametreler olduğu düşünülerek,

func(???, a,b,t) // göndermek isterken yanlış bir değer göndermemiz risk yaratıyor olabilir.
```

- Designated kullanımı bunu paketleyip ve parametreyi designated type yapabiliyoruz.

```c++
void process_file(bool open, bool close, bool read, bool write){}    //codes

struct FileProp{
    bool open;
    bool close;
    bool read;
    bool write;
};
void process_file(const FileProp& prop){/*codes*/} 

int main()
{
    //process_file(false, true, false, true); //ne ye true ne ye false verdiğimiz çok belli değil. 
    //process_file(/*open*/ true, /*close*/ false, /*read*/ true, /*write*/ false); //bu şekilde daha okunabilir.
    process_file(FileProp{.open = true, .close = false, .read = true, .write = false});
}
```

- Bazı durumlarda function overload resoulitoon'ı sağlaması için de kullanabiliyoruz.

```c++
struct Point
{
    int x,y;
};

struct Point3D
{
    int dx,dy,dz;
};

void func(const Point& p){
    std::cout << "2D Point\n";
} //codes
void func(const Point3D& p){
    std::cout << "3D Point\n";
} //codes

int main()
{
    func({.x = 10}); //2D Point
    func({.dx = 10}); //3D Point
}
```

### 

```c++

```

